// packages/php-wasm/util/src/lib/semaphore.ts
var Semaphore = class {
  constructor({ concurrency }) {
    this._running = 0;
    this.concurrency = concurrency;
    this.queue = [];
  }
  get running() {
    return this._running;
  }
  async acquire() {
    while (true) {
      if (this._running >= this.concurrency) {
        await new Promise((resolve) => this.queue.push(resolve));
      } else {
        this._running++;
        let released = false;
        return () => {
          if (released) {
            return;
          }
          released = true;
          this._running--;
          if (this.queue.length > 0) {
            this.queue.shift()();
          }
        };
      }
    }
  }
  async run(fn) {
    const release = await this.acquire();
    try {
      return await fn();
    } finally {
      release();
    }
  }
};

// packages/php-wasm/util/src/lib/paths.ts
function joinPaths(...paths) {
  let path = paths.join("/");
  const isAbsolute = path[0] === "/";
  const trailingSlash = path.substring(path.length - 1) === "/";
  path = normalizePath(path);
  if (!path && !isAbsolute) {
    path = ".";
  }
  if (path && trailingSlash) {
    path += "/";
  }
  return path;
}
function dirname(path) {
  if (path === "/") {
    return "/";
  }
  path = normalizePath(path);
  const lastSlash = path.lastIndexOf("/");
  if (lastSlash === -1) {
    return "";
  } else if (lastSlash === 0) {
    return "/";
  }
  return path.substr(0, lastSlash);
}
function basename(path) {
  if (path === "/") {
    return "/";
  }
  path = normalizePath(path);
  const lastSlash = path.lastIndexOf("/");
  if (lastSlash === -1) {
    return path;
  }
  return path.substr(lastSlash + 1);
}
function normalizePath(path) {
  const isAbsolute = path[0] === "/";
  path = normalizePathsArray(
    path.split("/").filter((p) => !!p),
    !isAbsolute
  ).join("/");
  return (isAbsolute ? "/" : "") + path.replace(/\/$/, "");
}
function normalizePathsArray(parts, allowAboveRoot) {
  let up = 0;
  for (let i = parts.length - 1; i >= 0; i--) {
    const last = parts[i];
    if (last === ".") {
      parts.splice(i, 1);
    } else if (last === "..") {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up; up--) {
      parts.unshift("..");
    }
  }
  return parts;
}

// packages/php-wasm/util/src/lib/create-spawn-handler.ts
function createSpawnHandler(program) {
  return function(command) {
    const childProcess = new ChildProcess();
    const processApi = new ProcessApi(childProcess);
    setTimeout(() => {
      program(command, processApi);
    });
    return childProcess;
  };
}
var ProcessApi = class {
  constructor(childProcess) {
    this.childProcess = childProcess;
    this.exited = false;
    this.stdinData = [];
    childProcess.on("stdin", (data) => {
      this.stdinData.push(data);
    });
  }
  stdout(data) {
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
    }
    this.childProcess.stdout.emit("data", data);
  }
  stderr(data) {
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
    }
    this.childProcess.stderr.emit("data", data);
  }
  exit(code) {
    if (!this.exited) {
      this.exited = true;
      this.childProcess.emit("exit", code);
    }
  }
  flushStdin() {
    const data = this.stdinData.join("");
    this.stdinData = [];
    return data;
  }
};
var EventEmitter = class {
  constructor() {
    this.listeners = {};
  }
  emit(eventName, data) {
    if (this.listeners[eventName]) {
      this.listeners[eventName].forEach(function(listener) {
        listener(data);
      });
    }
  }
  on(eventName, listener) {
    if (!this.listeners[eventName]) {
      this.listeners[eventName] = [];
    }
    this.listeners[eventName].push(listener);
  }
};
var ChildProcess = class extends EventEmitter {
  constructor() {
    super();
    this.stdout = new EventEmitter();
    this.stderr = new EventEmitter();
    const self = this;
    this.stdin = {
      write: (data) => {
        self.emit("stdin", data);
      }
    };
  }
};

// packages/php-wasm/util/src/lib/php-vars.ts
function phpVar(value) {
  return `json_decode(base64_decode('${stringToBase64(
    JSON.stringify(value)
  )}'), true)`;
}
function phpVars(vars) {
  const result = {};
  for (const key in vars) {
    result[key] = phpVar(vars[key]);
  }
  return result;
}
function stringToBase64(str) {
  return bytesToBase64(new TextEncoder().encode(str));
}
function bytesToBase64(bytes) {
  const binString = String.fromCodePoint(...bytes);
  return btoa(binString);
}
export {
  Semaphore,
  basename,
  createSpawnHandler,
  dirname,
  joinPaths,
  normalizePath,
  phpVar,
  phpVars
};
