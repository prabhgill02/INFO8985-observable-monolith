if (typeof File > "u") {
  class e extends Blob {
    constructor(r, n, i) {
      super(r);
      let o;
      i != null && i.lastModified && (o = /* @__PURE__ */ new Date()), (!o || isNaN(o.getFullYear())) && (o = /* @__PURE__ */ new Date()), this.lastModifiedDate = o, this.lastModified = o.getMilliseconds(), this.name = n || "";
    }
  }
  global.File = e;
}
function f(e) {
  return new Promise(function(t, r) {
    e.onload = e.onerror = function(n) {
      e.onload = e.onerror = null, n.type === "load" ? t(e.result) : r(new Error("Failed to read the blob/file"));
    };
  });
}
typeof Blob.prototype.arrayBuffer > "u" && (Blob.prototype.arrayBuffer = function() {
  const t = new FileReader();
  return t.readAsArrayBuffer(this), f(t);
});
typeof Blob.prototype.text > "u" && (Blob.prototype.text = function() {
  const t = new FileReader();
  return t.readAsText(this), f(t);
});
function l() {
  const e = new Uint8Array([1, 2, 3, 4]), r = new File([e], "test").stream();
  try {
    return r.getReader({ mode: "byob" }), !0;
  } catch {
    return !1;
  }
}
(typeof Blob.prototype.stream > "u" || !l()) && (Blob.prototype.stream = function() {
  let e = 0;
  const t = this;
  return new ReadableStream({
    type: "bytes",
    // 0.5 MB seems like a reasonable chunk size, let's adjust
    // this if needed.
    autoAllocateChunkSize: 512 * 1024,
    async pull(r) {
      const n = r.byobRequest.view, o = await t.slice(e, e + n.byteLength).arrayBuffer(), s = new Uint8Array(o);
      new Uint8Array(n.buffer).set(s);
      const a = s.byteLength;
      r.byobRequest.respond(a), e += a, e >= t.size && r.close();
    }
  });
});
if (typeof CustomEvent > "u") {
  class e extends Event {
    constructor(r, n = {}) {
      super(r, n), this.detail = n.detail;
    }
    initCustomEvent() {
    }
  }
  globalThis.CustomEvent = e;
}
