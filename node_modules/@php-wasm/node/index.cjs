"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError2 = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError2];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError2] = new RangeError("Max payload size exceeded");
      this[kError2].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError2][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver2;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var net3 = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender2 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(data, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError2 = Symbol("kError");
    var kMessage2 = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event2 = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event2.prototype, "target", { enumerable: true });
    Object.defineProperty(Event2.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event2 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent3 = class extends Event2 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError2] = options.error === void 0 ? null : options.error;
        this[kMessage2] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError2];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage2];
      }
    };
    Object.defineProperty(ErrorEvent3.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent3.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event2 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget2 = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent3("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event2("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent: ErrorEvent3,
      Event: Event2,
      EventTarget: EventTarget2,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http2 = require("http");
    var net3 = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket3 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket3, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket3.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket3.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket3.prototype.addEventListener = addEventListener;
    WebSocket3.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket3;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http2.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location2 = res.headers.location;
        const statusCode = res.statusCode;
        if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location2, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location2}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket3.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket3.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net3.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net3.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket3.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket3.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket3.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket3.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http2 = require("http");
    var https = require("https");
    var net3 = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket3 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer3 = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket3,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer3;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http2.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket3 = require_websocket();
    WebSocket3.createWebSocketStream = require_stream();
    WebSocket3.Server = require_websocket_server();
    WebSocket3.Receiver = require_receiver();
    WebSocket3.Sender = require_sender();
    WebSocket3.WebSocket = WebSocket3;
    WebSocket3.WebSocketServer = WebSocket3.Server;
    module2.exports = WebSocket3;
  }
});

// packages/php-wasm/node/public/php_8_3.js
var php_8_3_exports = {};
__export(php_8_3_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize,
  dependencyFilename: () => dependencyFilename,
  init: () => init
});
function init(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = RuntimeName === "WEB";
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
    } else {
      scriptDirectory = __dirname + "/";
    }
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
    Module["inspect"] = () => "[Emscripten Module object]";
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var noExitRuntime = Module["noExitRuntime"] || false;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var wasmTable;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  var runtimeKeepaliveCounter = 0;
  function keepRuntimeAlive() {
    return noExitRuntime || runtimeKeepaliveCounter > 0;
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  function isFileURI(filename) {
    return filename.startsWith("file://");
  }
  var wasmBinaryFile;
  wasmBinaryFile = dependencyFilename;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
      if (typeof fetch == "function") {
        return fetch(binaryFile, {
          credentials: "same-origin"
        }).then((response) => {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + binaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(() => getBinarySync(binaryFile));
      }
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then((instance) => instance).then(receiver, (reason) => {
      err("failed to asynchronously prepare wasm: " + reason);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err("wasm streaming compile failed: " + reason);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function createWasm() {
    var info = {
      "a": wasmImports
    };
    function receiveInstance(instance, module2) {
      var exports = instance.exports;
      exports = Asyncify.instrumentWasmExports(exports);
      Module["asm"] = exports;
      wasmMemory = Module["asm"]["bb"];
      updateMemoryViews();
      wasmTable = Module["asm"]["fb"];
      addOnInit(Module["asm"]["cb"]);
      removeRunDependency("wasm-instantiate");
      return exports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        return false;
      }
    }
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi.apply(null, [fp, a1]))(sig);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    },
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH_FS = {
    resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, -1);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        } else {
          result = null;
        }
      } else if (typeof window != "undefined" && typeof window.prompt == "function") {
        result = window.prompt("Input: ");
        if (result !== null) {
          result += "\n";
        }
      } else if (typeof readline == "function") {
        result = readline();
        if (result !== null) {
          result += "\n";
        }
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init: function() {
    },
    shutdown: function() {
    },
    register: function(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char: function(tty) {
        return FS_stdin_getChar();
      },
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets: function(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets: function(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz: function(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
      }
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
        old_node.parent = new_dir;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key in node.contents) {
          if (!node.contents.hasOwnProperty(key)) {
            continue;
          }
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach(function(plugin) {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  }
  function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        if (preFinish)
          preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        if (onload)
          onload();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        if (onerror)
          onerror();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, (byteArray) => processData(byteArray), onerror);
    } else {
      processData(url);
    }
  }
  function FS_modeStringToFlags(str) {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  }
  function FS_getMode(canRead, canWrite) {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  }
  var ERRNO_CODES = {};
  var NODEFS = {
    isWindows: false,
    staticInit: () => {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode: (e) => {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    mount: (mount) => NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0),
    createNode: (parent, name, mode, dev) => {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode: (path) => {
      var stat;
      try {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode = stat.mode | (stat.mode & 292) >> 2;
        }
      } catch (e) {
        if (!e.code)
          throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return stat.mode;
    },
    realPath: (node) => {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join.apply(null, parts);
    },
    flagsForNode: (flags) => {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr: (node) => {
        var path = NODEFS.realPath(node);
        var stat;
        try {
          stat = fs.lstatSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        if (NODEFS.isWindows && !stat.blksize) {
          stat.blksize = 4096;
        }
        if (NODEFS.isWindows && !stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr: (node, attr) => {
        var path = NODEFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      lookup: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod: (parent, name, mode, dev) => {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return node;
      },
      rename: (oldNode, newDir, newName) => {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          fs.renameSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        oldNode.name = newName;
      },
      unlink: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.unlinkSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      rmdir: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.rmdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readdir: (node) => {
        var path = NODEFS.realPath(node);
        try {
          return fs.readdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      symlink: (parent, newName, oldPath) => {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        try {
          fs.symlinkSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readlink: (node) => {
        var path = NODEFS.realPath(node);
        try {
          path = fs.readlinkSync(path);
          path = nodePath.relative(nodePath.resolve(node.mount.opts.root), path);
          return path;
        } catch (e) {
          if (!e.code)
            throw e;
          if (e.code === "UNKNOWN")
            throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      }
    },
    stream_ops: {
      open: (stream) => {
        var path = NODEFS.realPath(stream.node);
        try {
          if (FS.isFile(stream.node.mode)) {
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      close: (stream) => {
        try {
          if (FS.isFile(stream.node.mode) && stream.nfd) {
            fs.closeSync(stream.nfd);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      read: (stream, buffer, offset, length, position) => {
        if (length === 0)
          return 0;
        try {
          return fs.readSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      write: (stream, buffer, offset, length, position) => {
        try {
          return fs.writeSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      llseek: (stream, offset, whence) => {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap: (stream, length, position, prot, flags) => {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName: (parentid, name) => {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode: (parent, name) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode: (parent, name, mode, rdev) => {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode: (node) => {
      FS.hashRemoveNode(node);
    },
    isRoot: (node) => node === node.parent,
    isMountpoint: (node) => !!node.mounted,
    isFile: (mode) => (mode & 61440) === 32768,
    isDir: (mode) => (mode & 61440) === 16384,
    isLink: (mode) => (mode & 61440) === 40960,
    isChrdev: (mode) => (mode & 61440) === 8192,
    isBlkdev: (mode) => (mode & 61440) === 24576,
    isFIFO: (mode) => (mode & 61440) === 4096,
    isSocket: (mode) => (mode & 49152) === 49152,
    flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate: (dir, name) => {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete: (dir, name, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked: (fd) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, {
          object: {
            get() {
              return this.node;
            },
            set(val) {
              this.node = val;
            }
          },
          isRead: {
            get() {
              return (this.flags & 2097155) !== 1;
            }
          },
          isWrite: {
            get() {
              return (this.flags & 2097155) !== 0;
            }
          },
          isAppend: {
            get() {
              return this.flags & 1024;
            }
          },
          flags: {
            get() {
              return this.shared.flags;
            },
            set(val) {
              this.shared.flags = val;
            }
          },
          position: {
            get() {
              return this.shared.position;
            },
            set(val) {
              this.shared.position = val;
            }
          }
        });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream: (fd) => {
      FS.streams[fd] = null;
    },
    chrdev_stream_ops: {
      open: (stream) => {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      },
      llseek: () => {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice: (dev, ops) => {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    },
    syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount: (type, opts, mountpoint) => {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount: (mountpoint) => {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup: (parent, name) => parent.node_ops.lookup(parent, name),
    mknod: (path, mode, dev) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink: (path) => {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat: (path, dontFollow) => {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat: (path) => FS.stat(path, true),
    chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    },
    fchmod: (fd, mode) => {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    },
    fchown: (fd, uid, gid) => {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate: (fd, len) => {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime: (path, atime, mtime) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed: (stream) => stream.fd === null,
    llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read: (stream, buffer, offset, length, position) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write: (stream, buffer, offset, length, position, canOwn) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync: (stream, buffer, offset, length, mmapFlags) => {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    munmap: (stream) => 0,
    ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount: () => {
          var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: (parent, name) => {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams: () => {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
        };
        this.setErrno(errno);
        this.message = "FS error";
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    },
    staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS
      };
    },
    init: (input, output, error) => {
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile: (parent, name, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    },
    createDevice: (parent, name, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open: (stream) => {
          stream.seekable = false;
        },
        close: (stream) => {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        },
        read: (stream, buffer, offset, length, pos) => {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: (stream, buffer, offset, length, pos) => {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile: (parent, name, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, {
          length: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            }
          },
          chunkSize: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            }
          }
        });
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    varargs: void 0,
    get() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    },
    getStreamFromFD: function(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    }
  };
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
    try {
      var total = 0;
      var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;
      var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;
      var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;
      var dstReadLow = 0, dstReadHigh = 0;
      var dstWriteLow = 0, dstWriteHigh = 0;
      var dstExceptLow = 0, dstExceptHigh = 0;
      var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);
      var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);
      var check = function(fd2, low, high, val) {
        return fd2 < 32 ? low & val : high & val;
      };
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << fd % 32;
        if (!check(fd, allLow, allHigh, mask)) {
          continue;
        }
        var stream = SYSCALLS.getStreamFromFD(fd);
        var flags = SYSCALLS.DEFAULT_POLLMASK;
        if (stream.stream_ops?.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            var tv_sec = readfds ? HEAP32[timeout >> 2] : 0, tv_usec = readfds ? HEAP32[timeout + 8 >> 2] : 0;
            timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }
        if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
          total++;
        }
        if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
          total++;
        }
        if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
          total++;
        }
      }
      if (readfds) {
        HEAP32[readfds >> 2] = dstReadLow;
        HEAP32[readfds + 4 >> 2] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[writefds >> 2] = dstWriteLow;
        HEAP32[writefds + 4 >> 2] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[exceptfds >> 2] = dstExceptLow;
        HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;
      }
      return total;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  function getSocketFromFD(fd) {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  }
  var setErrNo = (value) => {
    HEAP32[___errno_location() >> 2] = value;
    return value;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name: (name) => {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr: (addr) => {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  function getSocketAddress(addrp, addrlen, allowNull) {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  }
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.createStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.createStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function convertI32PairToI53Checked(lo, hi) {
    return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  }
  function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    var len = convertI32PairToI53Checked(len_low, len_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5: {
          var arg = SYSCALLS.get();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 6:
        case 7:
          return 0;
        case 16:
        case 8:
          return -28;
        case 9:
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18 >> 0] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17 >> 0] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = SYSCALLS.get();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17 >> 0]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = SYSCALLS.get();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = SYSCALLS.get();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function readI53FromI64(ptr) {
    return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  }
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var nowIsMonotonic = true;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      return date.getTime() / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      if (Module["onExit"])
        Module["onExit"](code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var stringToNewUTF8 = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = _malloc(size);
    if (ret)
      stringToUTF8(str, ret, size);
    return ret;
  };
  var __tzset_js = (timezone, daylight, tzname) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    function extractZone(date) {
      var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
      return match ? match[1] : "GMT";
    }
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    var winterNamePtr = stringToNewUTF8(winterName);
    var summerNamePtr = stringToNewUTF8(summerName);
    if (summerOffset < winterOffset) {
      HEAPU32[tzname >> 2] = winterNamePtr;
      HEAPU32[tzname + 4 >> 2] = summerNamePtr;
    } else {
      HEAPU32[tzname >> 2] = summerNamePtr;
      HEAPU32[tzname + 4 >> 2] = winterNamePtr;
    }
  };
  var _abort = () => {
    abort("");
  };
  function _emscripten_date_now() {
    return Date.now();
  }
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = size - b.byteLength + 65535 >>> 16;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = function(ms) {
    return Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  };
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    }
    HEAP8[buffer >> 0] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf >> 0] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_sync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep(function(wakeUp) {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, function(err2) {
          if (err2) {
            wakeUp(function() {
              return 29;
            });
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  function _getcontext() {
    err("missing function: getcontext");
    abort(-1);
  }
  function _getdtablesize() {
    err("missing function: getdtablesize");
    abort(-1);
  }
  var getHostByName = (name) => {
    var ret = _malloc(20);
    var nameBuf = stringToNewUTF8(name);
    HEAPU32[ret >> 2] = nameBuf;
    var aliasesBuf = _malloc(4);
    HEAPU32[aliasesBuf >> 2] = 0;
    HEAPU32[ret + 4 >> 2] = aliasesBuf;
    var afinet = 2;
    HEAP32[ret + 8 >> 2] = afinet;
    HEAP32[ret + 12 >> 2] = 4;
    var addrListBuf = _malloc(12);
    HEAPU32[addrListBuf >> 2] = addrListBuf + 8;
    HEAPU32[addrListBuf + 4 >> 2] = 0;
    HEAP32[addrListBuf + 8 >> 2] = inetPton4(DNS.lookup_name(name));
    HEAPU32[ret + 16 >> 2] = addrListBuf;
    return ret;
  };
  var _gethostbyname = (name) => getHostByName(UTF8ToString(name));
  var _gethostbyname_r = (name, ret, buf, buflen, out2, err2) => {
    var data = _gethostbyname(name);
    _memcpy(ret, data, 20);
    _free(data);
    HEAP32[err2 >> 2] = 0;
    HEAPU32[out2 >> 2] = ret;
    return 0;
  };
  var _getloadavg = (loadavg, nelem) => {
    var limit = Math.min(nelem, 3);
    var doubleSize = 8;
    for (var i = 0; i < limit; i++) {
      HEAPF64[loadavg + i * doubleSize >> 3] = 0.1;
    }
    return limit;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitWsEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "error");
    },
    awaitWsEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command) {
      if (Module["spawnProcess"]) {
        const spawned = Module["spawnProcess"](command);
        if (!spawned || !spawned.on) {
          throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
        }
        return spawned;
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, [], {
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(procopenCallId) {
    if (!PHPWASM.input_devices) {
      PHPWASM.input_devices = {};
    }
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + procopenCallId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[procopenCallId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    var returnCode;
    var stream;
    try {
      stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      returnCode = 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      returnCode = e.errno;
    }
    if (returnCode === 6 && stream?.fd in PHPWASM.proc_fds) {
      return Asyncify.handleSleep(function(wakeUp) {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            var num2 = doReadv(stream2, iov, iovcnt);
            HEAPU32[pnum >> 2] = num2;
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          if (returnCode2 !== 6 || ++retries > maxRetries || !(stream2?.fd in PHPWASM.proc_fds) || PHPWASM.proc_fds[stream2?.fd]?.exited || FS.isClosed(stream2) || !(PHPWASM.proc_fds[fd]?.stdinFd in (PHPWASM.input_devices || {}))) {
            wakeUp(returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    }
    return returnCode;
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(0);
        });
      });
    }
  }
  function _js_open_process(command, stdinFd, stdoutChildFd, stdoutParentFd, stderrChildFd, stderrParentFd) {
    if (!PHPWASM.proc_fds) {
      PHPWASM.proc_fds = {};
    }
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let cp;
    try {
      cp = PHPWASM.spawnProcess(cmdstr);
    } catch (e) {
      if (e.code === "SPAWN_UNSUPPORTED") {
        return 1;
      }
      throw e;
    }
    let EventEmitter;
    if (ENVIRONMENT_IS_NODE) {
      EventEmitter = require("events").EventEmitter;
    } else {
      EventEmitter = function() {
        this.listeners = {};
      };
      EventEmitter.prototype.emit = function(eventName, data) {
        if (this.listeners[eventName]) {
          this.listeners[eventName].forEach(function(callback) {
            callback(data);
          });
        }
      };
      EventEmitter.prototype.once = function(eventName, callback) {
        const self2 = this;
        function removedCallback() {
          callback(...arguments);
          self2.removeListener(eventName, removedCallback);
        }
        this.on(eventName, removedCallback);
      };
      EventEmitter.prototype.on = function(eventName, callback) {
        if (!this.listeners[eventName]) {
          this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(callback);
      };
      EventEmitter.prototype.removeListener = function(eventName, callback) {
        const idx = this.listeners[eventName].indexOf(callback);
        if (idx !== -1) {
          this.listeners[eventName].splice(idx, 1);
        }
      };
    }
    PHPWASM.proc_fds[stdoutParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stdoutParentFd].stdinFd = stdinFd;
    PHPWASM.proc_fds[stderrParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stderrParentFd].stdinFd = stdinFd;
    const stdoutStream = SYSCALLS.getStreamFromFD(stdoutChildFd);
    cp.on("exit", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].exited = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      PHPWASM.proc_fds[stderrParentFd].exited = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
    });
    cp.stdout.on("data", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].hasData = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, 0);
    });
    const stderrStream = SYSCALLS.getStreamFromFD(stderrChildFd);
    cp.stderr.on("data", function(data) {
      PHPWASM.proc_fds[stderrParentFd].hasData = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
      stderrStream.stream_ops.write(stderrStream, data, 0, data.length, 0);
    });
    if (PHPWASM.input_devices && stdinFd in PHPWASM.input_devices) {
      PHPWASM.input_devices[stdinFd].onData(function(data) {
        if (!data)
          return;
        const dataStr = new TextDecoder("utf-8").decode(data);
        cp.stdin.write(dataStr);
      });
      return 0;
    }
    const stdinStream = SYSCALLS.getStreamFromFD(stdinFd);
    if (!stdinStream.node) {
      return 0;
    }
    const CHUNK_SIZE = 1024;
    const buffer = Buffer.alloc(CHUNK_SIZE);
    let offset = 0;
    while (true) {
      const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
      if (bytesRead === null || bytesRead === 0) {
        break;
      }
      try {
        cp.stdin.write(buffer.subarray(0, bytesRead));
      } catch (e) {
        console.error(e);
        return 1;
      }
      if (bytesRead < CHUNK_SIZE) {
        break;
      }
      offset += bytesRead;
    }
    return 0;
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep((wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr);
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _makecontext() {
    err("missing function: makecontext");
    abort(-1);
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAP32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": (date2) => getWeekBasedYear(date2),
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "%A": "%a",
      "%B": "%b",
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m\\/%d\\/%y",
      "%e": "%d",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%R": "%H\\:%M",
      "%r": "%I\\:%M\\:%S\\s%p",
      "%T": "%H\\:%M\\:%S",
      "%x": "%m\\/%d\\/(?:%y|%Y)",
      "%X": "%H\\:%M\\:%S"
    };
    for (var matcher in EQUIVALENT_MATCHERS) {
      pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
    }
    var DATE_PATTERNS = {
      "%a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      "%b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      "%C": "\\d\\d",
      "%d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      "%H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      "%I": "\\d(?!\\d)|0\\d|10|11|12",
      "%j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      "%m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      "%M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      "%n": "\\s",
      "%p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      "%S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      "%U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%w": "[0-6]",
      "%y": "\\d\\d",
      "%Y": "\\d\\d\\d\\d",
      "%%": "%",
      "%t": "\\s"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    for (var datePattern in DATE_PATTERNS) {
      pattern = pattern.replace(datePattern, "(" + datePattern + DATE_PATTERNS[datePattern] + ")");
    }
    var capture = [];
    for (var i = pattern.indexOf("%"); i >= 0; i = pattern.indexOf("%")) {
      capture.push(pattern[i + 1]);
      pattern = pattern.replace(new RegExp("\\%" + pattern[i + 1], "g"), "");
    }
    var matches = new RegExp("^" + pattern, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59)
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _swapcontext() {
    err("missing function: swapcontext");
    abort(-1);
  }
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (PHPWASM.proc_fds && socketd in PHPWASM.proc_fds) {
        const emitter = PHPWASM.proc_fds[socketd];
        if (emitter.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitWsEvent(emitter, "data"));
      } else {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  function runAndAbortIfError(func) {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  }
  var Asyncify = {
    instrumentWasmImports: function(imports) {
      var importPatterns = [/^_dlopen_js$/, /^invoke_i$/, /^invoke_ii$/, /^invoke_iii$/, /^invoke_iiii$/, /^invoke_iiiii$/, /^invoke_iiiiii$/, /^invoke_iiiiiii$/, /^invoke_iiiiiiii$/, /^invoke_iiiiiiiiii$/, /^invoke_v$/, /^invoke_vi$/, /^invoke_vii$/, /^invoke_viidii$/, /^invoke_viii$/, /^invoke_viiii$/, /^invoke_viiiii$/, /^invoke_viiiiii$/, /^invoke_viiiiiii$/, /^invoke_viiiiiiiii$/, /^js_open_process$/, /^js_popen_to_file$/, /^js_fd_read$/, /^js_module_onMessage$/, /^wasm_poll_socket$/, /^wasm_shutdown$/, /^fd_sync$/, /^__wasi_fd_sync$/, /^__asyncjs__.*$/, /^emscripten_promise_await$/, /^emscripten_idb_load$/, /^emscripten_idb_store$/, /^emscripten_idb_delete$/, /^emscripten_idb_exists$/, /^emscripten_idb_load_blob$/, /^emscripten_idb_store_blob$/, /^emscripten_sleep$/, /^emscripten_wget_data$/, /^emscripten_scan_registers$/, /^emscripten_lazy_load_code$/, /^_load_secondary_module$/, /^emscripten_fiber_swap$/, /^SDL_Delay$/];
      for (var x in imports) {
        (function(x2) {
          var original = imports[x2];
          var sig = original.sig;
          if (typeof original == "function") {
            var isAsyncifyImport = original.isAsync || importPatterns.some((pattern) => !!x2.match(pattern));
          }
        })(x);
      }
    },
    instrumentWasmExports: function(exports) {
      var ret = {};
      for (var x in exports) {
        (function(x2) {
          var original = exports[x2];
          if (typeof original == "function") {
            ret[x2] = function() {
              Asyncify.exportCallStack.push(x2);
              try {
                return original.apply(null, arguments);
              } finally {
                if (!ABORT) {
                  var y = Asyncify.exportCallStack.pop();
                  assert(y === x2);
                  Asyncify.maybeStopUnwind();
                }
              }
            };
          } else {
            ret[x2] = original;
          }
        })(x);
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId: function(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind: function() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone: function() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData: function() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader: function(ptr, stack, stackSize) {
      HEAP32[ptr >> 2] = stack;
      HEAP32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc: function(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFunc: function(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      var func = Module["asm"][name];
      return func;
    },
    doRewind: function(ptr) {
      var start = Asyncify.getDataRewindFunc(ptr);
      runtimeKeepalivePop();
      return start();
    },
    handleSleep: function(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach((func) => callUserCallback(func));
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync: function(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  function getCFunc(ident) {
    var func = Module["_" + ident];
    return func;
  }
  var ccall = function(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func.apply(null, cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts && opts.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FSNode = function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
    read: {
      get: function() {
        return (this.mode & readMode) === readMode;
      },
      set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }
    },
    write: {
      get: function() {
        return (this.mode & writeMode) === writeMode;
      },
      set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }
    },
    isFolder: {
      get: function() {
        return FS.isDir(this.mode);
      }
    },
    isDevice: {
      get: function() {
        return FS.isChrdev(this.mode);
      }
    }
  });
  FS.FSNode = FSNode;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var wasmImports = {
    l: ___assert_fail,
    ab: ___call_sighandler,
    $a: ___syscall__newselect,
    _a: ___syscall_accept4,
    Za: ___syscall_bind,
    Ya: ___syscall_chdir,
    S: ___syscall_chmod,
    Xa: ___syscall_connect,
    Wa: ___syscall_dup,
    Va: ___syscall_dup3,
    Ua: ___syscall_faccessat,
    ca: ___syscall_fallocate,
    Ta: ___syscall_fchmod,
    Sa: ___syscall_fchown32,
    R: ___syscall_fchownat,
    n: ___syscall_fcntl64,
    Ra: ___syscall_fdatasync,
    Qa: ___syscall_fstat64,
    ba: ___syscall_ftruncate64,
    Pa: ___syscall_getcwd,
    Oa: ___syscall_getdents64,
    Na: ___syscall_getpeername,
    Ma: ___syscall_getsockname,
    La: ___syscall_getsockopt,
    Q: ___syscall_ioctl,
    Ka: ___syscall_listen,
    Ja: ___syscall_lstat64,
    Ia: ___syscall_mkdirat,
    Ha: ___syscall_newfstatat,
    x: ___syscall_openat,
    Ga: ___syscall_pipe,
    Fa: ___syscall_poll,
    Ea: ___syscall_readlinkat,
    Da: ___syscall_recvfrom,
    Ca: ___syscall_renameat,
    P: ___syscall_rmdir,
    Ba: ___syscall_sendto,
    O: ___syscall_socket,
    Aa: ___syscall_stat64,
    za: ___syscall_statfs64,
    ya: ___syscall_symlink,
    E: ___syscall_unlinkat,
    xa: ___syscall_utimensat,
    sa: __emscripten_get_now_is_monotonic,
    ra: __emscripten_throw_longjmp,
    $: __gmtime_js,
    _: __localtime_js,
    Z: __mktime_js,
    Y: __mmap_js,
    X: __munmap_js,
    L: __setitimer_js,
    qa: __tzset_js,
    g: _abort,
    C: _emscripten_date_now,
    pa: _emscripten_get_heap_max,
    u: _emscripten_get_now,
    oa: _emscripten_memcpy_big,
    na: _emscripten_resize_heap,
    K: _emscripten_sleep,
    wa: _environ_get,
    va: _environ_sizes_get,
    q: _exit,
    r: _fd_close,
    N: _fd_fdstat_get,
    M: _fd_read,
    aa: _fd_seek,
    ua: _fd_sync,
    D: _fd_write,
    ma: _getaddrinfo,
    la: _getcontext,
    ka: _getdtablesize,
    J: _gethostbyname_r,
    ja: _getloadavg,
    w: _getnameinfo,
    ia: _getprotobyname,
    ha: _getprotobynumber,
    k: invoke_i,
    c: invoke_ii,
    b: invoke_iii,
    f: invoke_iiii,
    j: invoke_iiiii,
    o: invoke_iiiiii,
    t: invoke_iiiiiii,
    v: invoke_iiiiiiii,
    I: invoke_iiiiiiiiii,
    e: invoke_v,
    a: invoke_vi,
    d: invoke_vii,
    B: invoke_viidii,
    i: invoke_viii,
    m: invoke_viiii,
    h: invoke_viiiii,
    A: invoke_viiiiii,
    ga: invoke_viiiiiii,
    z: invoke_viiiiiiiii,
    H: _js_create_input_device,
    fa: _js_fd_read,
    ea: _js_module_onMessage,
    G: _js_open_process,
    da: _js_popen_to_file,
    W: _makecontext,
    ta: _proc_exit,
    F: _strftime,
    V: _strptime,
    U: _swapcontext,
    s: _wasm_close,
    y: _wasm_poll_socket,
    p: _wasm_setsockopt,
    T: _wasm_shutdown
  };
  var asm = createWasm();
  var ___wasm_call_ctors = function() {
    return (___wasm_call_ctors = Module["asm"]["cb"]).apply(null, arguments);
  };
  var _free = function() {
    return (_free = Module["asm"]["db"]).apply(null, arguments);
  };
  var _memcpy = function() {
    return (_memcpy = Module["asm"]["eb"]).apply(null, arguments);
  };
  var _malloc = function() {
    return (_malloc = Module["asm"]["gb"]).apply(null, arguments);
  };
  var ___errno_location = function() {
    return (___errno_location = Module["asm"]["hb"]).apply(null, arguments);
  };
  var setTempRet0 = function() {
    return (setTempRet0 = Module["asm"]["ib"]).apply(null, arguments);
  };
  var _wasm_popen = Module["_wasm_popen"] = function() {
    return (_wasm_popen = Module["_wasm_popen"] = Module["asm"]["jb"]).apply(null, arguments);
  };
  var _wasm_php_exec = Module["_wasm_php_exec"] = function() {
    return (_wasm_php_exec = Module["_wasm_php_exec"] = Module["asm"]["kb"]).apply(null, arguments);
  };
  var _php_pollfd_for = Module["_php_pollfd_for"] = function() {
    return (_php_pollfd_for = Module["_php_pollfd_for"] = Module["asm"]["lb"]).apply(null, arguments);
  };
  var _htons = function() {
    return (_htons = Module["asm"]["mb"]).apply(null, arguments);
  };
  var _ntohs = function() {
    return (_ntohs = Module["asm"]["nb"]).apply(null, arguments);
  };
  var _htonl = function() {
    return (_htonl = Module["asm"]["ob"]).apply(null, arguments);
  };
  var _wasm_sleep = Module["_wasm_sleep"] = function() {
    return (_wasm_sleep = Module["_wasm_sleep"] = Module["asm"]["pb"]).apply(null, arguments);
  };
  var _fflush = Module["_fflush"] = function() {
    return (_fflush = Module["_fflush"] = Module["asm"]["qb"]).apply(null, arguments);
  };
  var _wasm_read = Module["_wasm_read"] = function() {
    return (_wasm_read = Module["_wasm_read"] = Module["asm"]["rb"]).apply(null, arguments);
  };
  var _wasm_select = Module["_wasm_select"] = function() {
    return (_wasm_select = Module["_wasm_select"] = Module["asm"]["sb"]).apply(null, arguments);
  };
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = function() {
    return (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = Module["asm"]["tb"]).apply(null, arguments);
  };
  var _run_cli = Module["_run_cli"] = function() {
    return (_run_cli = Module["_run_cli"] = Module["asm"]["ub"]).apply(null, arguments);
  };
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = function() {
    return (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = Module["asm"]["vb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = function() {
    return (_wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = Module["asm"]["wb"]).apply(null, arguments);
  };
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = function() {
    return (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = Module["asm"]["xb"]).apply(null, arguments);
  };
  var _wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = function() {
    return (_wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = Module["asm"]["yb"]).apply(null, arguments);
  };
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = function() {
    return (_wasm_set_query_string = Module["_wasm_set_query_string"] = Module["asm"]["zb"]).apply(null, arguments);
  };
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = function() {
    return (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = Module["asm"]["Ab"]).apply(null, arguments);
  };
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = function() {
    return (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = Module["asm"]["Bb"]).apply(null, arguments);
  };
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = function() {
    return (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = Module["asm"]["Cb"]).apply(null, arguments);
  };
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = function() {
    return (_wasm_set_request_method = Module["_wasm_set_request_method"] = Module["asm"]["Db"]).apply(null, arguments);
  };
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = function() {
    return (_wasm_set_request_host = Module["_wasm_set_request_host"] = Module["asm"]["Eb"]).apply(null, arguments);
  };
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = function() {
    return (_wasm_set_content_type = Module["_wasm_set_content_type"] = Module["asm"]["Fb"]).apply(null, arguments);
  };
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = function() {
    return (_wasm_set_request_body = Module["_wasm_set_request_body"] = Module["asm"]["Gb"]).apply(null, arguments);
  };
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = function() {
    return (_wasm_set_content_length = Module["_wasm_set_content_length"] = Module["asm"]["Hb"]).apply(null, arguments);
  };
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = function() {
    return (_wasm_set_cookies = Module["_wasm_set_cookies"] = Module["asm"]["Ib"]).apply(null, arguments);
  };
  var _wasm_set_php_code = Module["_wasm_set_php_code"] = function() {
    return (_wasm_set_php_code = Module["_wasm_set_php_code"] = Module["asm"]["Jb"]).apply(null, arguments);
  };
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = function() {
    return (_wasm_set_request_port = Module["_wasm_set_request_port"] = Module["asm"]["Kb"]).apply(null, arguments);
  };
  var _phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = function() {
    return (_phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = Module["asm"]["Lb"]).apply(null, arguments);
  };
  var _phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = function() {
    return (_phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = Module["asm"]["Mb"]).apply(null, arguments);
  };
  var _phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = function() {
    return (_phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = Module["asm"]["Nb"]).apply(null, arguments);
  };
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = function() {
    return (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = Module["asm"]["Ob"]).apply(null, arguments);
  };
  var _php_wasm_init = Module["_php_wasm_init"] = function() {
    return (_php_wasm_init = Module["_php_wasm_init"] = Module["asm"]["Pb"]).apply(null, arguments);
  };
  var ___funcs_on_exit = function() {
    return (___funcs_on_exit = Module["asm"]["Qb"]).apply(null, arguments);
  };
  var _emscripten_builtin_memalign = function() {
    return (_emscripten_builtin_memalign = Module["asm"]["Rb"]).apply(null, arguments);
  };
  var __emscripten_timeout = function() {
    return (__emscripten_timeout = Module["asm"]["Sb"]).apply(null, arguments);
  };
  var _setThrew = function() {
    return (_setThrew = Module["asm"]["Tb"]).apply(null, arguments);
  };
  var _emscripten_stack_set_limits = function() {
    return (_emscripten_stack_set_limits = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
  };
  var _emscripten_stack_get_base = function() {
    return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
  };
  var _emscripten_stack_get_end = function() {
    return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
  };
  var stackSave = function() {
    return (stackSave = Module["asm"]["Ub"]).apply(null, arguments);
  };
  var stackRestore = function() {
    return (stackRestore = Module["asm"]["Vb"]).apply(null, arguments);
  };
  var stackAlloc = function() {
    return (stackAlloc = Module["asm"]["Wb"]).apply(null, arguments);
  };
  var dynCall_iiii = Module["dynCall_iiii"] = function() {
    return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["Xb"]).apply(null, arguments);
  };
  var dynCall_ii = Module["dynCall_ii"] = function() {
    return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["Yb"]).apply(null, arguments);
  };
  var dynCall_vi = Module["dynCall_vi"] = function() {
    return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["Zb"]).apply(null, arguments);
  };
  var dynCall_vii = Module["dynCall_vii"] = function() {
    return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["_b"]).apply(null, arguments);
  };
  var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
    return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["$b"]).apply(null, arguments);
  };
  var dynCall_iii = Module["dynCall_iii"] = function() {
    return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["ac"]).apply(null, arguments);
  };
  var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
    return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["bc"]).apply(null, arguments);
  };
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
    return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["cc"]).apply(null, arguments);
  };
  var dynCall_viii = Module["dynCall_viii"] = function() {
    return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["dc"]).apply(null, arguments);
  };
  var dynCall_v = Module["dynCall_v"] = function() {
    return (dynCall_v = Module["dynCall_v"] = Module["asm"]["ec"]).apply(null, arguments);
  };
  var dynCall_i = Module["dynCall_i"] = function() {
    return (dynCall_i = Module["dynCall_i"] = Module["asm"]["fc"]).apply(null, arguments);
  };
  var dynCall_viiii = Module["dynCall_viiii"] = function() {
    return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["gc"]).apply(null, arguments);
  };
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
    return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["hc"]).apply(null, arguments);
  };
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {
    return (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = Module["asm"]["ic"]).apply(null, arguments);
  };
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = function() {
    return (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = Module["asm"]["jc"]).apply(null, arguments);
  };
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
    return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["kc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
    return (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = Module["asm"]["lc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = function() {
    return (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = Module["asm"]["mc"]).apply(null, arguments);
  };
  var dynCall_viidii = Module["dynCall_viidii"] = function() {
    return (dynCall_viidii = Module["dynCall_viidii"] = Module["asm"]["nc"]).apply(null, arguments);
  };
  var _asyncify_start_unwind = function() {
    return (_asyncify_start_unwind = Module["asm"]["oc"]).apply(null, arguments);
  };
  var _asyncify_stop_unwind = function() {
    return (_asyncify_stop_unwind = Module["asm"]["pc"]).apply(null, arguments);
  };
  var _asyncify_start_rewind = function() {
    return (_asyncify_start_rewind = Module["asm"]["qc"]).apply(null, arguments);
  };
  var _asyncify_stop_rewind = function() {
    return (_asyncify_stop_rewind = Module["asm"]["rc"]).apply(null, arguments);
  };
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  Module["FS_unlink"] = FS.unlink;
  Module["ccall"] = ccall;
  Module["UTF8ToString"] = UTF8ToString;
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS"] = FS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  return PHPLoader;
}
var dependencyFilename, dependenciesTotalSize;
var init_php_8_3 = __esm({
  "packages/php-wasm/node/public/php_8_3.js"() {
    "use strict";
    dependencyFilename = __dirname + "/8_3_0/php_8_3.wasm";
    dependenciesTotalSize = 11367550;
  }
});

// packages/php-wasm/node/public/php_8_2.js
var php_8_2_exports = {};
__export(php_8_2_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize2,
  dependencyFilename: () => dependencyFilename2,
  init: () => init2
});
function init2(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = RuntimeName === "WEB";
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
    } else {
      scriptDirectory = __dirname + "/";
    }
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
    Module["inspect"] = () => "[Emscripten Module object]";
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var noExitRuntime = Module["noExitRuntime"] || false;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var wasmTable;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  var runtimeKeepaliveCounter = 0;
  function keepRuntimeAlive() {
    return noExitRuntime || runtimeKeepaliveCounter > 0;
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  function isFileURI(filename) {
    return filename.startsWith("file://");
  }
  var wasmBinaryFile;
  wasmBinaryFile = dependencyFilename2;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
      if (typeof fetch == "function") {
        return fetch(binaryFile, {
          credentials: "same-origin"
        }).then((response) => {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + binaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(() => getBinarySync(binaryFile));
      }
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then((instance) => instance).then(receiver, (reason) => {
      err("failed to asynchronously prepare wasm: " + reason);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err("wasm streaming compile failed: " + reason);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function createWasm() {
    var info = {
      "a": wasmImports
    };
    function receiveInstance(instance, module2) {
      var exports = instance.exports;
      exports = Asyncify.instrumentWasmExports(exports);
      Module["asm"] = exports;
      wasmMemory = Module["asm"]["bb"];
      updateMemoryViews();
      wasmTable = Module["asm"]["fb"];
      addOnInit(Module["asm"]["cb"]);
      removeRunDependency("wasm-instantiate");
      return exports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        return false;
      }
    }
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi.apply(null, [fp, a1]))(sig);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    },
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH_FS = {
    resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, -1);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        } else {
          result = null;
        }
      } else if (typeof window != "undefined" && typeof window.prompt == "function") {
        result = window.prompt("Input: ");
        if (result !== null) {
          result += "\n";
        }
      } else if (typeof readline == "function") {
        result = readline();
        if (result !== null) {
          result += "\n";
        }
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init: function() {
    },
    shutdown: function() {
    },
    register: function(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char: function(tty) {
        return FS_stdin_getChar();
      },
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets: function(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets: function(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz: function(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
      }
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
        old_node.parent = new_dir;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key in node.contents) {
          if (!node.contents.hasOwnProperty(key)) {
            continue;
          }
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach(function(plugin) {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  }
  function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        if (preFinish)
          preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        if (onload)
          onload();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        if (onerror)
          onerror();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, (byteArray) => processData(byteArray), onerror);
    } else {
      processData(url);
    }
  }
  function FS_modeStringToFlags(str) {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  }
  function FS_getMode(canRead, canWrite) {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  }
  var ERRNO_CODES = {};
  var NODEFS = {
    isWindows: false,
    staticInit: () => {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode: (e) => {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    mount: (mount) => NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0),
    createNode: (parent, name, mode, dev) => {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode: (path) => {
      var stat;
      try {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode = stat.mode | (stat.mode & 292) >> 2;
        }
      } catch (e) {
        if (!e.code)
          throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return stat.mode;
    },
    realPath: (node) => {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join.apply(null, parts);
    },
    flagsForNode: (flags) => {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr: (node) => {
        var path = NODEFS.realPath(node);
        var stat;
        try {
          stat = fs.lstatSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        if (NODEFS.isWindows && !stat.blksize) {
          stat.blksize = 4096;
        }
        if (NODEFS.isWindows && !stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr: (node, attr) => {
        var path = NODEFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      lookup: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod: (parent, name, mode, dev) => {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return node;
      },
      rename: (oldNode, newDir, newName) => {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          fs.renameSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        oldNode.name = newName;
      },
      unlink: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.unlinkSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      rmdir: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.rmdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readdir: (node) => {
        var path = NODEFS.realPath(node);
        try {
          return fs.readdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      symlink: (parent, newName, oldPath) => {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        try {
          fs.symlinkSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readlink: (node) => {
        var path = NODEFS.realPath(node);
        try {
          path = fs.readlinkSync(path);
          path = nodePath.relative(nodePath.resolve(node.mount.opts.root), path);
          return path;
        } catch (e) {
          if (!e.code)
            throw e;
          if (e.code === "UNKNOWN")
            throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      }
    },
    stream_ops: {
      open: (stream) => {
        var path = NODEFS.realPath(stream.node);
        try {
          if (FS.isFile(stream.node.mode)) {
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      close: (stream) => {
        try {
          if (FS.isFile(stream.node.mode) && stream.nfd) {
            fs.closeSync(stream.nfd);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      read: (stream, buffer, offset, length, position) => {
        if (length === 0)
          return 0;
        try {
          return fs.readSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      write: (stream, buffer, offset, length, position) => {
        try {
          return fs.writeSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      llseek: (stream, offset, whence) => {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap: (stream, length, position, prot, flags) => {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName: (parentid, name) => {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode: (parent, name) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode: (parent, name, mode, rdev) => {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode: (node) => {
      FS.hashRemoveNode(node);
    },
    isRoot: (node) => node === node.parent,
    isMountpoint: (node) => !!node.mounted,
    isFile: (mode) => (mode & 61440) === 32768,
    isDir: (mode) => (mode & 61440) === 16384,
    isLink: (mode) => (mode & 61440) === 40960,
    isChrdev: (mode) => (mode & 61440) === 8192,
    isBlkdev: (mode) => (mode & 61440) === 24576,
    isFIFO: (mode) => (mode & 61440) === 4096,
    isSocket: (mode) => (mode & 49152) === 49152,
    flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate: (dir, name) => {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete: (dir, name, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked: (fd) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, {
          object: {
            get() {
              return this.node;
            },
            set(val) {
              this.node = val;
            }
          },
          isRead: {
            get() {
              return (this.flags & 2097155) !== 1;
            }
          },
          isWrite: {
            get() {
              return (this.flags & 2097155) !== 0;
            }
          },
          isAppend: {
            get() {
              return this.flags & 1024;
            }
          },
          flags: {
            get() {
              return this.shared.flags;
            },
            set(val) {
              this.shared.flags = val;
            }
          },
          position: {
            get() {
              return this.shared.position;
            },
            set(val) {
              this.shared.position = val;
            }
          }
        });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream: (fd) => {
      FS.streams[fd] = null;
    },
    chrdev_stream_ops: {
      open: (stream) => {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      },
      llseek: () => {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice: (dev, ops) => {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    },
    syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount: (type, opts, mountpoint) => {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount: (mountpoint) => {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup: (parent, name) => parent.node_ops.lookup(parent, name),
    mknod: (path, mode, dev) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink: (path) => {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat: (path, dontFollow) => {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat: (path) => FS.stat(path, true),
    chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    },
    fchmod: (fd, mode) => {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    },
    fchown: (fd, uid, gid) => {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate: (fd, len) => {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime: (path, atime, mtime) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed: (stream) => stream.fd === null,
    llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read: (stream, buffer, offset, length, position) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write: (stream, buffer, offset, length, position, canOwn) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync: (stream, buffer, offset, length, mmapFlags) => {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    munmap: (stream) => 0,
    ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount: () => {
          var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: (parent, name) => {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams: () => {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
        };
        this.setErrno(errno);
        this.message = "FS error";
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    },
    staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS
      };
    },
    init: (input, output, error) => {
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile: (parent, name, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    },
    createDevice: (parent, name, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open: (stream) => {
          stream.seekable = false;
        },
        close: (stream) => {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        },
        read: (stream, buffer, offset, length, pos) => {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: (stream, buffer, offset, length, pos) => {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile: (parent, name, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, {
          length: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            }
          },
          chunkSize: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            }
          }
        });
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    varargs: void 0,
    get() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    },
    getStreamFromFD: function(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    }
  };
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
    try {
      var total = 0;
      var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;
      var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;
      var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;
      var dstReadLow = 0, dstReadHigh = 0;
      var dstWriteLow = 0, dstWriteHigh = 0;
      var dstExceptLow = 0, dstExceptHigh = 0;
      var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);
      var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);
      var check = function(fd2, low, high, val) {
        return fd2 < 32 ? low & val : high & val;
      };
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << fd % 32;
        if (!check(fd, allLow, allHigh, mask)) {
          continue;
        }
        var stream = SYSCALLS.getStreamFromFD(fd);
        var flags = SYSCALLS.DEFAULT_POLLMASK;
        if (stream.stream_ops?.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            var tv_sec = readfds ? HEAP32[timeout >> 2] : 0, tv_usec = readfds ? HEAP32[timeout + 8 >> 2] : 0;
            timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }
        if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
          total++;
        }
        if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
          total++;
        }
        if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
          total++;
        }
      }
      if (readfds) {
        HEAP32[readfds >> 2] = dstReadLow;
        HEAP32[readfds + 4 >> 2] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[writefds >> 2] = dstWriteLow;
        HEAP32[writefds + 4 >> 2] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[exceptfds >> 2] = dstExceptLow;
        HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;
      }
      return total;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  function getSocketFromFD(fd) {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  }
  var setErrNo = (value) => {
    HEAP32[___errno_location() >> 2] = value;
    return value;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name: (name) => {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr: (addr) => {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  function getSocketAddress(addrp, addrlen, allowNull) {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  }
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.createStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.createStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function convertI32PairToI53Checked(lo, hi) {
    return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  }
  function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    var len = convertI32PairToI53Checked(len_low, len_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5: {
          var arg = SYSCALLS.get();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 6:
        case 7:
          return 0;
        case 16:
        case 8:
          return -28;
        case 9:
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18 >> 0] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17 >> 0] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = SYSCALLS.get();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17 >> 0]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = SYSCALLS.get();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = SYSCALLS.get();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function readI53FromI64(ptr) {
    return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  }
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var nowIsMonotonic = true;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      return date.getTime() / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      if (Module["onExit"])
        Module["onExit"](code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var stringToNewUTF8 = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = _malloc(size);
    if (ret)
      stringToUTF8(str, ret, size);
    return ret;
  };
  var __tzset_js = (timezone, daylight, tzname) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    function extractZone(date) {
      var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
      return match ? match[1] : "GMT";
    }
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    var winterNamePtr = stringToNewUTF8(winterName);
    var summerNamePtr = stringToNewUTF8(summerName);
    if (summerOffset < winterOffset) {
      HEAPU32[tzname >> 2] = winterNamePtr;
      HEAPU32[tzname + 4 >> 2] = summerNamePtr;
    } else {
      HEAPU32[tzname >> 2] = summerNamePtr;
      HEAPU32[tzname + 4 >> 2] = winterNamePtr;
    }
  };
  var _abort = () => {
    abort("");
  };
  function _emscripten_date_now() {
    return Date.now();
  }
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = size - b.byteLength + 65535 >>> 16;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = function(ms) {
    return Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  };
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    }
    HEAP8[buffer >> 0] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf >> 0] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_sync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep(function(wakeUp) {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, function(err2) {
          if (err2) {
            wakeUp(function() {
              return 29;
            });
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  function _getcontext() {
    err("missing function: getcontext");
    abort(-1);
  }
  function _getdtablesize() {
    err("missing function: getdtablesize");
    abort(-1);
  }
  var getHostByName = (name) => {
    var ret = _malloc(20);
    var nameBuf = stringToNewUTF8(name);
    HEAPU32[ret >> 2] = nameBuf;
    var aliasesBuf = _malloc(4);
    HEAPU32[aliasesBuf >> 2] = 0;
    HEAPU32[ret + 4 >> 2] = aliasesBuf;
    var afinet = 2;
    HEAP32[ret + 8 >> 2] = afinet;
    HEAP32[ret + 12 >> 2] = 4;
    var addrListBuf = _malloc(12);
    HEAPU32[addrListBuf >> 2] = addrListBuf + 8;
    HEAPU32[addrListBuf + 4 >> 2] = 0;
    HEAP32[addrListBuf + 8 >> 2] = inetPton4(DNS.lookup_name(name));
    HEAPU32[ret + 16 >> 2] = addrListBuf;
    return ret;
  };
  var _gethostbyname = (name) => getHostByName(UTF8ToString(name));
  var _gethostbyname_r = (name, ret, buf, buflen, out2, err2) => {
    var data = _gethostbyname(name);
    _memcpy(ret, data, 20);
    _free(data);
    HEAP32[err2 >> 2] = 0;
    HEAPU32[out2 >> 2] = ret;
    return 0;
  };
  var _getloadavg = (loadavg, nelem) => {
    var limit = Math.min(nelem, 3);
    var doubleSize = 8;
    for (var i = 0; i < limit; i++) {
      HEAPF64[loadavg + i * doubleSize >> 3] = 0.1;
    }
    return limit;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitWsEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "error");
    },
    awaitWsEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command) {
      if (Module["spawnProcess"]) {
        const spawned = Module["spawnProcess"](command);
        if (!spawned || !spawned.on) {
          throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
        }
        return spawned;
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, [], {
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(procopenCallId) {
    if (!PHPWASM.input_devices) {
      PHPWASM.input_devices = {};
    }
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + procopenCallId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[procopenCallId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    var returnCode;
    var stream;
    try {
      stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      returnCode = 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      returnCode = e.errno;
    }
    if (returnCode === 6 && stream?.fd in PHPWASM.proc_fds) {
      return Asyncify.handleSleep(function(wakeUp) {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            var num2 = doReadv(stream2, iov, iovcnt);
            HEAPU32[pnum >> 2] = num2;
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          if (returnCode2 !== 6 || ++retries > maxRetries || !(stream2?.fd in PHPWASM.proc_fds) || PHPWASM.proc_fds[stream2?.fd]?.exited || FS.isClosed(stream2) || !(PHPWASM.proc_fds[fd]?.stdinFd in (PHPWASM.input_devices || {}))) {
            wakeUp(returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    }
    return returnCode;
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(0);
        });
      });
    }
  }
  function _js_open_process(command, stdinFd, stdoutChildFd, stdoutParentFd, stderrChildFd, stderrParentFd) {
    if (!PHPWASM.proc_fds) {
      PHPWASM.proc_fds = {};
    }
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let cp;
    try {
      cp = PHPWASM.spawnProcess(cmdstr);
    } catch (e) {
      if (e.code === "SPAWN_UNSUPPORTED") {
        return 1;
      }
      throw e;
    }
    let EventEmitter;
    if (ENVIRONMENT_IS_NODE) {
      EventEmitter = require("events").EventEmitter;
    } else {
      EventEmitter = function() {
        this.listeners = {};
      };
      EventEmitter.prototype.emit = function(eventName, data) {
        if (this.listeners[eventName]) {
          this.listeners[eventName].forEach(function(callback) {
            callback(data);
          });
        }
      };
      EventEmitter.prototype.once = function(eventName, callback) {
        const self2 = this;
        function removedCallback() {
          callback(...arguments);
          self2.removeListener(eventName, removedCallback);
        }
        this.on(eventName, removedCallback);
      };
      EventEmitter.prototype.on = function(eventName, callback) {
        if (!this.listeners[eventName]) {
          this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(callback);
      };
      EventEmitter.prototype.removeListener = function(eventName, callback) {
        const idx = this.listeners[eventName].indexOf(callback);
        if (idx !== -1) {
          this.listeners[eventName].splice(idx, 1);
        }
      };
    }
    PHPWASM.proc_fds[stdoutParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stdoutParentFd].stdinFd = stdinFd;
    PHPWASM.proc_fds[stderrParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stderrParentFd].stdinFd = stdinFd;
    const stdoutStream = SYSCALLS.getStreamFromFD(stdoutChildFd);
    cp.on("exit", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].exited = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      PHPWASM.proc_fds[stderrParentFd].exited = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
    });
    cp.stdout.on("data", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].hasData = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, 0);
    });
    const stderrStream = SYSCALLS.getStreamFromFD(stderrChildFd);
    cp.stderr.on("data", function(data) {
      PHPWASM.proc_fds[stderrParentFd].hasData = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
      stderrStream.stream_ops.write(stderrStream, data, 0, data.length, 0);
    });
    if (PHPWASM.input_devices && stdinFd in PHPWASM.input_devices) {
      PHPWASM.input_devices[stdinFd].onData(function(data) {
        if (!data)
          return;
        const dataStr = new TextDecoder("utf-8").decode(data);
        cp.stdin.write(dataStr);
      });
      return 0;
    }
    const stdinStream = SYSCALLS.getStreamFromFD(stdinFd);
    if (!stdinStream.node) {
      return 0;
    }
    const CHUNK_SIZE = 1024;
    const buffer = Buffer.alloc(CHUNK_SIZE);
    let offset = 0;
    while (true) {
      const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
      if (bytesRead === null || bytesRead === 0) {
        break;
      }
      try {
        cp.stdin.write(buffer.subarray(0, bytesRead));
      } catch (e) {
        console.error(e);
        return 1;
      }
      if (bytesRead < CHUNK_SIZE) {
        break;
      }
      offset += bytesRead;
    }
    return 0;
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep((wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr);
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _makecontext() {
    err("missing function: makecontext");
    abort(-1);
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAP32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": (date2) => getWeekBasedYear(date2),
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "%A": "%a",
      "%B": "%b",
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m\\/%d\\/%y",
      "%e": "%d",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%R": "%H\\:%M",
      "%r": "%I\\:%M\\:%S\\s%p",
      "%T": "%H\\:%M\\:%S",
      "%x": "%m\\/%d\\/(?:%y|%Y)",
      "%X": "%H\\:%M\\:%S"
    };
    for (var matcher in EQUIVALENT_MATCHERS) {
      pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
    }
    var DATE_PATTERNS = {
      "%a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      "%b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      "%C": "\\d\\d",
      "%d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      "%H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      "%I": "\\d(?!\\d)|0\\d|10|11|12",
      "%j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      "%m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      "%M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      "%n": "\\s",
      "%p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      "%S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      "%U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%w": "[0-6]",
      "%y": "\\d\\d",
      "%Y": "\\d\\d\\d\\d",
      "%%": "%",
      "%t": "\\s"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    for (var datePattern in DATE_PATTERNS) {
      pattern = pattern.replace(datePattern, "(" + datePattern + DATE_PATTERNS[datePattern] + ")");
    }
    var capture = [];
    for (var i = pattern.indexOf("%"); i >= 0; i = pattern.indexOf("%")) {
      capture.push(pattern[i + 1]);
      pattern = pattern.replace(new RegExp("\\%" + pattern[i + 1], "g"), "");
    }
    var matches = new RegExp("^" + pattern, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59)
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _swapcontext() {
    err("missing function: swapcontext");
    abort(-1);
  }
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (PHPWASM.proc_fds && socketd in PHPWASM.proc_fds) {
        const emitter = PHPWASM.proc_fds[socketd];
        if (emitter.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitWsEvent(emitter, "data"));
      } else {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  function runAndAbortIfError(func) {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  }
  var Asyncify = {
    instrumentWasmImports: function(imports) {
      var importPatterns = [/^_dlopen_js$/, /^invoke_i$/, /^invoke_ii$/, /^invoke_iii$/, /^invoke_iiii$/, /^invoke_iiiii$/, /^invoke_iiiiii$/, /^invoke_iiiiiii$/, /^invoke_iiiiiiii$/, /^invoke_iiiiiiiiii$/, /^invoke_v$/, /^invoke_vi$/, /^invoke_vii$/, /^invoke_viidii$/, /^invoke_viii$/, /^invoke_viiii$/, /^invoke_viiiii$/, /^invoke_viiiiii$/, /^invoke_viiiiiii$/, /^invoke_viiiiiiiii$/, /^js_open_process$/, /^js_popen_to_file$/, /^js_fd_read$/, /^js_module_onMessage$/, /^wasm_poll_socket$/, /^wasm_shutdown$/, /^fd_sync$/, /^__wasi_fd_sync$/, /^__asyncjs__.*$/, /^emscripten_promise_await$/, /^emscripten_idb_load$/, /^emscripten_idb_store$/, /^emscripten_idb_delete$/, /^emscripten_idb_exists$/, /^emscripten_idb_load_blob$/, /^emscripten_idb_store_blob$/, /^emscripten_sleep$/, /^emscripten_wget_data$/, /^emscripten_scan_registers$/, /^emscripten_lazy_load_code$/, /^_load_secondary_module$/, /^emscripten_fiber_swap$/, /^SDL_Delay$/];
      for (var x in imports) {
        (function(x2) {
          var original = imports[x2];
          var sig = original.sig;
          if (typeof original == "function") {
            var isAsyncifyImport = original.isAsync || importPatterns.some((pattern) => !!x2.match(pattern));
          }
        })(x);
      }
    },
    instrumentWasmExports: function(exports) {
      var ret = {};
      for (var x in exports) {
        (function(x2) {
          var original = exports[x2];
          if (typeof original == "function") {
            ret[x2] = function() {
              Asyncify.exportCallStack.push(x2);
              try {
                return original.apply(null, arguments);
              } finally {
                if (!ABORT) {
                  var y = Asyncify.exportCallStack.pop();
                  assert(y === x2);
                  Asyncify.maybeStopUnwind();
                }
              }
            };
          } else {
            ret[x2] = original;
          }
        })(x);
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId: function(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind: function() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone: function() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData: function() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader: function(ptr, stack, stackSize) {
      HEAP32[ptr >> 2] = stack;
      HEAP32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc: function(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFunc: function(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      var func = Module["asm"][name];
      return func;
    },
    doRewind: function(ptr) {
      var start = Asyncify.getDataRewindFunc(ptr);
      runtimeKeepalivePop();
      return start();
    },
    handleSleep: function(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach((func) => callUserCallback(func));
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync: function(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  function getCFunc(ident) {
    var func = Module["_" + ident];
    return func;
  }
  var ccall = function(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func.apply(null, cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts && opts.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FSNode = function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
    read: {
      get: function() {
        return (this.mode & readMode) === readMode;
      },
      set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }
    },
    write: {
      get: function() {
        return (this.mode & writeMode) === writeMode;
      },
      set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }
    },
    isFolder: {
      get: function() {
        return FS.isDir(this.mode);
      }
    },
    isDevice: {
      get: function() {
        return FS.isChrdev(this.mode);
      }
    }
  });
  FS.FSNode = FSNode;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var wasmImports = {
    m: ___assert_fail,
    ab: ___call_sighandler,
    $a: ___syscall__newselect,
    _a: ___syscall_accept4,
    Za: ___syscall_bind,
    Ya: ___syscall_chdir,
    S: ___syscall_chmod,
    Xa: ___syscall_connect,
    Wa: ___syscall_dup,
    Va: ___syscall_dup3,
    Ua: ___syscall_faccessat,
    ca: ___syscall_fallocate,
    Ta: ___syscall_fchmod,
    Sa: ___syscall_fchown32,
    R: ___syscall_fchownat,
    o: ___syscall_fcntl64,
    Ra: ___syscall_fdatasync,
    Qa: ___syscall_fstat64,
    ba: ___syscall_ftruncate64,
    Pa: ___syscall_getcwd,
    Oa: ___syscall_getdents64,
    Na: ___syscall_getpeername,
    Ma: ___syscall_getsockname,
    La: ___syscall_getsockopt,
    Q: ___syscall_ioctl,
    Ka: ___syscall_listen,
    Ja: ___syscall_lstat64,
    Ia: ___syscall_mkdirat,
    Ha: ___syscall_newfstatat,
    y: ___syscall_openat,
    Ga: ___syscall_pipe,
    Fa: ___syscall_poll,
    Ea: ___syscall_readlinkat,
    Da: ___syscall_recvfrom,
    Ca: ___syscall_renameat,
    P: ___syscall_rmdir,
    Ba: ___syscall_sendto,
    O: ___syscall_socket,
    Aa: ___syscall_stat64,
    za: ___syscall_statfs64,
    ya: ___syscall_symlink,
    E: ___syscall_unlinkat,
    xa: ___syscall_utimensat,
    sa: __emscripten_get_now_is_monotonic,
    ra: __emscripten_throw_longjmp,
    $: __gmtime_js,
    _: __localtime_js,
    Z: __mktime_js,
    Y: __mmap_js,
    X: __munmap_js,
    L: __setitimer_js,
    qa: __tzset_js,
    f: _abort,
    C: _emscripten_date_now,
    pa: _emscripten_get_heap_max,
    v: _emscripten_get_now,
    oa: _emscripten_memcpy_big,
    na: _emscripten_resize_heap,
    K: _emscripten_sleep,
    wa: _environ_get,
    va: _environ_sizes_get,
    r: _exit,
    t: _fd_close,
    N: _fd_fdstat_get,
    M: _fd_read,
    aa: _fd_seek,
    ua: _fd_sync,
    D: _fd_write,
    ma: _getaddrinfo,
    la: _getcontext,
    ka: _getdtablesize,
    J: _gethostbyname_r,
    ja: _getloadavg,
    x: _getnameinfo,
    ia: _getprotobyname,
    ha: _getprotobynumber,
    j: invoke_i,
    c: invoke_ii,
    b: invoke_iii,
    g: invoke_iiii,
    i: invoke_iiiii,
    q: invoke_iiiiii,
    s: invoke_iiiiiii,
    w: invoke_iiiiiiii,
    I: invoke_iiiiiiiiii,
    e: invoke_v,
    a: invoke_vi,
    d: invoke_vii,
    B: invoke_viidii,
    h: invoke_viii,
    l: invoke_viiii,
    n: invoke_viiiii,
    k: invoke_viiiiii,
    ga: invoke_viiiiiii,
    A: invoke_viiiiiiiii,
    H: _js_create_input_device,
    fa: _js_fd_read,
    ea: _js_module_onMessage,
    G: _js_open_process,
    da: _js_popen_to_file,
    W: _makecontext,
    ta: _proc_exit,
    F: _strftime,
    V: _strptime,
    U: _swapcontext,
    u: _wasm_close,
    z: _wasm_poll_socket,
    p: _wasm_setsockopt,
    T: _wasm_shutdown
  };
  var asm = createWasm();
  var ___wasm_call_ctors = function() {
    return (___wasm_call_ctors = Module["asm"]["cb"]).apply(null, arguments);
  };
  var _free = function() {
    return (_free = Module["asm"]["db"]).apply(null, arguments);
  };
  var _memcpy = function() {
    return (_memcpy = Module["asm"]["eb"]).apply(null, arguments);
  };
  var _malloc = function() {
    return (_malloc = Module["asm"]["gb"]).apply(null, arguments);
  };
  var setTempRet0 = function() {
    return (setTempRet0 = Module["asm"]["hb"]).apply(null, arguments);
  };
  var ___errno_location = function() {
    return (___errno_location = Module["asm"]["ib"]).apply(null, arguments);
  };
  var _wasm_popen = Module["_wasm_popen"] = function() {
    return (_wasm_popen = Module["_wasm_popen"] = Module["asm"]["jb"]).apply(null, arguments);
  };
  var _wasm_php_exec = Module["_wasm_php_exec"] = function() {
    return (_wasm_php_exec = Module["_wasm_php_exec"] = Module["asm"]["kb"]).apply(null, arguments);
  };
  var _php_pollfd_for = Module["_php_pollfd_for"] = function() {
    return (_php_pollfd_for = Module["_php_pollfd_for"] = Module["asm"]["lb"]).apply(null, arguments);
  };
  var _htons = function() {
    return (_htons = Module["asm"]["mb"]).apply(null, arguments);
  };
  var _ntohs = function() {
    return (_ntohs = Module["asm"]["nb"]).apply(null, arguments);
  };
  var _htonl = function() {
    return (_htonl = Module["asm"]["ob"]).apply(null, arguments);
  };
  var _wasm_sleep = Module["_wasm_sleep"] = function() {
    return (_wasm_sleep = Module["_wasm_sleep"] = Module["asm"]["pb"]).apply(null, arguments);
  };
  var _fflush = Module["_fflush"] = function() {
    return (_fflush = Module["_fflush"] = Module["asm"]["qb"]).apply(null, arguments);
  };
  var _wasm_read = Module["_wasm_read"] = function() {
    return (_wasm_read = Module["_wasm_read"] = Module["asm"]["rb"]).apply(null, arguments);
  };
  var _wasm_select = Module["_wasm_select"] = function() {
    return (_wasm_select = Module["_wasm_select"] = Module["asm"]["sb"]).apply(null, arguments);
  };
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = function() {
    return (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = Module["asm"]["tb"]).apply(null, arguments);
  };
  var _run_cli = Module["_run_cli"] = function() {
    return (_run_cli = Module["_run_cli"] = Module["asm"]["ub"]).apply(null, arguments);
  };
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = function() {
    return (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = Module["asm"]["vb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = function() {
    return (_wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = Module["asm"]["wb"]).apply(null, arguments);
  };
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = function() {
    return (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = Module["asm"]["xb"]).apply(null, arguments);
  };
  var _wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = function() {
    return (_wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = Module["asm"]["yb"]).apply(null, arguments);
  };
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = function() {
    return (_wasm_set_query_string = Module["_wasm_set_query_string"] = Module["asm"]["zb"]).apply(null, arguments);
  };
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = function() {
    return (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = Module["asm"]["Ab"]).apply(null, arguments);
  };
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = function() {
    return (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = Module["asm"]["Bb"]).apply(null, arguments);
  };
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = function() {
    return (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = Module["asm"]["Cb"]).apply(null, arguments);
  };
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = function() {
    return (_wasm_set_request_method = Module["_wasm_set_request_method"] = Module["asm"]["Db"]).apply(null, arguments);
  };
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = function() {
    return (_wasm_set_request_host = Module["_wasm_set_request_host"] = Module["asm"]["Eb"]).apply(null, arguments);
  };
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = function() {
    return (_wasm_set_content_type = Module["_wasm_set_content_type"] = Module["asm"]["Fb"]).apply(null, arguments);
  };
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = function() {
    return (_wasm_set_request_body = Module["_wasm_set_request_body"] = Module["asm"]["Gb"]).apply(null, arguments);
  };
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = function() {
    return (_wasm_set_content_length = Module["_wasm_set_content_length"] = Module["asm"]["Hb"]).apply(null, arguments);
  };
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = function() {
    return (_wasm_set_cookies = Module["_wasm_set_cookies"] = Module["asm"]["Ib"]).apply(null, arguments);
  };
  var _wasm_set_php_code = Module["_wasm_set_php_code"] = function() {
    return (_wasm_set_php_code = Module["_wasm_set_php_code"] = Module["asm"]["Jb"]).apply(null, arguments);
  };
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = function() {
    return (_wasm_set_request_port = Module["_wasm_set_request_port"] = Module["asm"]["Kb"]).apply(null, arguments);
  };
  var _phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = function() {
    return (_phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = Module["asm"]["Lb"]).apply(null, arguments);
  };
  var _phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = function() {
    return (_phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = Module["asm"]["Mb"]).apply(null, arguments);
  };
  var _phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = function() {
    return (_phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = Module["asm"]["Nb"]).apply(null, arguments);
  };
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = function() {
    return (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = Module["asm"]["Ob"]).apply(null, arguments);
  };
  var _php_wasm_init = Module["_php_wasm_init"] = function() {
    return (_php_wasm_init = Module["_php_wasm_init"] = Module["asm"]["Pb"]).apply(null, arguments);
  };
  var ___funcs_on_exit = function() {
    return (___funcs_on_exit = Module["asm"]["Qb"]).apply(null, arguments);
  };
  var _emscripten_builtin_memalign = function() {
    return (_emscripten_builtin_memalign = Module["asm"]["Rb"]).apply(null, arguments);
  };
  var __emscripten_timeout = function() {
    return (__emscripten_timeout = Module["asm"]["Sb"]).apply(null, arguments);
  };
  var _setThrew = function() {
    return (_setThrew = Module["asm"]["Tb"]).apply(null, arguments);
  };
  var _emscripten_stack_set_limits = function() {
    return (_emscripten_stack_set_limits = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
  };
  var _emscripten_stack_get_base = function() {
    return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
  };
  var _emscripten_stack_get_end = function() {
    return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
  };
  var stackSave = function() {
    return (stackSave = Module["asm"]["Ub"]).apply(null, arguments);
  };
  var stackRestore = function() {
    return (stackRestore = Module["asm"]["Vb"]).apply(null, arguments);
  };
  var stackAlloc = function() {
    return (stackAlloc = Module["asm"]["Wb"]).apply(null, arguments);
  };
  var dynCall_iiii = Module["dynCall_iiii"] = function() {
    return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["Xb"]).apply(null, arguments);
  };
  var dynCall_ii = Module["dynCall_ii"] = function() {
    return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["Yb"]).apply(null, arguments);
  };
  var dynCall_vi = Module["dynCall_vi"] = function() {
    return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["Zb"]).apply(null, arguments);
  };
  var dynCall_vii = Module["dynCall_vii"] = function() {
    return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["_b"]).apply(null, arguments);
  };
  var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
    return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["$b"]).apply(null, arguments);
  };
  var dynCall_iii = Module["dynCall_iii"] = function() {
    return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["ac"]).apply(null, arguments);
  };
  var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
    return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["bc"]).apply(null, arguments);
  };
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
    return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["cc"]).apply(null, arguments);
  };
  var dynCall_viii = Module["dynCall_viii"] = function() {
    return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["dc"]).apply(null, arguments);
  };
  var dynCall_v = Module["dynCall_v"] = function() {
    return (dynCall_v = Module["dynCall_v"] = Module["asm"]["ec"]).apply(null, arguments);
  };
  var dynCall_i = Module["dynCall_i"] = function() {
    return (dynCall_i = Module["dynCall_i"] = Module["asm"]["fc"]).apply(null, arguments);
  };
  var dynCall_viiii = Module["dynCall_viiii"] = function() {
    return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["gc"]).apply(null, arguments);
  };
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
    return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["hc"]).apply(null, arguments);
  };
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {
    return (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = Module["asm"]["ic"]).apply(null, arguments);
  };
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = function() {
    return (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = Module["asm"]["jc"]).apply(null, arguments);
  };
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
    return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["kc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
    return (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = Module["asm"]["lc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = function() {
    return (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = Module["asm"]["mc"]).apply(null, arguments);
  };
  var dynCall_viidii = Module["dynCall_viidii"] = function() {
    return (dynCall_viidii = Module["dynCall_viidii"] = Module["asm"]["nc"]).apply(null, arguments);
  };
  var _asyncify_start_unwind = function() {
    return (_asyncify_start_unwind = Module["asm"]["oc"]).apply(null, arguments);
  };
  var _asyncify_stop_unwind = function() {
    return (_asyncify_stop_unwind = Module["asm"]["pc"]).apply(null, arguments);
  };
  var _asyncify_start_rewind = function() {
    return (_asyncify_start_rewind = Module["asm"]["qc"]).apply(null, arguments);
  };
  var _asyncify_stop_rewind = function() {
    return (_asyncify_stop_rewind = Module["asm"]["rc"]).apply(null, arguments);
  };
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  Module["FS_unlink"] = FS.unlink;
  Module["ccall"] = ccall;
  Module["UTF8ToString"] = UTF8ToString;
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS"] = FS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  return PHPLoader;
}
var dependencyFilename2, dependenciesTotalSize2;
var init_php_8_2 = __esm({
  "packages/php-wasm/node/public/php_8_2.js"() {
    "use strict";
    dependencyFilename2 = __dirname + "/8_2_10/php_8_2.wasm";
    dependenciesTotalSize2 = 11249074;
  }
});

// packages/php-wasm/node/public/php_8_1.js
var php_8_1_exports = {};
__export(php_8_1_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize3,
  dependencyFilename: () => dependencyFilename3,
  init: () => init3
});
function init3(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = RuntimeName === "WEB";
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
    } else {
      scriptDirectory = __dirname + "/";
    }
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
    Module["inspect"] = () => "[Emscripten Module object]";
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var noExitRuntime = Module["noExitRuntime"] || false;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var wasmTable;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  var runtimeKeepaliveCounter = 0;
  function keepRuntimeAlive() {
    return noExitRuntime || runtimeKeepaliveCounter > 0;
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  function isFileURI(filename) {
    return filename.startsWith("file://");
  }
  var wasmBinaryFile;
  wasmBinaryFile = dependencyFilename3;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
      if (typeof fetch == "function") {
        return fetch(binaryFile, {
          credentials: "same-origin"
        }).then((response) => {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + binaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(() => getBinarySync(binaryFile));
      }
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then((instance) => instance).then(receiver, (reason) => {
      err("failed to asynchronously prepare wasm: " + reason);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err("wasm streaming compile failed: " + reason);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function createWasm() {
    var info = {
      "a": wasmImports
    };
    function receiveInstance(instance, module2) {
      var exports = instance.exports;
      exports = Asyncify.instrumentWasmExports(exports);
      Module["asm"] = exports;
      wasmMemory = Module["asm"]["ab"];
      updateMemoryViews();
      wasmTable = Module["asm"]["eb"];
      addOnInit(Module["asm"]["bb"]);
      removeRunDependency("wasm-instantiate");
      return exports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        return false;
      }
    }
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi.apply(null, [fp, a1]))(sig);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    },
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH_FS = {
    resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, -1);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        } else {
          result = null;
        }
      } else if (typeof window != "undefined" && typeof window.prompt == "function") {
        result = window.prompt("Input: ");
        if (result !== null) {
          result += "\n";
        }
      } else if (typeof readline == "function") {
        result = readline();
        if (result !== null) {
          result += "\n";
        }
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init: function() {
    },
    shutdown: function() {
    },
    register: function(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char: function(tty) {
        return FS_stdin_getChar();
      },
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets: function(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets: function(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz: function(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
      }
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
        old_node.parent = new_dir;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key in node.contents) {
          if (!node.contents.hasOwnProperty(key)) {
            continue;
          }
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach(function(plugin) {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  }
  function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        if (preFinish)
          preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        if (onload)
          onload();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        if (onerror)
          onerror();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, (byteArray) => processData(byteArray), onerror);
    } else {
      processData(url);
    }
  }
  function FS_modeStringToFlags(str) {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  }
  function FS_getMode(canRead, canWrite) {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  }
  var ERRNO_CODES = {};
  var NODEFS = {
    isWindows: false,
    staticInit: () => {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode: (e) => {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    mount: (mount) => NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0),
    createNode: (parent, name, mode, dev) => {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode: (path) => {
      var stat;
      try {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode = stat.mode | (stat.mode & 292) >> 2;
        }
      } catch (e) {
        if (!e.code)
          throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return stat.mode;
    },
    realPath: (node) => {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join.apply(null, parts);
    },
    flagsForNode: (flags) => {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr: (node) => {
        var path = NODEFS.realPath(node);
        var stat;
        try {
          stat = fs.lstatSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        if (NODEFS.isWindows && !stat.blksize) {
          stat.blksize = 4096;
        }
        if (NODEFS.isWindows && !stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr: (node, attr) => {
        var path = NODEFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      lookup: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod: (parent, name, mode, dev) => {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return node;
      },
      rename: (oldNode, newDir, newName) => {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          fs.renameSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        oldNode.name = newName;
      },
      unlink: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.unlinkSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      rmdir: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.rmdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readdir: (node) => {
        var path = NODEFS.realPath(node);
        try {
          return fs.readdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      symlink: (parent, newName, oldPath) => {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        try {
          fs.symlinkSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readlink: (node) => {
        var path = NODEFS.realPath(node);
        try {
          path = fs.readlinkSync(path);
          path = nodePath.relative(nodePath.resolve(node.mount.opts.root), path);
          return path;
        } catch (e) {
          if (!e.code)
            throw e;
          if (e.code === "UNKNOWN")
            throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      }
    },
    stream_ops: {
      open: (stream) => {
        var path = NODEFS.realPath(stream.node);
        try {
          if (FS.isFile(stream.node.mode)) {
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      close: (stream) => {
        try {
          if (FS.isFile(stream.node.mode) && stream.nfd) {
            fs.closeSync(stream.nfd);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      read: (stream, buffer, offset, length, position) => {
        if (length === 0)
          return 0;
        try {
          return fs.readSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      write: (stream, buffer, offset, length, position) => {
        try {
          return fs.writeSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      llseek: (stream, offset, whence) => {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap: (stream, length, position, prot, flags) => {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName: (parentid, name) => {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode: (parent, name) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode: (parent, name, mode, rdev) => {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode: (node) => {
      FS.hashRemoveNode(node);
    },
    isRoot: (node) => node === node.parent,
    isMountpoint: (node) => !!node.mounted,
    isFile: (mode) => (mode & 61440) === 32768,
    isDir: (mode) => (mode & 61440) === 16384,
    isLink: (mode) => (mode & 61440) === 40960,
    isChrdev: (mode) => (mode & 61440) === 8192,
    isBlkdev: (mode) => (mode & 61440) === 24576,
    isFIFO: (mode) => (mode & 61440) === 4096,
    isSocket: (mode) => (mode & 49152) === 49152,
    flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate: (dir, name) => {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete: (dir, name, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked: (fd) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, {
          object: {
            get() {
              return this.node;
            },
            set(val) {
              this.node = val;
            }
          },
          isRead: {
            get() {
              return (this.flags & 2097155) !== 1;
            }
          },
          isWrite: {
            get() {
              return (this.flags & 2097155) !== 0;
            }
          },
          isAppend: {
            get() {
              return this.flags & 1024;
            }
          },
          flags: {
            get() {
              return this.shared.flags;
            },
            set(val) {
              this.shared.flags = val;
            }
          },
          position: {
            get() {
              return this.shared.position;
            },
            set(val) {
              this.shared.position = val;
            }
          }
        });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream: (fd) => {
      FS.streams[fd] = null;
    },
    chrdev_stream_ops: {
      open: (stream) => {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      },
      llseek: () => {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice: (dev, ops) => {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    },
    syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount: (type, opts, mountpoint) => {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount: (mountpoint) => {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup: (parent, name) => parent.node_ops.lookup(parent, name),
    mknod: (path, mode, dev) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink: (path) => {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat: (path, dontFollow) => {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat: (path) => FS.stat(path, true),
    chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    },
    fchmod: (fd, mode) => {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    },
    fchown: (fd, uid, gid) => {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate: (fd, len) => {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime: (path, atime, mtime) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed: (stream) => stream.fd === null,
    llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read: (stream, buffer, offset, length, position) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write: (stream, buffer, offset, length, position, canOwn) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync: (stream, buffer, offset, length, mmapFlags) => {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    munmap: (stream) => 0,
    ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount: () => {
          var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: (parent, name) => {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams: () => {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
        };
        this.setErrno(errno);
        this.message = "FS error";
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    },
    staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS
      };
    },
    init: (input, output, error) => {
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile: (parent, name, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    },
    createDevice: (parent, name, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open: (stream) => {
          stream.seekable = false;
        },
        close: (stream) => {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        },
        read: (stream, buffer, offset, length, pos) => {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: (stream, buffer, offset, length, pos) => {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile: (parent, name, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, {
          length: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            }
          },
          chunkSize: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            }
          }
        });
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    varargs: void 0,
    get() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    },
    getStreamFromFD: function(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    }
  };
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
    try {
      var total = 0;
      var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;
      var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;
      var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;
      var dstReadLow = 0, dstReadHigh = 0;
      var dstWriteLow = 0, dstWriteHigh = 0;
      var dstExceptLow = 0, dstExceptHigh = 0;
      var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);
      var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);
      var check = function(fd2, low, high, val) {
        return fd2 < 32 ? low & val : high & val;
      };
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << fd % 32;
        if (!check(fd, allLow, allHigh, mask)) {
          continue;
        }
        var stream = SYSCALLS.getStreamFromFD(fd);
        var flags = SYSCALLS.DEFAULT_POLLMASK;
        if (stream.stream_ops?.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            var tv_sec = readfds ? HEAP32[timeout >> 2] : 0, tv_usec = readfds ? HEAP32[timeout + 8 >> 2] : 0;
            timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }
        if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
          total++;
        }
        if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
          total++;
        }
        if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
          total++;
        }
      }
      if (readfds) {
        HEAP32[readfds >> 2] = dstReadLow;
        HEAP32[readfds + 4 >> 2] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[writefds >> 2] = dstWriteLow;
        HEAP32[writefds + 4 >> 2] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[exceptfds >> 2] = dstExceptLow;
        HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;
      }
      return total;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  function getSocketFromFD(fd) {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  }
  var setErrNo = (value) => {
    HEAP32[___errno_location() >> 2] = value;
    return value;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name: (name) => {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr: (addr) => {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  function getSocketAddress(addrp, addrlen, allowNull) {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  }
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.createStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.createStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function convertI32PairToI53Checked(lo, hi) {
    return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  }
  function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    var len = convertI32PairToI53Checked(len_low, len_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5: {
          var arg = SYSCALLS.get();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 6:
        case 7:
          return 0;
        case 16:
        case 8:
          return -28;
        case 9:
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18 >> 0] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17 >> 0] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = SYSCALLS.get();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17 >> 0]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = SYSCALLS.get();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = SYSCALLS.get();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function readI53FromI64(ptr) {
    return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  }
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var nowIsMonotonic = true;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      return date.getTime() / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      if (Module["onExit"])
        Module["onExit"](code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var stringToNewUTF8 = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = _malloc(size);
    if (ret)
      stringToUTF8(str, ret, size);
    return ret;
  };
  var __tzset_js = (timezone, daylight, tzname) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    function extractZone(date) {
      var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
      return match ? match[1] : "GMT";
    }
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    var winterNamePtr = stringToNewUTF8(winterName);
    var summerNamePtr = stringToNewUTF8(summerName);
    if (summerOffset < winterOffset) {
      HEAPU32[tzname >> 2] = winterNamePtr;
      HEAPU32[tzname + 4 >> 2] = summerNamePtr;
    } else {
      HEAPU32[tzname >> 2] = summerNamePtr;
      HEAPU32[tzname + 4 >> 2] = winterNamePtr;
    }
  };
  var _abort = () => {
    abort("");
  };
  function _emscripten_date_now() {
    return Date.now();
  }
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = size - b.byteLength + 65535 >>> 16;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = function(ms) {
    return Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  };
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    }
    HEAP8[buffer >> 0] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf >> 0] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_sync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep(function(wakeUp) {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, function(err2) {
          if (err2) {
            wakeUp(function() {
              return 29;
            });
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  function _getcontext() {
    err("missing function: getcontext");
    abort(-1);
  }
  var getHostByName = (name) => {
    var ret = _malloc(20);
    var nameBuf = stringToNewUTF8(name);
    HEAPU32[ret >> 2] = nameBuf;
    var aliasesBuf = _malloc(4);
    HEAPU32[aliasesBuf >> 2] = 0;
    HEAPU32[ret + 4 >> 2] = aliasesBuf;
    var afinet = 2;
    HEAP32[ret + 8 >> 2] = afinet;
    HEAP32[ret + 12 >> 2] = 4;
    var addrListBuf = _malloc(12);
    HEAPU32[addrListBuf >> 2] = addrListBuf + 8;
    HEAPU32[addrListBuf + 4 >> 2] = 0;
    HEAP32[addrListBuf + 8 >> 2] = inetPton4(DNS.lookup_name(name));
    HEAPU32[ret + 16 >> 2] = addrListBuf;
    return ret;
  };
  var _gethostbyname = (name) => getHostByName(UTF8ToString(name));
  var _gethostbyname_r = (name, ret, buf, buflen, out2, err2) => {
    var data = _gethostbyname(name);
    _memcpy(ret, data, 20);
    _free(data);
    HEAP32[err2 >> 2] = 0;
    HEAPU32[out2 >> 2] = ret;
    return 0;
  };
  var _getloadavg = (loadavg, nelem) => {
    var limit = Math.min(nelem, 3);
    var doubleSize = 8;
    for (var i = 0; i < limit; i++) {
      HEAPF64[loadavg + i * doubleSize >> 3] = 0.1;
    }
    return limit;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitWsEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "error");
    },
    awaitWsEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command) {
      if (Module["spawnProcess"]) {
        const spawned = Module["spawnProcess"](command);
        if (!spawned || !spawned.on) {
          throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
        }
        return spawned;
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, [], {
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(procopenCallId) {
    if (!PHPWASM.input_devices) {
      PHPWASM.input_devices = {};
    }
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + procopenCallId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[procopenCallId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    var returnCode;
    var stream;
    try {
      stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      returnCode = 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      returnCode = e.errno;
    }
    if (returnCode === 6 && stream?.fd in PHPWASM.proc_fds) {
      return Asyncify.handleSleep(function(wakeUp) {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            var num2 = doReadv(stream2, iov, iovcnt);
            HEAPU32[pnum >> 2] = num2;
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          if (returnCode2 !== 6 || ++retries > maxRetries || !(stream2?.fd in PHPWASM.proc_fds) || PHPWASM.proc_fds[stream2?.fd]?.exited || FS.isClosed(stream2) || !(PHPWASM.proc_fds[fd]?.stdinFd in (PHPWASM.input_devices || {}))) {
            wakeUp(returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    }
    return returnCode;
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(0);
        });
      });
    }
  }
  function _js_open_process(command, stdinFd, stdoutChildFd, stdoutParentFd, stderrChildFd, stderrParentFd) {
    if (!PHPWASM.proc_fds) {
      PHPWASM.proc_fds = {};
    }
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let cp;
    try {
      cp = PHPWASM.spawnProcess(cmdstr);
    } catch (e) {
      if (e.code === "SPAWN_UNSUPPORTED") {
        return 1;
      }
      throw e;
    }
    let EventEmitter;
    if (ENVIRONMENT_IS_NODE) {
      EventEmitter = require("events").EventEmitter;
    } else {
      EventEmitter = function() {
        this.listeners = {};
      };
      EventEmitter.prototype.emit = function(eventName, data) {
        if (this.listeners[eventName]) {
          this.listeners[eventName].forEach(function(callback) {
            callback(data);
          });
        }
      };
      EventEmitter.prototype.once = function(eventName, callback) {
        const self2 = this;
        function removedCallback() {
          callback(...arguments);
          self2.removeListener(eventName, removedCallback);
        }
        this.on(eventName, removedCallback);
      };
      EventEmitter.prototype.on = function(eventName, callback) {
        if (!this.listeners[eventName]) {
          this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(callback);
      };
      EventEmitter.prototype.removeListener = function(eventName, callback) {
        const idx = this.listeners[eventName].indexOf(callback);
        if (idx !== -1) {
          this.listeners[eventName].splice(idx, 1);
        }
      };
    }
    PHPWASM.proc_fds[stdoutParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stdoutParentFd].stdinFd = stdinFd;
    PHPWASM.proc_fds[stderrParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stderrParentFd].stdinFd = stdinFd;
    const stdoutStream = SYSCALLS.getStreamFromFD(stdoutChildFd);
    cp.on("exit", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].exited = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      PHPWASM.proc_fds[stderrParentFd].exited = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
    });
    cp.stdout.on("data", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].hasData = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, 0);
    });
    const stderrStream = SYSCALLS.getStreamFromFD(stderrChildFd);
    cp.stderr.on("data", function(data) {
      PHPWASM.proc_fds[stderrParentFd].hasData = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
      stderrStream.stream_ops.write(stderrStream, data, 0, data.length, 0);
    });
    if (PHPWASM.input_devices && stdinFd in PHPWASM.input_devices) {
      PHPWASM.input_devices[stdinFd].onData(function(data) {
        if (!data)
          return;
        const dataStr = new TextDecoder("utf-8").decode(data);
        cp.stdin.write(dataStr);
      });
      return 0;
    }
    const stdinStream = SYSCALLS.getStreamFromFD(stdinFd);
    if (!stdinStream.node) {
      return 0;
    }
    const CHUNK_SIZE = 1024;
    const buffer = Buffer.alloc(CHUNK_SIZE);
    let offset = 0;
    while (true) {
      const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
      if (bytesRead === null || bytesRead === 0) {
        break;
      }
      try {
        cp.stdin.write(buffer.subarray(0, bytesRead));
      } catch (e) {
        console.error(e);
        return 1;
      }
      if (bytesRead < CHUNK_SIZE) {
        break;
      }
      offset += bytesRead;
    }
    return 0;
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep((wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr);
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _makecontext() {
    err("missing function: makecontext");
    abort(-1);
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAP32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": (date2) => getWeekBasedYear(date2),
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "%A": "%a",
      "%B": "%b",
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m\\/%d\\/%y",
      "%e": "%d",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%R": "%H\\:%M",
      "%r": "%I\\:%M\\:%S\\s%p",
      "%T": "%H\\:%M\\:%S",
      "%x": "%m\\/%d\\/(?:%y|%Y)",
      "%X": "%H\\:%M\\:%S"
    };
    for (var matcher in EQUIVALENT_MATCHERS) {
      pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
    }
    var DATE_PATTERNS = {
      "%a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      "%b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      "%C": "\\d\\d",
      "%d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      "%H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      "%I": "\\d(?!\\d)|0\\d|10|11|12",
      "%j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      "%m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      "%M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      "%n": "\\s",
      "%p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      "%S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      "%U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%w": "[0-6]",
      "%y": "\\d\\d",
      "%Y": "\\d\\d\\d\\d",
      "%%": "%",
      "%t": "\\s"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    for (var datePattern in DATE_PATTERNS) {
      pattern = pattern.replace(datePattern, "(" + datePattern + DATE_PATTERNS[datePattern] + ")");
    }
    var capture = [];
    for (var i = pattern.indexOf("%"); i >= 0; i = pattern.indexOf("%")) {
      capture.push(pattern[i + 1]);
      pattern = pattern.replace(new RegExp("\\%" + pattern[i + 1], "g"), "");
    }
    var matches = new RegExp("^" + pattern, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59)
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _swapcontext() {
    err("missing function: swapcontext");
    abort(-1);
  }
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (PHPWASM.proc_fds && socketd in PHPWASM.proc_fds) {
        const emitter = PHPWASM.proc_fds[socketd];
        if (emitter.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitWsEvent(emitter, "data"));
      } else {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  function runAndAbortIfError(func) {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  }
  var Asyncify = {
    instrumentWasmImports: function(imports) {
      var importPatterns = [/^_dlopen_js$/, /^invoke_i$/, /^invoke_ii$/, /^invoke_iii$/, /^invoke_iiii$/, /^invoke_iiiii$/, /^invoke_iiiiii$/, /^invoke_iiiiiii$/, /^invoke_iiiiiiii$/, /^invoke_iiiiiiiiii$/, /^invoke_v$/, /^invoke_vi$/, /^invoke_vii$/, /^invoke_viidii$/, /^invoke_viii$/, /^invoke_viiii$/, /^invoke_viiiii$/, /^invoke_viiiiii$/, /^invoke_viiiiiii$/, /^invoke_viiiiiiiii$/, /^js_open_process$/, /^js_popen_to_file$/, /^js_fd_read$/, /^js_module_onMessage$/, /^wasm_poll_socket$/, /^wasm_shutdown$/, /^fd_sync$/, /^__wasi_fd_sync$/, /^__asyncjs__.*$/, /^emscripten_promise_await$/, /^emscripten_idb_load$/, /^emscripten_idb_store$/, /^emscripten_idb_delete$/, /^emscripten_idb_exists$/, /^emscripten_idb_load_blob$/, /^emscripten_idb_store_blob$/, /^emscripten_sleep$/, /^emscripten_wget_data$/, /^emscripten_scan_registers$/, /^emscripten_lazy_load_code$/, /^_load_secondary_module$/, /^emscripten_fiber_swap$/, /^SDL_Delay$/];
      for (var x in imports) {
        (function(x2) {
          var original = imports[x2];
          var sig = original.sig;
          if (typeof original == "function") {
            var isAsyncifyImport = original.isAsync || importPatterns.some((pattern) => !!x2.match(pattern));
          }
        })(x);
      }
    },
    instrumentWasmExports: function(exports) {
      var ret = {};
      for (var x in exports) {
        (function(x2) {
          var original = exports[x2];
          if (typeof original == "function") {
            ret[x2] = function() {
              Asyncify.exportCallStack.push(x2);
              try {
                return original.apply(null, arguments);
              } finally {
                if (!ABORT) {
                  var y = Asyncify.exportCallStack.pop();
                  assert(y === x2);
                  Asyncify.maybeStopUnwind();
                }
              }
            };
          } else {
            ret[x2] = original;
          }
        })(x);
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId: function(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind: function() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone: function() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData: function() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader: function(ptr, stack, stackSize) {
      HEAP32[ptr >> 2] = stack;
      HEAP32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc: function(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFunc: function(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      var func = Module["asm"][name];
      return func;
    },
    doRewind: function(ptr) {
      var start = Asyncify.getDataRewindFunc(ptr);
      runtimeKeepalivePop();
      return start();
    },
    handleSleep: function(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach((func) => callUserCallback(func));
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync: function(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  function getCFunc(ident) {
    var func = Module["_" + ident];
    return func;
  }
  var ccall = function(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func.apply(null, cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts && opts.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FSNode = function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
    read: {
      get: function() {
        return (this.mode & readMode) === readMode;
      },
      set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }
    },
    write: {
      get: function() {
        return (this.mode & writeMode) === writeMode;
      },
      set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }
    },
    isFolder: {
      get: function() {
        return FS.isDir(this.mode);
      }
    },
    isDevice: {
      get: function() {
        return FS.isChrdev(this.mode);
      }
    }
  });
  FS.FSNode = FSNode;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var wasmImports = {
    m: ___assert_fail,
    $a: ___call_sighandler,
    _a: ___syscall__newselect,
    Za: ___syscall_accept4,
    Ya: ___syscall_bind,
    Xa: ___syscall_chdir,
    S: ___syscall_chmod,
    Wa: ___syscall_connect,
    Va: ___syscall_dup,
    Ua: ___syscall_dup3,
    Ta: ___syscall_faccessat,
    ca: ___syscall_fallocate,
    Sa: ___syscall_fchmod,
    Ra: ___syscall_fchown32,
    R: ___syscall_fchownat,
    o: ___syscall_fcntl64,
    Qa: ___syscall_fdatasync,
    Pa: ___syscall_fstat64,
    ba: ___syscall_ftruncate64,
    Oa: ___syscall_getcwd,
    Na: ___syscall_getdents64,
    Ma: ___syscall_getpeername,
    La: ___syscall_getsockname,
    Ka: ___syscall_getsockopt,
    Q: ___syscall_ioctl,
    Ja: ___syscall_listen,
    Ia: ___syscall_lstat64,
    Ha: ___syscall_mkdirat,
    Ga: ___syscall_newfstatat,
    y: ___syscall_openat,
    Fa: ___syscall_pipe,
    Ea: ___syscall_poll,
    Da: ___syscall_readlinkat,
    Ca: ___syscall_recvfrom,
    Ba: ___syscall_renameat,
    P: ___syscall_rmdir,
    Aa: ___syscall_sendto,
    O: ___syscall_socket,
    za: ___syscall_stat64,
    ya: ___syscall_statfs64,
    xa: ___syscall_symlink,
    E: ___syscall_unlinkat,
    wa: ___syscall_utimensat,
    ra: __emscripten_get_now_is_monotonic,
    qa: __emscripten_throw_longjmp,
    $: __gmtime_js,
    _: __localtime_js,
    Z: __mktime_js,
    Y: __mmap_js,
    X: __munmap_js,
    L: __setitimer_js,
    pa: __tzset_js,
    f: _abort,
    C: _emscripten_date_now,
    oa: _emscripten_get_heap_max,
    v: _emscripten_get_now,
    na: _emscripten_memcpy_big,
    ma: _emscripten_resize_heap,
    K: _emscripten_sleep,
    va: _environ_get,
    ua: _environ_sizes_get,
    q: _exit,
    t: _fd_close,
    N: _fd_fdstat_get,
    M: _fd_read,
    aa: _fd_seek,
    ta: _fd_sync,
    D: _fd_write,
    la: _getaddrinfo,
    ka: _getcontext,
    J: _gethostbyname_r,
    ja: _getloadavg,
    x: _getnameinfo,
    ia: _getprotobyname,
    ha: _getprotobynumber,
    j: invoke_i,
    c: invoke_ii,
    b: invoke_iii,
    g: invoke_iiii,
    i: invoke_iiiii,
    s: invoke_iiiiii,
    r: invoke_iiiiiii,
    w: invoke_iiiiiiii,
    I: invoke_iiiiiiiiii,
    e: invoke_v,
    a: invoke_vi,
    d: invoke_vii,
    B: invoke_viidii,
    h: invoke_viii,
    l: invoke_viiii,
    n: invoke_viiiii,
    k: invoke_viiiiii,
    ga: invoke_viiiiiii,
    A: invoke_viiiiiiiii,
    H: _js_create_input_device,
    fa: _js_fd_read,
    ea: _js_module_onMessage,
    G: _js_open_process,
    da: _js_popen_to_file,
    W: _makecontext,
    sa: _proc_exit,
    F: _strftime,
    V: _strptime,
    U: _swapcontext,
    u: _wasm_close,
    z: _wasm_poll_socket,
    p: _wasm_setsockopt,
    T: _wasm_shutdown
  };
  var asm = createWasm();
  var ___wasm_call_ctors = function() {
    return (___wasm_call_ctors = Module["asm"]["bb"]).apply(null, arguments);
  };
  var _free = function() {
    return (_free = Module["asm"]["cb"]).apply(null, arguments);
  };
  var _memcpy = function() {
    return (_memcpy = Module["asm"]["db"]).apply(null, arguments);
  };
  var _malloc = function() {
    return (_malloc = Module["asm"]["fb"]).apply(null, arguments);
  };
  var setTempRet0 = function() {
    return (setTempRet0 = Module["asm"]["gb"]).apply(null, arguments);
  };
  var ___errno_location = function() {
    return (___errno_location = Module["asm"]["hb"]).apply(null, arguments);
  };
  var _wasm_read = Module["_wasm_read"] = function() {
    return (_wasm_read = Module["_wasm_read"] = Module["asm"]["ib"]).apply(null, arguments);
  };
  var _fflush = Module["_fflush"] = function() {
    return (_fflush = Module["_fflush"] = Module["asm"]["jb"]).apply(null, arguments);
  };
  var _wasm_popen = Module["_wasm_popen"] = function() {
    return (_wasm_popen = Module["_wasm_popen"] = Module["asm"]["kb"]).apply(null, arguments);
  };
  var _wasm_php_exec = Module["_wasm_php_exec"] = function() {
    return (_wasm_php_exec = Module["_wasm_php_exec"] = Module["asm"]["lb"]).apply(null, arguments);
  };
  var _php_pollfd_for = Module["_php_pollfd_for"] = function() {
    return (_php_pollfd_for = Module["_php_pollfd_for"] = Module["asm"]["mb"]).apply(null, arguments);
  };
  var _htons = function() {
    return (_htons = Module["asm"]["nb"]).apply(null, arguments);
  };
  var _ntohs = function() {
    return (_ntohs = Module["asm"]["ob"]).apply(null, arguments);
  };
  var _htonl = function() {
    return (_htonl = Module["asm"]["pb"]).apply(null, arguments);
  };
  var _wasm_sleep = Module["_wasm_sleep"] = function() {
    return (_wasm_sleep = Module["_wasm_sleep"] = Module["asm"]["qb"]).apply(null, arguments);
  };
  var _wasm_select = Module["_wasm_select"] = function() {
    return (_wasm_select = Module["_wasm_select"] = Module["asm"]["rb"]).apply(null, arguments);
  };
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = function() {
    return (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = Module["asm"]["sb"]).apply(null, arguments);
  };
  var _run_cli = Module["_run_cli"] = function() {
    return (_run_cli = Module["_run_cli"] = Module["asm"]["tb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = function() {
    return (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = Module["asm"]["ub"]).apply(null, arguments);
  };
  var _wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = function() {
    return (_wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = Module["asm"]["vb"]).apply(null, arguments);
  };
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = function() {
    return (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = Module["asm"]["wb"]).apply(null, arguments);
  };
  var _wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = function() {
    return (_wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = Module["asm"]["xb"]).apply(null, arguments);
  };
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = function() {
    return (_wasm_set_query_string = Module["_wasm_set_query_string"] = Module["asm"]["yb"]).apply(null, arguments);
  };
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = function() {
    return (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = Module["asm"]["zb"]).apply(null, arguments);
  };
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = function() {
    return (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = Module["asm"]["Ab"]).apply(null, arguments);
  };
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = function() {
    return (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = Module["asm"]["Bb"]).apply(null, arguments);
  };
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = function() {
    return (_wasm_set_request_method = Module["_wasm_set_request_method"] = Module["asm"]["Cb"]).apply(null, arguments);
  };
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = function() {
    return (_wasm_set_request_host = Module["_wasm_set_request_host"] = Module["asm"]["Db"]).apply(null, arguments);
  };
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = function() {
    return (_wasm_set_content_type = Module["_wasm_set_content_type"] = Module["asm"]["Eb"]).apply(null, arguments);
  };
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = function() {
    return (_wasm_set_request_body = Module["_wasm_set_request_body"] = Module["asm"]["Fb"]).apply(null, arguments);
  };
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = function() {
    return (_wasm_set_content_length = Module["_wasm_set_content_length"] = Module["asm"]["Gb"]).apply(null, arguments);
  };
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = function() {
    return (_wasm_set_cookies = Module["_wasm_set_cookies"] = Module["asm"]["Hb"]).apply(null, arguments);
  };
  var _wasm_set_php_code = Module["_wasm_set_php_code"] = function() {
    return (_wasm_set_php_code = Module["_wasm_set_php_code"] = Module["asm"]["Ib"]).apply(null, arguments);
  };
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = function() {
    return (_wasm_set_request_port = Module["_wasm_set_request_port"] = Module["asm"]["Jb"]).apply(null, arguments);
  };
  var _phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = function() {
    return (_phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = Module["asm"]["Kb"]).apply(null, arguments);
  };
  var _phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = function() {
    return (_phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = Module["asm"]["Lb"]).apply(null, arguments);
  };
  var _phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = function() {
    return (_phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = Module["asm"]["Mb"]).apply(null, arguments);
  };
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = function() {
    return (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = Module["asm"]["Nb"]).apply(null, arguments);
  };
  var _php_wasm_init = Module["_php_wasm_init"] = function() {
    return (_php_wasm_init = Module["_php_wasm_init"] = Module["asm"]["Ob"]).apply(null, arguments);
  };
  var ___funcs_on_exit = function() {
    return (___funcs_on_exit = Module["asm"]["Pb"]).apply(null, arguments);
  };
  var _emscripten_builtin_memalign = function() {
    return (_emscripten_builtin_memalign = Module["asm"]["Qb"]).apply(null, arguments);
  };
  var __emscripten_timeout = function() {
    return (__emscripten_timeout = Module["asm"]["Rb"]).apply(null, arguments);
  };
  var _setThrew = function() {
    return (_setThrew = Module["asm"]["Sb"]).apply(null, arguments);
  };
  var _emscripten_stack_set_limits = function() {
    return (_emscripten_stack_set_limits = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
  };
  var _emscripten_stack_get_base = function() {
    return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
  };
  var _emscripten_stack_get_end = function() {
    return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
  };
  var stackSave = function() {
    return (stackSave = Module["asm"]["Tb"]).apply(null, arguments);
  };
  var stackRestore = function() {
    return (stackRestore = Module["asm"]["Ub"]).apply(null, arguments);
  };
  var stackAlloc = function() {
    return (stackAlloc = Module["asm"]["Vb"]).apply(null, arguments);
  };
  var dynCall_iiii = Module["dynCall_iiii"] = function() {
    return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["Wb"]).apply(null, arguments);
  };
  var dynCall_ii = Module["dynCall_ii"] = function() {
    return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["Xb"]).apply(null, arguments);
  };
  var dynCall_vi = Module["dynCall_vi"] = function() {
    return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["Yb"]).apply(null, arguments);
  };
  var dynCall_vii = Module["dynCall_vii"] = function() {
    return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["Zb"]).apply(null, arguments);
  };
  var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
    return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["_b"]).apply(null, arguments);
  };
  var dynCall_iii = Module["dynCall_iii"] = function() {
    return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["$b"]).apply(null, arguments);
  };
  var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
    return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["ac"]).apply(null, arguments);
  };
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
    return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["bc"]).apply(null, arguments);
  };
  var dynCall_viii = Module["dynCall_viii"] = function() {
    return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["cc"]).apply(null, arguments);
  };
  var dynCall_v = Module["dynCall_v"] = function() {
    return (dynCall_v = Module["dynCall_v"] = Module["asm"]["dc"]).apply(null, arguments);
  };
  var dynCall_i = Module["dynCall_i"] = function() {
    return (dynCall_i = Module["dynCall_i"] = Module["asm"]["ec"]).apply(null, arguments);
  };
  var dynCall_viiii = Module["dynCall_viiii"] = function() {
    return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["fc"]).apply(null, arguments);
  };
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
    return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["gc"]).apply(null, arguments);
  };
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {
    return (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = Module["asm"]["hc"]).apply(null, arguments);
  };
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = function() {
    return (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = Module["asm"]["ic"]).apply(null, arguments);
  };
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
    return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["jc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
    return (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = Module["asm"]["kc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = function() {
    return (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = Module["asm"]["lc"]).apply(null, arguments);
  };
  var dynCall_viidii = Module["dynCall_viidii"] = function() {
    return (dynCall_viidii = Module["dynCall_viidii"] = Module["asm"]["mc"]).apply(null, arguments);
  };
  var _asyncify_start_unwind = function() {
    return (_asyncify_start_unwind = Module["asm"]["nc"]).apply(null, arguments);
  };
  var _asyncify_stop_unwind = function() {
    return (_asyncify_stop_unwind = Module["asm"]["oc"]).apply(null, arguments);
  };
  var _asyncify_start_rewind = function() {
    return (_asyncify_start_rewind = Module["asm"]["pc"]).apply(null, arguments);
  };
  var _asyncify_stop_rewind = function() {
    return (_asyncify_stop_rewind = Module["asm"]["qc"]).apply(null, arguments);
  };
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  Module["FS_unlink"] = FS.unlink;
  Module["ccall"] = ccall;
  Module["UTF8ToString"] = UTF8ToString;
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS"] = FS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  return PHPLoader;
}
var dependencyFilename3, dependenciesTotalSize3;
var init_php_8_1 = __esm({
  "packages/php-wasm/node/public/php_8_1.js"() {
    "use strict";
    dependencyFilename3 = __dirname + "/8_1_23/php_8_1.wasm";
    dependenciesTotalSize3 = 10991664;
  }
});

// packages/php-wasm/node/public/php_8_0.js
var php_8_0_exports = {};
__export(php_8_0_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize4,
  dependencyFilename: () => dependencyFilename4,
  init: () => init4
});
function init4(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = RuntimeName === "WEB";
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
    } else {
      scriptDirectory = __dirname + "/";
    }
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
    Module["inspect"] = () => "[Emscripten Module object]";
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var noExitRuntime = Module["noExitRuntime"] || false;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var wasmTable;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  var runtimeKeepaliveCounter = 0;
  function keepRuntimeAlive() {
    return noExitRuntime || runtimeKeepaliveCounter > 0;
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  function isFileURI(filename) {
    return filename.startsWith("file://");
  }
  var wasmBinaryFile;
  wasmBinaryFile = dependencyFilename4;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
      if (typeof fetch == "function") {
        return fetch(binaryFile, {
          credentials: "same-origin"
        }).then((response) => {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + binaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(() => getBinarySync(binaryFile));
      }
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then((instance) => instance).then(receiver, (reason) => {
      err("failed to asynchronously prepare wasm: " + reason);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err("wasm streaming compile failed: " + reason);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function createWasm() {
    var info = {
      "a": wasmImports
    };
    function receiveInstance(instance, module2) {
      var exports = instance.exports;
      exports = Asyncify.instrumentWasmExports(exports);
      Module["asm"] = exports;
      wasmMemory = Module["asm"]["Za"];
      updateMemoryViews();
      wasmTable = Module["asm"]["bb"];
      addOnInit(Module["asm"]["_a"]);
      removeRunDependency("wasm-instantiate");
      return exports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        return false;
      }
    }
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi.apply(null, [fp, a1]))(sig);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    },
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH_FS = {
    resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, -1);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        } else {
          result = null;
        }
      } else if (typeof window != "undefined" && typeof window.prompt == "function") {
        result = window.prompt("Input: ");
        if (result !== null) {
          result += "\n";
        }
      } else if (typeof readline == "function") {
        result = readline();
        if (result !== null) {
          result += "\n";
        }
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init: function() {
    },
    shutdown: function() {
    },
    register: function(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char: function(tty) {
        return FS_stdin_getChar();
      },
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets: function(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets: function(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz: function(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
      }
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
        old_node.parent = new_dir;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key in node.contents) {
          if (!node.contents.hasOwnProperty(key)) {
            continue;
          }
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach(function(plugin) {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  }
  function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        if (preFinish)
          preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        if (onload)
          onload();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        if (onerror)
          onerror();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, (byteArray) => processData(byteArray), onerror);
    } else {
      processData(url);
    }
  }
  function FS_modeStringToFlags(str) {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  }
  function FS_getMode(canRead, canWrite) {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  }
  var ERRNO_CODES = {};
  var NODEFS = {
    isWindows: false,
    staticInit: () => {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode: (e) => {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    mount: (mount) => NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0),
    createNode: (parent, name, mode, dev) => {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode: (path) => {
      var stat;
      try {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode = stat.mode | (stat.mode & 292) >> 2;
        }
      } catch (e) {
        if (!e.code)
          throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return stat.mode;
    },
    realPath: (node) => {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join.apply(null, parts);
    },
    flagsForNode: (flags) => {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr: (node) => {
        var path = NODEFS.realPath(node);
        var stat;
        try {
          stat = fs.lstatSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        if (NODEFS.isWindows && !stat.blksize) {
          stat.blksize = 4096;
        }
        if (NODEFS.isWindows && !stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr: (node, attr) => {
        var path = NODEFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      lookup: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod: (parent, name, mode, dev) => {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return node;
      },
      rename: (oldNode, newDir, newName) => {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          fs.renameSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        oldNode.name = newName;
      },
      unlink: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.unlinkSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      rmdir: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.rmdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readdir: (node) => {
        var path = NODEFS.realPath(node);
        try {
          return fs.readdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      symlink: (parent, newName, oldPath) => {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        try {
          fs.symlinkSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readlink: (node) => {
        var path = NODEFS.realPath(node);
        try {
          path = fs.readlinkSync(path);
          path = nodePath.relative(nodePath.resolve(node.mount.opts.root), path);
          return path;
        } catch (e) {
          if (!e.code)
            throw e;
          if (e.code === "UNKNOWN")
            throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      }
    },
    stream_ops: {
      open: (stream) => {
        var path = NODEFS.realPath(stream.node);
        try {
          if (FS.isFile(stream.node.mode)) {
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      close: (stream) => {
        try {
          if (FS.isFile(stream.node.mode) && stream.nfd) {
            fs.closeSync(stream.nfd);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      read: (stream, buffer, offset, length, position) => {
        if (length === 0)
          return 0;
        try {
          return fs.readSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      write: (stream, buffer, offset, length, position) => {
        try {
          return fs.writeSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      llseek: (stream, offset, whence) => {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap: (stream, length, position, prot, flags) => {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName: (parentid, name) => {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode: (parent, name) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode: (parent, name, mode, rdev) => {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode: (node) => {
      FS.hashRemoveNode(node);
    },
    isRoot: (node) => node === node.parent,
    isMountpoint: (node) => !!node.mounted,
    isFile: (mode) => (mode & 61440) === 32768,
    isDir: (mode) => (mode & 61440) === 16384,
    isLink: (mode) => (mode & 61440) === 40960,
    isChrdev: (mode) => (mode & 61440) === 8192,
    isBlkdev: (mode) => (mode & 61440) === 24576,
    isFIFO: (mode) => (mode & 61440) === 4096,
    isSocket: (mode) => (mode & 49152) === 49152,
    flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate: (dir, name) => {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete: (dir, name, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked: (fd) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, {
          object: {
            get() {
              return this.node;
            },
            set(val) {
              this.node = val;
            }
          },
          isRead: {
            get() {
              return (this.flags & 2097155) !== 1;
            }
          },
          isWrite: {
            get() {
              return (this.flags & 2097155) !== 0;
            }
          },
          isAppend: {
            get() {
              return this.flags & 1024;
            }
          },
          flags: {
            get() {
              return this.shared.flags;
            },
            set(val) {
              this.shared.flags = val;
            }
          },
          position: {
            get() {
              return this.shared.position;
            },
            set(val) {
              this.shared.position = val;
            }
          }
        });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream: (fd) => {
      FS.streams[fd] = null;
    },
    chrdev_stream_ops: {
      open: (stream) => {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      },
      llseek: () => {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice: (dev, ops) => {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    },
    syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount: (type, opts, mountpoint) => {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount: (mountpoint) => {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup: (parent, name) => parent.node_ops.lookup(parent, name),
    mknod: (path, mode, dev) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink: (path) => {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat: (path, dontFollow) => {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat: (path) => FS.stat(path, true),
    chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    },
    fchmod: (fd, mode) => {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    },
    fchown: (fd, uid, gid) => {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate: (fd, len) => {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime: (path, atime, mtime) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed: (stream) => stream.fd === null,
    llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read: (stream, buffer, offset, length, position) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write: (stream, buffer, offset, length, position, canOwn) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync: (stream, buffer, offset, length, mmapFlags) => {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    munmap: (stream) => 0,
    ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount: () => {
          var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: (parent, name) => {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams: () => {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
        };
        this.setErrno(errno);
        this.message = "FS error";
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    },
    staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS
      };
    },
    init: (input, output, error) => {
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile: (parent, name, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    },
    createDevice: (parent, name, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open: (stream) => {
          stream.seekable = false;
        },
        close: (stream) => {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        },
        read: (stream, buffer, offset, length, pos) => {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: (stream, buffer, offset, length, pos) => {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile: (parent, name, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, {
          length: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            }
          },
          chunkSize: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            }
          }
        });
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    varargs: void 0,
    get() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    },
    getStreamFromFD: function(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    }
  };
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
    try {
      var total = 0;
      var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;
      var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;
      var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;
      var dstReadLow = 0, dstReadHigh = 0;
      var dstWriteLow = 0, dstWriteHigh = 0;
      var dstExceptLow = 0, dstExceptHigh = 0;
      var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);
      var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);
      var check = function(fd2, low, high, val) {
        return fd2 < 32 ? low & val : high & val;
      };
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << fd % 32;
        if (!check(fd, allLow, allHigh, mask)) {
          continue;
        }
        var stream = SYSCALLS.getStreamFromFD(fd);
        var flags = SYSCALLS.DEFAULT_POLLMASK;
        if (stream.stream_ops?.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            var tv_sec = readfds ? HEAP32[timeout >> 2] : 0, tv_usec = readfds ? HEAP32[timeout + 8 >> 2] : 0;
            timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }
        if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
          total++;
        }
        if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
          total++;
        }
        if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
          total++;
        }
      }
      if (readfds) {
        HEAP32[readfds >> 2] = dstReadLow;
        HEAP32[readfds + 4 >> 2] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[writefds >> 2] = dstWriteLow;
        HEAP32[writefds + 4 >> 2] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[exceptfds >> 2] = dstExceptLow;
        HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;
      }
      return total;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  function getSocketFromFD(fd) {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  }
  var setErrNo = (value) => {
    HEAP32[___errno_location() >> 2] = value;
    return value;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name: (name) => {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr: (addr) => {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  function getSocketAddress(addrp, addrlen, allowNull) {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  }
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.createStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.createStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function convertI32PairToI53Checked(lo, hi) {
    return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  }
  function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    var len = convertI32PairToI53Checked(len_low, len_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5: {
          var arg = SYSCALLS.get();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 6:
        case 7:
          return 0;
        case 16:
        case 8:
          return -28;
        case 9:
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18 >> 0] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17 >> 0] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = SYSCALLS.get();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17 >> 0]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = SYSCALLS.get();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = SYSCALLS.get();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function readI53FromI64(ptr) {
    return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  }
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var nowIsMonotonic = true;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      return date.getTime() / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      if (Module["onExit"])
        Module["onExit"](code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var stringToNewUTF8 = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = _malloc(size);
    if (ret)
      stringToUTF8(str, ret, size);
    return ret;
  };
  var __tzset_js = (timezone, daylight, tzname) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    function extractZone(date) {
      var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
      return match ? match[1] : "GMT";
    }
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    var winterNamePtr = stringToNewUTF8(winterName);
    var summerNamePtr = stringToNewUTF8(summerName);
    if (summerOffset < winterOffset) {
      HEAPU32[tzname >> 2] = winterNamePtr;
      HEAPU32[tzname + 4 >> 2] = summerNamePtr;
    } else {
      HEAPU32[tzname >> 2] = summerNamePtr;
      HEAPU32[tzname + 4 >> 2] = winterNamePtr;
    }
  };
  var _abort = () => {
    abort("");
  };
  function _emscripten_date_now() {
    return Date.now();
  }
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = size - b.byteLength + 65535 >>> 16;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = function(ms) {
    return Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  };
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    }
    HEAP8[buffer >> 0] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf >> 0] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var getHostByName = (name) => {
    var ret = _malloc(20);
    var nameBuf = stringToNewUTF8(name);
    HEAPU32[ret >> 2] = nameBuf;
    var aliasesBuf = _malloc(4);
    HEAPU32[aliasesBuf >> 2] = 0;
    HEAPU32[ret + 4 >> 2] = aliasesBuf;
    var afinet = 2;
    HEAP32[ret + 8 >> 2] = afinet;
    HEAP32[ret + 12 >> 2] = 4;
    var addrListBuf = _malloc(12);
    HEAPU32[addrListBuf >> 2] = addrListBuf + 8;
    HEAPU32[addrListBuf + 4 >> 2] = 0;
    HEAP32[addrListBuf + 8 >> 2] = inetPton4(DNS.lookup_name(name));
    HEAPU32[ret + 16 >> 2] = addrListBuf;
    return ret;
  };
  var _gethostbyaddr = (addr, addrlen, type) => {
    if (type !== 2) {
      setErrNo(5);
      return null;
    }
    addr = HEAP32[addr >> 2];
    var host = inetNtop4(addr);
    var lookup3 = DNS.lookup_addr(host);
    if (lookup3) {
      host = lookup3;
    }
    return getHostByName(host);
  };
  var _gethostbyname = (name) => getHostByName(UTF8ToString(name));
  var _gethostbyname_r = (name, ret, buf, buflen, out2, err2) => {
    var data = _gethostbyname(name);
    _memcpy(ret, data, 20);
    _free(data);
    HEAP32[err2 >> 2] = 0;
    HEAPU32[out2 >> 2] = ret;
    return 0;
  };
  var _getloadavg = (loadavg, nelem) => {
    var limit = Math.min(nelem, 3);
    var doubleSize = 8;
    for (var i = 0; i < limit; i++) {
      HEAPF64[loadavg + i * doubleSize >> 3] = 0.1;
    }
    return limit;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitWsEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "error");
    },
    awaitWsEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command) {
      if (Module["spawnProcess"]) {
        const spawned = Module["spawnProcess"](command);
        if (!spawned || !spawned.on) {
          throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
        }
        return spawned;
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, [], {
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(procopenCallId) {
    if (!PHPWASM.input_devices) {
      PHPWASM.input_devices = {};
    }
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + procopenCallId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[procopenCallId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    var returnCode;
    var stream;
    try {
      stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      returnCode = 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      returnCode = e.errno;
    }
    if (returnCode === 6 && stream?.fd in PHPWASM.proc_fds) {
      return Asyncify.handleSleep(function(wakeUp) {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            var num2 = doReadv(stream2, iov, iovcnt);
            HEAPU32[pnum >> 2] = num2;
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          if (returnCode2 !== 6 || ++retries > maxRetries || !(stream2?.fd in PHPWASM.proc_fds) || PHPWASM.proc_fds[stream2?.fd]?.exited || FS.isClosed(stream2) || !(PHPWASM.proc_fds[fd]?.stdinFd in (PHPWASM.input_devices || {}))) {
            wakeUp(returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    }
    return returnCode;
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(0);
        });
      });
    }
  }
  function _js_open_process(command, stdinFd, stdoutChildFd, stdoutParentFd, stderrChildFd, stderrParentFd) {
    if (!PHPWASM.proc_fds) {
      PHPWASM.proc_fds = {};
    }
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let cp;
    try {
      cp = PHPWASM.spawnProcess(cmdstr);
    } catch (e) {
      if (e.code === "SPAWN_UNSUPPORTED") {
        return 1;
      }
      throw e;
    }
    let EventEmitter;
    if (ENVIRONMENT_IS_NODE) {
      EventEmitter = require("events").EventEmitter;
    } else {
      EventEmitter = function() {
        this.listeners = {};
      };
      EventEmitter.prototype.emit = function(eventName, data) {
        if (this.listeners[eventName]) {
          this.listeners[eventName].forEach(function(callback) {
            callback(data);
          });
        }
      };
      EventEmitter.prototype.once = function(eventName, callback) {
        const self2 = this;
        function removedCallback() {
          callback(...arguments);
          self2.removeListener(eventName, removedCallback);
        }
        this.on(eventName, removedCallback);
      };
      EventEmitter.prototype.on = function(eventName, callback) {
        if (!this.listeners[eventName]) {
          this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(callback);
      };
      EventEmitter.prototype.removeListener = function(eventName, callback) {
        const idx = this.listeners[eventName].indexOf(callback);
        if (idx !== -1) {
          this.listeners[eventName].splice(idx, 1);
        }
      };
    }
    PHPWASM.proc_fds[stdoutParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stdoutParentFd].stdinFd = stdinFd;
    PHPWASM.proc_fds[stderrParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stderrParentFd].stdinFd = stdinFd;
    const stdoutStream = SYSCALLS.getStreamFromFD(stdoutChildFd);
    cp.on("exit", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].exited = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      PHPWASM.proc_fds[stderrParentFd].exited = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
    });
    cp.stdout.on("data", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].hasData = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, 0);
    });
    const stderrStream = SYSCALLS.getStreamFromFD(stderrChildFd);
    cp.stderr.on("data", function(data) {
      PHPWASM.proc_fds[stderrParentFd].hasData = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
      stderrStream.stream_ops.write(stderrStream, data, 0, data.length, 0);
    });
    if (PHPWASM.input_devices && stdinFd in PHPWASM.input_devices) {
      PHPWASM.input_devices[stdinFd].onData(function(data) {
        if (!data)
          return;
        const dataStr = new TextDecoder("utf-8").decode(data);
        cp.stdin.write(dataStr);
      });
      return 0;
    }
    const stdinStream = SYSCALLS.getStreamFromFD(stdinFd);
    if (!stdinStream.node) {
      return 0;
    }
    const CHUNK_SIZE = 1024;
    const buffer = Buffer.alloc(CHUNK_SIZE);
    let offset = 0;
    while (true) {
      const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
      if (bytesRead === null || bytesRead === 0) {
        break;
      }
      try {
        cp.stdin.write(buffer.subarray(0, bytesRead));
      } catch (e) {
        console.error(e);
        return 1;
      }
      if (bytesRead < CHUNK_SIZE) {
        break;
      }
      offset += bytesRead;
    }
    return 0;
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep((wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr);
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAP32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": (date2) => getWeekBasedYear(date2),
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "%A": "%a",
      "%B": "%b",
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m\\/%d\\/%y",
      "%e": "%d",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%R": "%H\\:%M",
      "%r": "%I\\:%M\\:%S\\s%p",
      "%T": "%H\\:%M\\:%S",
      "%x": "%m\\/%d\\/(?:%y|%Y)",
      "%X": "%H\\:%M\\:%S"
    };
    for (var matcher in EQUIVALENT_MATCHERS) {
      pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
    }
    var DATE_PATTERNS = {
      "%a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      "%b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      "%C": "\\d\\d",
      "%d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      "%H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      "%I": "\\d(?!\\d)|0\\d|10|11|12",
      "%j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      "%m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      "%M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      "%n": "\\s",
      "%p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      "%S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      "%U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%w": "[0-6]",
      "%y": "\\d\\d",
      "%Y": "\\d\\d\\d\\d",
      "%%": "%",
      "%t": "\\s"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    for (var datePattern in DATE_PATTERNS) {
      pattern = pattern.replace(datePattern, "(" + datePattern + DATE_PATTERNS[datePattern] + ")");
    }
    var capture = [];
    for (var i = pattern.indexOf("%"); i >= 0; i = pattern.indexOf("%")) {
      capture.push(pattern[i + 1]);
      pattern = pattern.replace(new RegExp("\\%" + pattern[i + 1], "g"), "");
    }
    var matches = new RegExp("^" + pattern, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59)
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (PHPWASM.proc_fds && socketd in PHPWASM.proc_fds) {
        const emitter = PHPWASM.proc_fds[socketd];
        if (emitter.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitWsEvent(emitter, "data"));
      } else {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  function runAndAbortIfError(func) {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  }
  var Asyncify = {
    instrumentWasmImports: function(imports) {
      var importPatterns = [/^_dlopen_js$/, /^invoke_i$/, /^invoke_ii$/, /^invoke_iii$/, /^invoke_iiii$/, /^invoke_iiiii$/, /^invoke_iiiiii$/, /^invoke_iiiiiii$/, /^invoke_iiiiiiii$/, /^invoke_iiiiiiiiii$/, /^invoke_v$/, /^invoke_vi$/, /^invoke_vii$/, /^invoke_viidii$/, /^invoke_viii$/, /^invoke_viiii$/, /^invoke_viiiii$/, /^invoke_viiiiii$/, /^invoke_viiiiiii$/, /^invoke_viiiiiiiii$/, /^js_open_process$/, /^js_popen_to_file$/, /^js_fd_read$/, /^js_module_onMessage$/, /^wasm_poll_socket$/, /^wasm_shutdown$/, /^fd_sync$/, /^__wasi_fd_sync$/, /^__asyncjs__.*$/, /^emscripten_promise_await$/, /^emscripten_idb_load$/, /^emscripten_idb_store$/, /^emscripten_idb_delete$/, /^emscripten_idb_exists$/, /^emscripten_idb_load_blob$/, /^emscripten_idb_store_blob$/, /^emscripten_sleep$/, /^emscripten_wget_data$/, /^emscripten_scan_registers$/, /^emscripten_lazy_load_code$/, /^_load_secondary_module$/, /^emscripten_fiber_swap$/, /^SDL_Delay$/];
      for (var x in imports) {
        (function(x2) {
          var original = imports[x2];
          var sig = original.sig;
          if (typeof original == "function") {
            var isAsyncifyImport = original.isAsync || importPatterns.some((pattern) => !!x2.match(pattern));
          }
        })(x);
      }
    },
    instrumentWasmExports: function(exports) {
      var ret = {};
      for (var x in exports) {
        (function(x2) {
          var original = exports[x2];
          if (typeof original == "function") {
            ret[x2] = function() {
              Asyncify.exportCallStack.push(x2);
              try {
                return original.apply(null, arguments);
              } finally {
                if (!ABORT) {
                  var y = Asyncify.exportCallStack.pop();
                  assert(y === x2);
                  Asyncify.maybeStopUnwind();
                }
              }
            };
          } else {
            ret[x2] = original;
          }
        })(x);
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId: function(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind: function() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone: function() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData: function() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader: function(ptr, stack, stackSize) {
      HEAP32[ptr >> 2] = stack;
      HEAP32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc: function(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFunc: function(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      var func = Module["asm"][name];
      return func;
    },
    doRewind: function(ptr) {
      var start = Asyncify.getDataRewindFunc(ptr);
      runtimeKeepalivePop();
      return start();
    },
    handleSleep: function(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach((func) => callUserCallback(func));
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync: function(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  function getCFunc(ident) {
    var func = Module["_" + ident];
    return func;
  }
  var ccall = function(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func.apply(null, cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts && opts.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FSNode = function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
    read: {
      get: function() {
        return (this.mode & readMode) === readMode;
      },
      set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }
    },
    write: {
      get: function() {
        return (this.mode & writeMode) === writeMode;
      },
      set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }
    },
    isFolder: {
      get: function() {
        return FS.isDir(this.mode);
      }
    },
    isDevice: {
      get: function() {
        return FS.isChrdev(this.mode);
      }
    }
  });
  FS.FSNode = FSNode;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var wasmImports = {
    m: ___assert_fail,
    Ya: ___call_sighandler,
    Xa: ___syscall__newselect,
    Wa: ___syscall_accept4,
    Va: ___syscall_bind,
    Ua: ___syscall_chdir,
    T: ___syscall_chmod,
    Ta: ___syscall_connect,
    Sa: ___syscall_dup,
    Ra: ___syscall_dup3,
    Qa: ___syscall_faccessat,
    ba: ___syscall_fallocate,
    Pa: ___syscall_fchmod,
    Oa: ___syscall_fchown32,
    S: ___syscall_fchownat,
    o: ___syscall_fcntl64,
    Na: ___syscall_fdatasync,
    Ma: ___syscall_fstat64,
    aa: ___syscall_ftruncate64,
    La: ___syscall_getcwd,
    Ka: ___syscall_getdents64,
    Ja: ___syscall_getpeername,
    Ia: ___syscall_getsockname,
    Ha: ___syscall_getsockopt,
    R: ___syscall_ioctl,
    Ga: ___syscall_listen,
    Fa: ___syscall_lstat64,
    Ea: ___syscall_mkdirat,
    Da: ___syscall_newfstatat,
    x: ___syscall_openat,
    Ca: ___syscall_pipe,
    Ba: ___syscall_poll,
    Aa: ___syscall_readlinkat,
    za: ___syscall_recvfrom,
    ya: ___syscall_renameat,
    Q: ___syscall_rmdir,
    xa: ___syscall_sendto,
    P: ___syscall_socket,
    wa: ___syscall_stat64,
    va: ___syscall_statfs64,
    ua: ___syscall_symlink,
    D: ___syscall_unlinkat,
    ta: ___syscall_utimensat,
    pa: __emscripten_get_now_is_monotonic,
    oa: __emscripten_throw_longjmp,
    _: __gmtime_js,
    Z: __localtime_js,
    Y: __mktime_js,
    X: __mmap_js,
    W: __munmap_js,
    M: __setitimer_js,
    na: __tzset_js,
    f: _abort,
    B: _emscripten_date_now,
    ma: _emscripten_get_heap_max,
    v: _emscripten_get_now,
    la: _emscripten_memcpy_big,
    ka: _emscripten_resize_heap,
    L: _emscripten_sleep,
    sa: _environ_get,
    ra: _environ_sizes_get,
    p: _exit,
    s: _fd_close,
    O: _fd_fdstat_get,
    N: _fd_read,
    $: _fd_seek,
    C: _fd_write,
    ja: _getaddrinfo,
    K: _gethostbyaddr,
    J: _gethostbyname_r,
    ia: _getloadavg,
    I: _getnameinfo,
    ha: _getprotobyname,
    ga: _getprotobynumber,
    i: invoke_i,
    c: invoke_ii,
    b: invoke_iii,
    g: invoke_iiii,
    h: invoke_iiiii,
    u: invoke_iiiiii,
    r: invoke_iiiiiii,
    w: invoke_iiiiiiii,
    H: invoke_iiiiiiiiii,
    e: invoke_v,
    a: invoke_vi,
    d: invoke_vii,
    A: invoke_viidii,
    l: invoke_viii,
    j: invoke_viiii,
    n: invoke_viiiii,
    k: invoke_viiiiii,
    fa: invoke_viiiiiii,
    z: invoke_viiiiiiiii,
    G: _js_create_input_device,
    ea: _js_fd_read,
    da: _js_module_onMessage,
    F: _js_open_process,
    ca: _js_popen_to_file,
    qa: _proc_exit,
    E: _strftime,
    V: _strptime,
    t: _wasm_close,
    y: _wasm_poll_socket,
    q: _wasm_setsockopt,
    U: _wasm_shutdown
  };
  var asm = createWasm();
  var ___wasm_call_ctors = function() {
    return (___wasm_call_ctors = Module["asm"]["_a"]).apply(null, arguments);
  };
  var _free = function() {
    return (_free = Module["asm"]["$a"]).apply(null, arguments);
  };
  var _memcpy = function() {
    return (_memcpy = Module["asm"]["ab"]).apply(null, arguments);
  };
  var _malloc = function() {
    return (_malloc = Module["asm"]["cb"]).apply(null, arguments);
  };
  var setTempRet0 = function() {
    return (setTempRet0 = Module["asm"]["db"]).apply(null, arguments);
  };
  var ___errno_location = function() {
    return (___errno_location = Module["asm"]["eb"]).apply(null, arguments);
  };
  var _wasm_read = Module["_wasm_read"] = function() {
    return (_wasm_read = Module["_wasm_read"] = Module["asm"]["fb"]).apply(null, arguments);
  };
  var _fflush = Module["_fflush"] = function() {
    return (_fflush = Module["_fflush"] = Module["asm"]["gb"]).apply(null, arguments);
  };
  var _wasm_popen = Module["_wasm_popen"] = function() {
    return (_wasm_popen = Module["_wasm_popen"] = Module["asm"]["hb"]).apply(null, arguments);
  };
  var _wasm_php_exec = Module["_wasm_php_exec"] = function() {
    return (_wasm_php_exec = Module["_wasm_php_exec"] = Module["asm"]["ib"]).apply(null, arguments);
  };
  var _php_pollfd_for = Module["_php_pollfd_for"] = function() {
    return (_php_pollfd_for = Module["_php_pollfd_for"] = Module["asm"]["jb"]).apply(null, arguments);
  };
  var _htons = function() {
    return (_htons = Module["asm"]["kb"]).apply(null, arguments);
  };
  var _ntohs = function() {
    return (_ntohs = Module["asm"]["lb"]).apply(null, arguments);
  };
  var _htonl = function() {
    return (_htonl = Module["asm"]["mb"]).apply(null, arguments);
  };
  var _wasm_sleep = Module["_wasm_sleep"] = function() {
    return (_wasm_sleep = Module["_wasm_sleep"] = Module["asm"]["nb"]).apply(null, arguments);
  };
  var _wasm_select = Module["_wasm_select"] = function() {
    return (_wasm_select = Module["_wasm_select"] = Module["asm"]["ob"]).apply(null, arguments);
  };
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = function() {
    return (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = Module["asm"]["pb"]).apply(null, arguments);
  };
  var _run_cli = Module["_run_cli"] = function() {
    return (_run_cli = Module["_run_cli"] = Module["asm"]["qb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = function() {
    return (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = Module["asm"]["rb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = function() {
    return (_wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = Module["asm"]["sb"]).apply(null, arguments);
  };
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = function() {
    return (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = Module["asm"]["tb"]).apply(null, arguments);
  };
  var _wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = function() {
    return (_wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = Module["asm"]["ub"]).apply(null, arguments);
  };
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = function() {
    return (_wasm_set_query_string = Module["_wasm_set_query_string"] = Module["asm"]["vb"]).apply(null, arguments);
  };
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = function() {
    return (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = Module["asm"]["wb"]).apply(null, arguments);
  };
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = function() {
    return (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = Module["asm"]["xb"]).apply(null, arguments);
  };
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = function() {
    return (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = Module["asm"]["yb"]).apply(null, arguments);
  };
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = function() {
    return (_wasm_set_request_method = Module["_wasm_set_request_method"] = Module["asm"]["zb"]).apply(null, arguments);
  };
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = function() {
    return (_wasm_set_request_host = Module["_wasm_set_request_host"] = Module["asm"]["Ab"]).apply(null, arguments);
  };
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = function() {
    return (_wasm_set_content_type = Module["_wasm_set_content_type"] = Module["asm"]["Bb"]).apply(null, arguments);
  };
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = function() {
    return (_wasm_set_request_body = Module["_wasm_set_request_body"] = Module["asm"]["Cb"]).apply(null, arguments);
  };
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = function() {
    return (_wasm_set_content_length = Module["_wasm_set_content_length"] = Module["asm"]["Db"]).apply(null, arguments);
  };
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = function() {
    return (_wasm_set_cookies = Module["_wasm_set_cookies"] = Module["asm"]["Eb"]).apply(null, arguments);
  };
  var _wasm_set_php_code = Module["_wasm_set_php_code"] = function() {
    return (_wasm_set_php_code = Module["_wasm_set_php_code"] = Module["asm"]["Fb"]).apply(null, arguments);
  };
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = function() {
    return (_wasm_set_request_port = Module["_wasm_set_request_port"] = Module["asm"]["Gb"]).apply(null, arguments);
  };
  var _phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = function() {
    return (_phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = Module["asm"]["Hb"]).apply(null, arguments);
  };
  var _phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = function() {
    return (_phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = Module["asm"]["Ib"]).apply(null, arguments);
  };
  var _phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = function() {
    return (_phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = Module["asm"]["Jb"]).apply(null, arguments);
  };
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = function() {
    return (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = Module["asm"]["Kb"]).apply(null, arguments);
  };
  var _php_wasm_init = Module["_php_wasm_init"] = function() {
    return (_php_wasm_init = Module["_php_wasm_init"] = Module["asm"]["Lb"]).apply(null, arguments);
  };
  var ___funcs_on_exit = function() {
    return (___funcs_on_exit = Module["asm"]["Mb"]).apply(null, arguments);
  };
  var _emscripten_builtin_memalign = function() {
    return (_emscripten_builtin_memalign = Module["asm"]["Nb"]).apply(null, arguments);
  };
  var __emscripten_timeout = function() {
    return (__emscripten_timeout = Module["asm"]["Ob"]).apply(null, arguments);
  };
  var _setThrew = function() {
    return (_setThrew = Module["asm"]["Pb"]).apply(null, arguments);
  };
  var _emscripten_stack_set_limits = function() {
    return (_emscripten_stack_set_limits = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
  };
  var _emscripten_stack_get_base = function() {
    return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
  };
  var _emscripten_stack_get_end = function() {
    return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
  };
  var stackSave = function() {
    return (stackSave = Module["asm"]["Qb"]).apply(null, arguments);
  };
  var stackRestore = function() {
    return (stackRestore = Module["asm"]["Rb"]).apply(null, arguments);
  };
  var stackAlloc = function() {
    return (stackAlloc = Module["asm"]["Sb"]).apply(null, arguments);
  };
  var dynCall_iiii = Module["dynCall_iiii"] = function() {
    return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["Tb"]).apply(null, arguments);
  };
  var dynCall_ii = Module["dynCall_ii"] = function() {
    return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["Ub"]).apply(null, arguments);
  };
  var dynCall_vi = Module["dynCall_vi"] = function() {
    return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["Vb"]).apply(null, arguments);
  };
  var dynCall_vii = Module["dynCall_vii"] = function() {
    return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["Wb"]).apply(null, arguments);
  };
  var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
    return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["Xb"]).apply(null, arguments);
  };
  var dynCall_iii = Module["dynCall_iii"] = function() {
    return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["Yb"]).apply(null, arguments);
  };
  var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
    return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["Zb"]).apply(null, arguments);
  };
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
    return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["_b"]).apply(null, arguments);
  };
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
    return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["$b"]).apply(null, arguments);
  };
  var dynCall_i = Module["dynCall_i"] = function() {
    return (dynCall_i = Module["dynCall_i"] = Module["asm"]["ac"]).apply(null, arguments);
  };
  var dynCall_viii = Module["dynCall_viii"] = function() {
    return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["bc"]).apply(null, arguments);
  };
  var dynCall_viiii = Module["dynCall_viiii"] = function() {
    return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["cc"]).apply(null, arguments);
  };
  var dynCall_v = Module["dynCall_v"] = function() {
    return (dynCall_v = Module["dynCall_v"] = Module["asm"]["dc"]).apply(null, arguments);
  };
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {
    return (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = Module["asm"]["ec"]).apply(null, arguments);
  };
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = function() {
    return (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = Module["asm"]["fc"]).apply(null, arguments);
  };
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
    return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["gc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
    return (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = Module["asm"]["hc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = function() {
    return (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = Module["asm"]["ic"]).apply(null, arguments);
  };
  var dynCall_viidii = Module["dynCall_viidii"] = function() {
    return (dynCall_viidii = Module["dynCall_viidii"] = Module["asm"]["jc"]).apply(null, arguments);
  };
  var _asyncify_start_unwind = function() {
    return (_asyncify_start_unwind = Module["asm"]["kc"]).apply(null, arguments);
  };
  var _asyncify_stop_unwind = function() {
    return (_asyncify_stop_unwind = Module["asm"]["lc"]).apply(null, arguments);
  };
  var _asyncify_start_rewind = function() {
    return (_asyncify_start_rewind = Module["asm"]["mc"]).apply(null, arguments);
  };
  var _asyncify_stop_rewind = function() {
    return (_asyncify_stop_rewind = Module["asm"]["nc"]).apply(null, arguments);
  };
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  Module["FS_unlink"] = FS.unlink;
  Module["ccall"] = ccall;
  Module["UTF8ToString"] = UTF8ToString;
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS"] = FS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  return PHPLoader;
}
var dependencyFilename4, dependenciesTotalSize4;
var init_php_8_0 = __esm({
  "packages/php-wasm/node/public/php_8_0.js"() {
    "use strict";
    dependencyFilename4 = __dirname + "/8_0_30/php_8_0.wasm";
    dependenciesTotalSize4 = 11119903;
  }
});

// packages/php-wasm/node/public/php_7_4.js
var php_7_4_exports = {};
__export(php_7_4_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize5,
  dependencyFilename: () => dependencyFilename5,
  init: () => init5
});
function init5(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = RuntimeName === "WEB";
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
    } else {
      scriptDirectory = __dirname + "/";
    }
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
    Module["inspect"] = () => "[Emscripten Module object]";
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var noExitRuntime = Module["noExitRuntime"] || false;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var wasmTable;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  var runtimeKeepaliveCounter = 0;
  function keepRuntimeAlive() {
    return noExitRuntime || runtimeKeepaliveCounter > 0;
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  function isFileURI(filename) {
    return filename.startsWith("file://");
  }
  var wasmBinaryFile;
  wasmBinaryFile = dependencyFilename5;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
      if (typeof fetch == "function") {
        return fetch(binaryFile, {
          credentials: "same-origin"
        }).then((response) => {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + binaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(() => getBinarySync(binaryFile));
      }
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then((instance) => instance).then(receiver, (reason) => {
      err("failed to asynchronously prepare wasm: " + reason);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err("wasm streaming compile failed: " + reason);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function createWasm() {
    var info = {
      "a": wasmImports
    };
    function receiveInstance(instance, module2) {
      var exports = instance.exports;
      exports = Asyncify.instrumentWasmExports(exports);
      Module["asm"] = exports;
      wasmMemory = Module["asm"]["Ya"];
      updateMemoryViews();
      wasmTable = Module["asm"]["$a"];
      addOnInit(Module["asm"]["Za"]);
      removeRunDependency("wasm-instantiate");
      return exports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        return false;
      }
    }
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi.apply(null, [fp, a1]))(sig);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    },
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH_FS = {
    resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, -1);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        } else {
          result = null;
        }
      } else if (typeof window != "undefined" && typeof window.prompt == "function") {
        result = window.prompt("Input: ");
        if (result !== null) {
          result += "\n";
        }
      } else if (typeof readline == "function") {
        result = readline();
        if (result !== null) {
          result += "\n";
        }
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init: function() {
    },
    shutdown: function() {
    },
    register: function(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char: function(tty) {
        return FS_stdin_getChar();
      },
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets: function(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets: function(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz: function(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
      }
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
        old_node.parent = new_dir;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key in node.contents) {
          if (!node.contents.hasOwnProperty(key)) {
            continue;
          }
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach(function(plugin) {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  }
  function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        if (preFinish)
          preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        if (onload)
          onload();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        if (onerror)
          onerror();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, (byteArray) => processData(byteArray), onerror);
    } else {
      processData(url);
    }
  }
  function FS_modeStringToFlags(str) {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  }
  function FS_getMode(canRead, canWrite) {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  }
  var ERRNO_CODES = {};
  var NODEFS = {
    isWindows: false,
    staticInit: () => {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode: (e) => {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    mount: (mount) => NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0),
    createNode: (parent, name, mode, dev) => {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode: (path) => {
      var stat;
      try {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode = stat.mode | (stat.mode & 292) >> 2;
        }
      } catch (e) {
        if (!e.code)
          throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return stat.mode;
    },
    realPath: (node) => {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join.apply(null, parts);
    },
    flagsForNode: (flags) => {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr: (node) => {
        var path = NODEFS.realPath(node);
        var stat;
        try {
          stat = fs.lstatSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        if (NODEFS.isWindows && !stat.blksize) {
          stat.blksize = 4096;
        }
        if (NODEFS.isWindows && !stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr: (node, attr) => {
        var path = NODEFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      lookup: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod: (parent, name, mode, dev) => {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return node;
      },
      rename: (oldNode, newDir, newName) => {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          fs.renameSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        oldNode.name = newName;
      },
      unlink: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.unlinkSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      rmdir: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.rmdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readdir: (node) => {
        var path = NODEFS.realPath(node);
        try {
          return fs.readdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      symlink: (parent, newName, oldPath) => {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        try {
          fs.symlinkSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readlink: (node) => {
        var path = NODEFS.realPath(node);
        try {
          path = fs.readlinkSync(path);
          path = nodePath.relative(nodePath.resolve(node.mount.opts.root), path);
          return path;
        } catch (e) {
          if (!e.code)
            throw e;
          if (e.code === "UNKNOWN")
            throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      }
    },
    stream_ops: {
      open: (stream) => {
        var path = NODEFS.realPath(stream.node);
        try {
          if (FS.isFile(stream.node.mode)) {
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      close: (stream) => {
        try {
          if (FS.isFile(stream.node.mode) && stream.nfd) {
            fs.closeSync(stream.nfd);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      read: (stream, buffer, offset, length, position) => {
        if (length === 0)
          return 0;
        try {
          return fs.readSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      write: (stream, buffer, offset, length, position) => {
        try {
          return fs.writeSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      llseek: (stream, offset, whence) => {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap: (stream, length, position, prot, flags) => {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName: (parentid, name) => {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode: (parent, name) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode: (parent, name, mode, rdev) => {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode: (node) => {
      FS.hashRemoveNode(node);
    },
    isRoot: (node) => node === node.parent,
    isMountpoint: (node) => !!node.mounted,
    isFile: (mode) => (mode & 61440) === 32768,
    isDir: (mode) => (mode & 61440) === 16384,
    isLink: (mode) => (mode & 61440) === 40960,
    isChrdev: (mode) => (mode & 61440) === 8192,
    isBlkdev: (mode) => (mode & 61440) === 24576,
    isFIFO: (mode) => (mode & 61440) === 4096,
    isSocket: (mode) => (mode & 49152) === 49152,
    flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate: (dir, name) => {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete: (dir, name, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked: (fd) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, {
          object: {
            get() {
              return this.node;
            },
            set(val) {
              this.node = val;
            }
          },
          isRead: {
            get() {
              return (this.flags & 2097155) !== 1;
            }
          },
          isWrite: {
            get() {
              return (this.flags & 2097155) !== 0;
            }
          },
          isAppend: {
            get() {
              return this.flags & 1024;
            }
          },
          flags: {
            get() {
              return this.shared.flags;
            },
            set(val) {
              this.shared.flags = val;
            }
          },
          position: {
            get() {
              return this.shared.position;
            },
            set(val) {
              this.shared.position = val;
            }
          }
        });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream: (fd) => {
      FS.streams[fd] = null;
    },
    chrdev_stream_ops: {
      open: (stream) => {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      },
      llseek: () => {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice: (dev, ops) => {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    },
    syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount: (type, opts, mountpoint) => {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount: (mountpoint) => {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup: (parent, name) => parent.node_ops.lookup(parent, name),
    mknod: (path, mode, dev) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink: (path) => {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat: (path, dontFollow) => {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat: (path) => FS.stat(path, true),
    chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    },
    fchmod: (fd, mode) => {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    },
    fchown: (fd, uid, gid) => {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate: (fd, len) => {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime: (path, atime, mtime) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed: (stream) => stream.fd === null,
    llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read: (stream, buffer, offset, length, position) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write: (stream, buffer, offset, length, position, canOwn) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync: (stream, buffer, offset, length, mmapFlags) => {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    munmap: (stream) => 0,
    ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount: () => {
          var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: (parent, name) => {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams: () => {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
        };
        this.setErrno(errno);
        this.message = "FS error";
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    },
    staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS
      };
    },
    init: (input, output, error) => {
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile: (parent, name, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    },
    createDevice: (parent, name, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open: (stream) => {
          stream.seekable = false;
        },
        close: (stream) => {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        },
        read: (stream, buffer, offset, length, pos) => {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: (stream, buffer, offset, length, pos) => {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile: (parent, name, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, {
          length: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            }
          },
          chunkSize: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            }
          }
        });
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    varargs: void 0,
    get() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    },
    getStreamFromFD: function(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    }
  };
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
    try {
      var total = 0;
      var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;
      var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;
      var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;
      var dstReadLow = 0, dstReadHigh = 0;
      var dstWriteLow = 0, dstWriteHigh = 0;
      var dstExceptLow = 0, dstExceptHigh = 0;
      var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);
      var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);
      var check = function(fd2, low, high, val) {
        return fd2 < 32 ? low & val : high & val;
      };
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << fd % 32;
        if (!check(fd, allLow, allHigh, mask)) {
          continue;
        }
        var stream = SYSCALLS.getStreamFromFD(fd);
        var flags = SYSCALLS.DEFAULT_POLLMASK;
        if (stream.stream_ops?.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            var tv_sec = readfds ? HEAP32[timeout >> 2] : 0, tv_usec = readfds ? HEAP32[timeout + 8 >> 2] : 0;
            timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }
        if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
          total++;
        }
        if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
          total++;
        }
        if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
          total++;
        }
      }
      if (readfds) {
        HEAP32[readfds >> 2] = dstReadLow;
        HEAP32[readfds + 4 >> 2] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[writefds >> 2] = dstWriteLow;
        HEAP32[writefds + 4 >> 2] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[exceptfds >> 2] = dstExceptLow;
        HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;
      }
      return total;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  function getSocketFromFD(fd) {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  }
  var setErrNo = (value) => {
    HEAP32[___errno_location() >> 2] = value;
    return value;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name: (name) => {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr: (addr) => {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  function getSocketAddress(addrp, addrlen, allowNull) {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  }
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.createStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.createStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function convertI32PairToI53Checked(lo, hi) {
    return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  }
  function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    var len = convertI32PairToI53Checked(len_low, len_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5: {
          var arg = SYSCALLS.get();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 6:
        case 7:
          return 0;
        case 16:
        case 8:
          return -28;
        case 9:
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18 >> 0] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17 >> 0] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = SYSCALLS.get();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17 >> 0]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = SYSCALLS.get();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = SYSCALLS.get();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function readI53FromI64(ptr) {
    return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  }
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var nowIsMonotonic = true;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      return date.getTime() / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      if (Module["onExit"])
        Module["onExit"](code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var stringToNewUTF8 = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = _malloc(size);
    if (ret)
      stringToUTF8(str, ret, size);
    return ret;
  };
  var __tzset_js = (timezone, daylight, tzname) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    function extractZone(date) {
      var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
      return match ? match[1] : "GMT";
    }
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    var winterNamePtr = stringToNewUTF8(winterName);
    var summerNamePtr = stringToNewUTF8(summerName);
    if (summerOffset < winterOffset) {
      HEAPU32[tzname >> 2] = winterNamePtr;
      HEAPU32[tzname + 4 >> 2] = summerNamePtr;
    } else {
      HEAPU32[tzname >> 2] = summerNamePtr;
      HEAPU32[tzname + 4 >> 2] = winterNamePtr;
    }
  };
  var _abort = () => {
    abort("");
  };
  function _emscripten_date_now() {
    return Date.now();
  }
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = size - b.byteLength + 65535 >>> 16;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = function(ms) {
    return Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  };
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    }
    HEAP8[buffer >> 0] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf >> 0] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var getHostByName = (name) => {
    var ret = _malloc(20);
    var nameBuf = stringToNewUTF8(name);
    HEAPU32[ret >> 2] = nameBuf;
    var aliasesBuf = _malloc(4);
    HEAPU32[aliasesBuf >> 2] = 0;
    HEAPU32[ret + 4 >> 2] = aliasesBuf;
    var afinet = 2;
    HEAP32[ret + 8 >> 2] = afinet;
    HEAP32[ret + 12 >> 2] = 4;
    var addrListBuf = _malloc(12);
    HEAPU32[addrListBuf >> 2] = addrListBuf + 8;
    HEAPU32[addrListBuf + 4 >> 2] = 0;
    HEAP32[addrListBuf + 8 >> 2] = inetPton4(DNS.lookup_name(name));
    HEAPU32[ret + 16 >> 2] = addrListBuf;
    return ret;
  };
  var _gethostbyaddr = (addr, addrlen, type) => {
    if (type !== 2) {
      setErrNo(5);
      return null;
    }
    addr = HEAP32[addr >> 2];
    var host = inetNtop4(addr);
    var lookup3 = DNS.lookup_addr(host);
    if (lookup3) {
      host = lookup3;
    }
    return getHostByName(host);
  };
  var _gethostbyname = (name) => getHostByName(UTF8ToString(name));
  var _gethostbyname_r = (name, ret, buf, buflen, out2, err2) => {
    var data = _gethostbyname(name);
    _memcpy(ret, data, 20);
    _free(data);
    HEAP32[err2 >> 2] = 0;
    HEAPU32[out2 >> 2] = ret;
    return 0;
  };
  var _getloadavg = (loadavg, nelem) => {
    var limit = Math.min(nelem, 3);
    var doubleSize = 8;
    for (var i = 0; i < limit; i++) {
      HEAPF64[loadavg + i * doubleSize >> 3] = 0.1;
    }
    return limit;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitWsEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "error");
    },
    awaitWsEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command) {
      if (Module["spawnProcess"]) {
        const spawned = Module["spawnProcess"](command);
        if (!spawned || !spawned.on) {
          throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
        }
        return spawned;
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, [], {
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(procopenCallId) {
    if (!PHPWASM.input_devices) {
      PHPWASM.input_devices = {};
    }
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + procopenCallId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[procopenCallId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    var returnCode;
    var stream;
    try {
      stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      returnCode = 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      returnCode = e.errno;
    }
    if (returnCode === 6 && stream?.fd in PHPWASM.proc_fds) {
      return Asyncify.handleSleep(function(wakeUp) {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            var num2 = doReadv(stream2, iov, iovcnt);
            HEAPU32[pnum >> 2] = num2;
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          if (returnCode2 !== 6 || ++retries > maxRetries || !(stream2?.fd in PHPWASM.proc_fds) || PHPWASM.proc_fds[stream2?.fd]?.exited || FS.isClosed(stream2) || !(PHPWASM.proc_fds[fd]?.stdinFd in (PHPWASM.input_devices || {}))) {
            wakeUp(returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    }
    return returnCode;
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(0);
        });
      });
    }
  }
  function _js_open_process(command, stdinFd, stdoutChildFd, stdoutParentFd, stderrChildFd, stderrParentFd) {
    if (!PHPWASM.proc_fds) {
      PHPWASM.proc_fds = {};
    }
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let cp;
    try {
      cp = PHPWASM.spawnProcess(cmdstr);
    } catch (e) {
      if (e.code === "SPAWN_UNSUPPORTED") {
        return 1;
      }
      throw e;
    }
    let EventEmitter;
    if (ENVIRONMENT_IS_NODE) {
      EventEmitter = require("events").EventEmitter;
    } else {
      EventEmitter = function() {
        this.listeners = {};
      };
      EventEmitter.prototype.emit = function(eventName, data) {
        if (this.listeners[eventName]) {
          this.listeners[eventName].forEach(function(callback) {
            callback(data);
          });
        }
      };
      EventEmitter.prototype.once = function(eventName, callback) {
        const self2 = this;
        function removedCallback() {
          callback(...arguments);
          self2.removeListener(eventName, removedCallback);
        }
        this.on(eventName, removedCallback);
      };
      EventEmitter.prototype.on = function(eventName, callback) {
        if (!this.listeners[eventName]) {
          this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(callback);
      };
      EventEmitter.prototype.removeListener = function(eventName, callback) {
        const idx = this.listeners[eventName].indexOf(callback);
        if (idx !== -1) {
          this.listeners[eventName].splice(idx, 1);
        }
      };
    }
    PHPWASM.proc_fds[stdoutParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stdoutParentFd].stdinFd = stdinFd;
    PHPWASM.proc_fds[stderrParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stderrParentFd].stdinFd = stdinFd;
    const stdoutStream = SYSCALLS.getStreamFromFD(stdoutChildFd);
    cp.on("exit", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].exited = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      PHPWASM.proc_fds[stderrParentFd].exited = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
    });
    cp.stdout.on("data", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].hasData = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, 0);
    });
    const stderrStream = SYSCALLS.getStreamFromFD(stderrChildFd);
    cp.stderr.on("data", function(data) {
      PHPWASM.proc_fds[stderrParentFd].hasData = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
      stderrStream.stream_ops.write(stderrStream, data, 0, data.length, 0);
    });
    if (PHPWASM.input_devices && stdinFd in PHPWASM.input_devices) {
      PHPWASM.input_devices[stdinFd].onData(function(data) {
        if (!data)
          return;
        const dataStr = new TextDecoder("utf-8").decode(data);
        cp.stdin.write(dataStr);
      });
      return 0;
    }
    const stdinStream = SYSCALLS.getStreamFromFD(stdinFd);
    if (!stdinStream.node) {
      return 0;
    }
    const CHUNK_SIZE = 1024;
    const buffer = Buffer.alloc(CHUNK_SIZE);
    let offset = 0;
    while (true) {
      const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
      if (bytesRead === null || bytesRead === 0) {
        break;
      }
      try {
        cp.stdin.write(buffer.subarray(0, bytesRead));
      } catch (e) {
        console.error(e);
        return 1;
      }
      if (bytesRead < CHUNK_SIZE) {
        break;
      }
      offset += bytesRead;
    }
    return 0;
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep((wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr);
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAP32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": (date2) => getWeekBasedYear(date2),
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "%A": "%a",
      "%B": "%b",
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m\\/%d\\/%y",
      "%e": "%d",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%R": "%H\\:%M",
      "%r": "%I\\:%M\\:%S\\s%p",
      "%T": "%H\\:%M\\:%S",
      "%x": "%m\\/%d\\/(?:%y|%Y)",
      "%X": "%H\\:%M\\:%S"
    };
    for (var matcher in EQUIVALENT_MATCHERS) {
      pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
    }
    var DATE_PATTERNS = {
      "%a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      "%b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      "%C": "\\d\\d",
      "%d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      "%H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      "%I": "\\d(?!\\d)|0\\d|10|11|12",
      "%j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      "%m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      "%M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      "%n": "\\s",
      "%p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      "%S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      "%U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%w": "[0-6]",
      "%y": "\\d\\d",
      "%Y": "\\d\\d\\d\\d",
      "%%": "%",
      "%t": "\\s"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    for (var datePattern in DATE_PATTERNS) {
      pattern = pattern.replace(datePattern, "(" + datePattern + DATE_PATTERNS[datePattern] + ")");
    }
    var capture = [];
    for (var i = pattern.indexOf("%"); i >= 0; i = pattern.indexOf("%")) {
      capture.push(pattern[i + 1]);
      pattern = pattern.replace(new RegExp("\\%" + pattern[i + 1], "g"), "");
    }
    var matches = new RegExp("^" + pattern, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59)
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (PHPWASM.proc_fds && socketd in PHPWASM.proc_fds) {
        const emitter = PHPWASM.proc_fds[socketd];
        if (emitter.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitWsEvent(emitter, "data"));
      } else {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  function runAndAbortIfError(func) {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  }
  var Asyncify = {
    instrumentWasmImports: function(imports) {
      var importPatterns = [/^_dlopen_js$/, /^invoke_i$/, /^invoke_ii$/, /^invoke_iii$/, /^invoke_iiii$/, /^invoke_iiiii$/, /^invoke_iiiiii$/, /^invoke_iiiiiii$/, /^invoke_iiiiiiii$/, /^invoke_iiiiiiiiii$/, /^invoke_v$/, /^invoke_vi$/, /^invoke_vii$/, /^invoke_viidii$/, /^invoke_viii$/, /^invoke_viiii$/, /^invoke_viiiii$/, /^invoke_viiiiii$/, /^invoke_viiiiiii$/, /^invoke_viiiiiiiii$/, /^js_open_process$/, /^js_popen_to_file$/, /^js_fd_read$/, /^js_module_onMessage$/, /^wasm_poll_socket$/, /^wasm_shutdown$/, /^fd_sync$/, /^__wasi_fd_sync$/, /^__asyncjs__.*$/, /^emscripten_promise_await$/, /^emscripten_idb_load$/, /^emscripten_idb_store$/, /^emscripten_idb_delete$/, /^emscripten_idb_exists$/, /^emscripten_idb_load_blob$/, /^emscripten_idb_store_blob$/, /^emscripten_sleep$/, /^emscripten_wget_data$/, /^emscripten_scan_registers$/, /^emscripten_lazy_load_code$/, /^_load_secondary_module$/, /^emscripten_fiber_swap$/, /^SDL_Delay$/];
      for (var x in imports) {
        (function(x2) {
          var original = imports[x2];
          var sig = original.sig;
          if (typeof original == "function") {
            var isAsyncifyImport = original.isAsync || importPatterns.some((pattern) => !!x2.match(pattern));
          }
        })(x);
      }
    },
    instrumentWasmExports: function(exports) {
      var ret = {};
      for (var x in exports) {
        (function(x2) {
          var original = exports[x2];
          if (typeof original == "function") {
            ret[x2] = function() {
              Asyncify.exportCallStack.push(x2);
              try {
                return original.apply(null, arguments);
              } finally {
                if (!ABORT) {
                  var y = Asyncify.exportCallStack.pop();
                  assert(y === x2);
                  Asyncify.maybeStopUnwind();
                }
              }
            };
          } else {
            ret[x2] = original;
          }
        })(x);
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId: function(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind: function() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone: function() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData: function() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader: function(ptr, stack, stackSize) {
      HEAP32[ptr >> 2] = stack;
      HEAP32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc: function(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFunc: function(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      var func = Module["asm"][name];
      return func;
    },
    doRewind: function(ptr) {
      var start = Asyncify.getDataRewindFunc(ptr);
      runtimeKeepalivePop();
      return start();
    },
    handleSleep: function(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach((func) => callUserCallback(func));
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync: function(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  function getCFunc(ident) {
    var func = Module["_" + ident];
    return func;
  }
  var ccall = function(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func.apply(null, cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts && opts.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FSNode = function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
    read: {
      get: function() {
        return (this.mode & readMode) === readMode;
      },
      set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }
    },
    write: {
      get: function() {
        return (this.mode & writeMode) === writeMode;
      },
      set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }
    },
    isFolder: {
      get: function() {
        return FS.isDir(this.mode);
      }
    },
    isDevice: {
      get: function() {
        return FS.isChrdev(this.mode);
      }
    }
  });
  FS.FSNode = FSNode;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var wasmImports = {
    k: ___assert_fail,
    Xa: ___call_sighandler,
    Wa: ___syscall__newselect,
    Va: ___syscall_accept4,
    Ua: ___syscall_bind,
    Ta: ___syscall_chdir,
    T: ___syscall_chmod,
    Sa: ___syscall_connect,
    Ra: ___syscall_dup,
    Qa: ___syscall_dup3,
    Pa: ___syscall_faccessat,
    ba: ___syscall_fallocate,
    Oa: ___syscall_fchmod,
    Na: ___syscall_fchown32,
    S: ___syscall_fchownat,
    o: ___syscall_fcntl64,
    Ma: ___syscall_fdatasync,
    La: ___syscall_fstat64,
    aa: ___syscall_ftruncate64,
    Ka: ___syscall_getcwd,
    Ja: ___syscall_getdents64,
    Ia: ___syscall_getpeername,
    Ha: ___syscall_getsockname,
    Ga: ___syscall_getsockopt,
    R: ___syscall_ioctl,
    Fa: ___syscall_listen,
    Ea: ___syscall_lstat64,
    Da: ___syscall_mkdirat,
    Ca: ___syscall_newfstatat,
    x: ___syscall_openat,
    Ba: ___syscall_pipe,
    Aa: ___syscall_poll,
    za: ___syscall_readlinkat,
    ya: ___syscall_recvfrom,
    xa: ___syscall_renameat,
    Q: ___syscall_rmdir,
    wa: ___syscall_sendto,
    P: ___syscall_socket,
    va: ___syscall_stat64,
    ua: ___syscall_statfs64,
    ta: ___syscall_symlink,
    D: ___syscall_unlinkat,
    sa: ___syscall_utimensat,
    oa: __emscripten_get_now_is_monotonic,
    na: __emscripten_throw_longjmp,
    _: __gmtime_js,
    Z: __localtime_js,
    Y: __mktime_js,
    X: __mmap_js,
    W: __munmap_js,
    M: __setitimer_js,
    ma: __tzset_js,
    e: _abort,
    B: _emscripten_date_now,
    la: _emscripten_get_heap_max,
    v: _emscripten_get_now,
    ka: _emscripten_memcpy_big,
    ja: _emscripten_resize_heap,
    L: _emscripten_sleep,
    ra: _environ_get,
    qa: _environ_sizes_get,
    p: _exit,
    r: _fd_close,
    O: _fd_fdstat_get,
    N: _fd_read,
    $: _fd_seek,
    C: _fd_write,
    ia: _getaddrinfo,
    K: _gethostbyaddr,
    J: _gethostbyname_r,
    ha: _getloadavg,
    I: _getnameinfo,
    ga: _getprotobyname,
    fa: _getprotobynumber,
    i: invoke_i,
    d: invoke_ii,
    b: invoke_iii,
    g: invoke_iiii,
    h: invoke_iiiii,
    u: invoke_iiiiii,
    t: invoke_iiiiiii,
    w: invoke_iiiiiiii,
    H: invoke_iiiiiiiiii,
    f: invoke_v,
    a: invoke_vi,
    c: invoke_vii,
    A: invoke_viidii,
    l: invoke_viii,
    m: invoke_viiii,
    n: invoke_viiiii,
    j: invoke_viiiiii,
    z: invoke_viiiiiiiii,
    G: _js_create_input_device,
    ea: _js_fd_read,
    da: _js_module_onMessage,
    F: _js_open_process,
    ca: _js_popen_to_file,
    pa: _proc_exit,
    E: _strftime,
    V: _strptime,
    s: _wasm_close,
    y: _wasm_poll_socket,
    q: _wasm_setsockopt,
    U: _wasm_shutdown
  };
  var asm = createWasm();
  var ___wasm_call_ctors = function() {
    return (___wasm_call_ctors = Module["asm"]["Za"]).apply(null, arguments);
  };
  var _free = function() {
    return (_free = Module["asm"]["_a"]).apply(null, arguments);
  };
  var _memcpy = function() {
    return (_memcpy = Module["asm"]["ab"]).apply(null, arguments);
  };
  var _malloc = function() {
    return (_malloc = Module["asm"]["bb"]).apply(null, arguments);
  };
  var setTempRet0 = function() {
    return (setTempRet0 = Module["asm"]["cb"]).apply(null, arguments);
  };
  var ___errno_location = function() {
    return (___errno_location = Module["asm"]["db"]).apply(null, arguments);
  };
  var _wasm_read = Module["_wasm_read"] = function() {
    return (_wasm_read = Module["_wasm_read"] = Module["asm"]["eb"]).apply(null, arguments);
  };
  var _php_pollfd_for = Module["_php_pollfd_for"] = function() {
    return (_php_pollfd_for = Module["_php_pollfd_for"] = Module["asm"]["fb"]).apply(null, arguments);
  };
  var _fflush = Module["_fflush"] = function() {
    return (_fflush = Module["_fflush"] = Module["asm"]["gb"]).apply(null, arguments);
  };
  var _wasm_popen = Module["_wasm_popen"] = function() {
    return (_wasm_popen = Module["_wasm_popen"] = Module["asm"]["hb"]).apply(null, arguments);
  };
  var _wasm_php_exec = Module["_wasm_php_exec"] = function() {
    return (_wasm_php_exec = Module["_wasm_php_exec"] = Module["asm"]["ib"]).apply(null, arguments);
  };
  var _htons = function() {
    return (_htons = Module["asm"]["jb"]).apply(null, arguments);
  };
  var _ntohs = function() {
    return (_ntohs = Module["asm"]["kb"]).apply(null, arguments);
  };
  var _htonl = function() {
    return (_htonl = Module["asm"]["lb"]).apply(null, arguments);
  };
  var _wasm_sleep = Module["_wasm_sleep"] = function() {
    return (_wasm_sleep = Module["_wasm_sleep"] = Module["asm"]["mb"]).apply(null, arguments);
  };
  var _wasm_select = Module["_wasm_select"] = function() {
    return (_wasm_select = Module["_wasm_select"] = Module["asm"]["nb"]).apply(null, arguments);
  };
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = function() {
    return (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = Module["asm"]["ob"]).apply(null, arguments);
  };
  var _run_cli = Module["_run_cli"] = function() {
    return (_run_cli = Module["_run_cli"] = Module["asm"]["pb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = function() {
    return (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = Module["asm"]["qb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = function() {
    return (_wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = Module["asm"]["rb"]).apply(null, arguments);
  };
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = function() {
    return (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = Module["asm"]["sb"]).apply(null, arguments);
  };
  var _wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = function() {
    return (_wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = Module["asm"]["tb"]).apply(null, arguments);
  };
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = function() {
    return (_wasm_set_query_string = Module["_wasm_set_query_string"] = Module["asm"]["ub"]).apply(null, arguments);
  };
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = function() {
    return (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = Module["asm"]["vb"]).apply(null, arguments);
  };
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = function() {
    return (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = Module["asm"]["wb"]).apply(null, arguments);
  };
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = function() {
    return (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = Module["asm"]["xb"]).apply(null, arguments);
  };
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = function() {
    return (_wasm_set_request_method = Module["_wasm_set_request_method"] = Module["asm"]["yb"]).apply(null, arguments);
  };
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = function() {
    return (_wasm_set_request_host = Module["_wasm_set_request_host"] = Module["asm"]["zb"]).apply(null, arguments);
  };
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = function() {
    return (_wasm_set_content_type = Module["_wasm_set_content_type"] = Module["asm"]["Ab"]).apply(null, arguments);
  };
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = function() {
    return (_wasm_set_request_body = Module["_wasm_set_request_body"] = Module["asm"]["Bb"]).apply(null, arguments);
  };
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = function() {
    return (_wasm_set_content_length = Module["_wasm_set_content_length"] = Module["asm"]["Cb"]).apply(null, arguments);
  };
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = function() {
    return (_wasm_set_cookies = Module["_wasm_set_cookies"] = Module["asm"]["Db"]).apply(null, arguments);
  };
  var _wasm_set_php_code = Module["_wasm_set_php_code"] = function() {
    return (_wasm_set_php_code = Module["_wasm_set_php_code"] = Module["asm"]["Eb"]).apply(null, arguments);
  };
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = function() {
    return (_wasm_set_request_port = Module["_wasm_set_request_port"] = Module["asm"]["Fb"]).apply(null, arguments);
  };
  var _phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = function() {
    return (_phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = Module["asm"]["Gb"]).apply(null, arguments);
  };
  var _phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = function() {
    return (_phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = Module["asm"]["Hb"]).apply(null, arguments);
  };
  var _phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = function() {
    return (_phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = Module["asm"]["Ib"]).apply(null, arguments);
  };
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = function() {
    return (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = Module["asm"]["Jb"]).apply(null, arguments);
  };
  var _php_wasm_init = Module["_php_wasm_init"] = function() {
    return (_php_wasm_init = Module["_php_wasm_init"] = Module["asm"]["Kb"]).apply(null, arguments);
  };
  var ___funcs_on_exit = function() {
    return (___funcs_on_exit = Module["asm"]["Lb"]).apply(null, arguments);
  };
  var _emscripten_builtin_memalign = function() {
    return (_emscripten_builtin_memalign = Module["asm"]["Mb"]).apply(null, arguments);
  };
  var __emscripten_timeout = function() {
    return (__emscripten_timeout = Module["asm"]["Nb"]).apply(null, arguments);
  };
  var _setThrew = function() {
    return (_setThrew = Module["asm"]["Ob"]).apply(null, arguments);
  };
  var _emscripten_stack_set_limits = function() {
    return (_emscripten_stack_set_limits = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
  };
  var _emscripten_stack_get_base = function() {
    return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
  };
  var _emscripten_stack_get_end = function() {
    return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
  };
  var stackSave = function() {
    return (stackSave = Module["asm"]["Pb"]).apply(null, arguments);
  };
  var stackRestore = function() {
    return (stackRestore = Module["asm"]["Qb"]).apply(null, arguments);
  };
  var stackAlloc = function() {
    return (stackAlloc = Module["asm"]["Rb"]).apply(null, arguments);
  };
  var dynCall_vi = Module["dynCall_vi"] = function() {
    return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["Sb"]).apply(null, arguments);
  };
  var dynCall_vii = Module["dynCall_vii"] = function() {
    return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["Tb"]).apply(null, arguments);
  };
  var dynCall_viii = Module["dynCall_viii"] = function() {
    return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["Ub"]).apply(null, arguments);
  };
  var dynCall_ii = Module["dynCall_ii"] = function() {
    return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["Vb"]).apply(null, arguments);
  };
  var dynCall_iiii = Module["dynCall_iiii"] = function() {
    return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["Wb"]).apply(null, arguments);
  };
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
    return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["Xb"]).apply(null, arguments);
  };
  var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
    return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["Yb"]).apply(null, arguments);
  };
  var dynCall_iii = Module["dynCall_iii"] = function() {
    return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["Zb"]).apply(null, arguments);
  };
  var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
    return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["_b"]).apply(null, arguments);
  };
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
    return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["$b"]).apply(null, arguments);
  };
  var dynCall_i = Module["dynCall_i"] = function() {
    return (dynCall_i = Module["dynCall_i"] = Module["asm"]["ac"]).apply(null, arguments);
  };
  var dynCall_v = Module["dynCall_v"] = function() {
    return (dynCall_v = Module["dynCall_v"] = Module["asm"]["bc"]).apply(null, arguments);
  };
  var dynCall_viiii = Module["dynCall_viiii"] = function() {
    return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["cc"]).apply(null, arguments);
  };
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {
    return (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = Module["asm"]["dc"]).apply(null, arguments);
  };
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
    return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["ec"]).apply(null, arguments);
  };
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
    return (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = Module["asm"]["fc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = function() {
    return (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = Module["asm"]["gc"]).apply(null, arguments);
  };
  var dynCall_viidii = Module["dynCall_viidii"] = function() {
    return (dynCall_viidii = Module["dynCall_viidii"] = Module["asm"]["hc"]).apply(null, arguments);
  };
  var _asyncify_start_unwind = function() {
    return (_asyncify_start_unwind = Module["asm"]["ic"]).apply(null, arguments);
  };
  var _asyncify_stop_unwind = function() {
    return (_asyncify_stop_unwind = Module["asm"]["jc"]).apply(null, arguments);
  };
  var _asyncify_start_rewind = function() {
    return (_asyncify_start_rewind = Module["asm"]["kc"]).apply(null, arguments);
  };
  var _asyncify_stop_rewind = function() {
    return (_asyncify_stop_rewind = Module["asm"]["lc"]).apply(null, arguments);
  };
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  Module["FS_unlink"] = FS.unlink;
  Module["ccall"] = ccall;
  Module["UTF8ToString"] = UTF8ToString;
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS"] = FS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  return PHPLoader;
}
var dependencyFilename5, dependenciesTotalSize5;
var init_php_7_4 = __esm({
  "packages/php-wasm/node/public/php_7_4.js"() {
    "use strict";
    dependencyFilename5 = __dirname + "/7_4_33/php_7_4.wasm";
    dependenciesTotalSize5 = 11980702;
  }
});

// packages/php-wasm/node/public/php_7_3.js
var php_7_3_exports = {};
__export(php_7_3_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize6,
  dependencyFilename: () => dependencyFilename6,
  init: () => init6
});
function init6(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = RuntimeName === "WEB";
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
    } else {
      scriptDirectory = __dirname + "/";
    }
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
    Module["inspect"] = () => "[Emscripten Module object]";
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var noExitRuntime = Module["noExitRuntime"] || false;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var wasmTable;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  var runtimeKeepaliveCounter = 0;
  function keepRuntimeAlive() {
    return noExitRuntime || runtimeKeepaliveCounter > 0;
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  function isFileURI(filename) {
    return filename.startsWith("file://");
  }
  var wasmBinaryFile;
  wasmBinaryFile = dependencyFilename6;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
      if (typeof fetch == "function") {
        return fetch(binaryFile, {
          credentials: "same-origin"
        }).then((response) => {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + binaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(() => getBinarySync(binaryFile));
      }
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then((instance) => instance).then(receiver, (reason) => {
      err("failed to asynchronously prepare wasm: " + reason);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err("wasm streaming compile failed: " + reason);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function createWasm() {
    var info = {
      "a": wasmImports
    };
    function receiveInstance(instance, module2) {
      var exports = instance.exports;
      exports = Asyncify.instrumentWasmExports(exports);
      Module["asm"] = exports;
      wasmMemory = Module["asm"]["Wa"];
      updateMemoryViews();
      wasmTable = Module["asm"]["$a"];
      addOnInit(Module["asm"]["Xa"]);
      removeRunDependency("wasm-instantiate");
      return exports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        return false;
      }
    }
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi.apply(null, [fp, a1]))(sig);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    },
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH_FS = {
    resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, -1);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        } else {
          result = null;
        }
      } else if (typeof window != "undefined" && typeof window.prompt == "function") {
        result = window.prompt("Input: ");
        if (result !== null) {
          result += "\n";
        }
      } else if (typeof readline == "function") {
        result = readline();
        if (result !== null) {
          result += "\n";
        }
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init: function() {
    },
    shutdown: function() {
    },
    register: function(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char: function(tty) {
        return FS_stdin_getChar();
      },
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets: function(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets: function(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz: function(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
      }
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
        old_node.parent = new_dir;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key in node.contents) {
          if (!node.contents.hasOwnProperty(key)) {
            continue;
          }
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach(function(plugin) {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  }
  function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        if (preFinish)
          preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        if (onload)
          onload();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        if (onerror)
          onerror();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, (byteArray) => processData(byteArray), onerror);
    } else {
      processData(url);
    }
  }
  function FS_modeStringToFlags(str) {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  }
  function FS_getMode(canRead, canWrite) {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  }
  var ERRNO_CODES = {};
  var NODEFS = {
    isWindows: false,
    staticInit: () => {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode: (e) => {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    mount: (mount) => NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0),
    createNode: (parent, name, mode, dev) => {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode: (path) => {
      var stat;
      try {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode = stat.mode | (stat.mode & 292) >> 2;
        }
      } catch (e) {
        if (!e.code)
          throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return stat.mode;
    },
    realPath: (node) => {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join.apply(null, parts);
    },
    flagsForNode: (flags) => {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr: (node) => {
        var path = NODEFS.realPath(node);
        var stat;
        try {
          stat = fs.lstatSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        if (NODEFS.isWindows && !stat.blksize) {
          stat.blksize = 4096;
        }
        if (NODEFS.isWindows && !stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr: (node, attr) => {
        var path = NODEFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      lookup: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod: (parent, name, mode, dev) => {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return node;
      },
      rename: (oldNode, newDir, newName) => {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          fs.renameSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        oldNode.name = newName;
      },
      unlink: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.unlinkSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      rmdir: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.rmdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readdir: (node) => {
        var path = NODEFS.realPath(node);
        try {
          return fs.readdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      symlink: (parent, newName, oldPath) => {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        try {
          fs.symlinkSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readlink: (node) => {
        var path = NODEFS.realPath(node);
        try {
          path = fs.readlinkSync(path);
          path = nodePath.relative(nodePath.resolve(node.mount.opts.root), path);
          return path;
        } catch (e) {
          if (!e.code)
            throw e;
          if (e.code === "UNKNOWN")
            throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      }
    },
    stream_ops: {
      open: (stream) => {
        var path = NODEFS.realPath(stream.node);
        try {
          if (FS.isFile(stream.node.mode)) {
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      close: (stream) => {
        try {
          if (FS.isFile(stream.node.mode) && stream.nfd) {
            fs.closeSync(stream.nfd);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      read: (stream, buffer, offset, length, position) => {
        if (length === 0)
          return 0;
        try {
          return fs.readSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      write: (stream, buffer, offset, length, position) => {
        try {
          return fs.writeSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      llseek: (stream, offset, whence) => {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap: (stream, length, position, prot, flags) => {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName: (parentid, name) => {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode: (parent, name) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode: (parent, name, mode, rdev) => {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode: (node) => {
      FS.hashRemoveNode(node);
    },
    isRoot: (node) => node === node.parent,
    isMountpoint: (node) => !!node.mounted,
    isFile: (mode) => (mode & 61440) === 32768,
    isDir: (mode) => (mode & 61440) === 16384,
    isLink: (mode) => (mode & 61440) === 40960,
    isChrdev: (mode) => (mode & 61440) === 8192,
    isBlkdev: (mode) => (mode & 61440) === 24576,
    isFIFO: (mode) => (mode & 61440) === 4096,
    isSocket: (mode) => (mode & 49152) === 49152,
    flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate: (dir, name) => {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete: (dir, name, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked: (fd) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, {
          object: {
            get() {
              return this.node;
            },
            set(val) {
              this.node = val;
            }
          },
          isRead: {
            get() {
              return (this.flags & 2097155) !== 1;
            }
          },
          isWrite: {
            get() {
              return (this.flags & 2097155) !== 0;
            }
          },
          isAppend: {
            get() {
              return this.flags & 1024;
            }
          },
          flags: {
            get() {
              return this.shared.flags;
            },
            set(val) {
              this.shared.flags = val;
            }
          },
          position: {
            get() {
              return this.shared.position;
            },
            set(val) {
              this.shared.position = val;
            }
          }
        });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream: (fd) => {
      FS.streams[fd] = null;
    },
    chrdev_stream_ops: {
      open: (stream) => {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      },
      llseek: () => {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice: (dev, ops) => {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    },
    syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount: (type, opts, mountpoint) => {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount: (mountpoint) => {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup: (parent, name) => parent.node_ops.lookup(parent, name),
    mknod: (path, mode, dev) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink: (path) => {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat: (path, dontFollow) => {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat: (path) => FS.stat(path, true),
    chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    },
    fchmod: (fd, mode) => {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    },
    fchown: (fd, uid, gid) => {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate: (fd, len) => {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime: (path, atime, mtime) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed: (stream) => stream.fd === null,
    llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read: (stream, buffer, offset, length, position) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write: (stream, buffer, offset, length, position, canOwn) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync: (stream, buffer, offset, length, mmapFlags) => {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    munmap: (stream) => 0,
    ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount: () => {
          var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: (parent, name) => {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams: () => {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
        };
        this.setErrno(errno);
        this.message = "FS error";
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    },
    staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS
      };
    },
    init: (input, output, error) => {
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile: (parent, name, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    },
    createDevice: (parent, name, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open: (stream) => {
          stream.seekable = false;
        },
        close: (stream) => {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        },
        read: (stream, buffer, offset, length, pos) => {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: (stream, buffer, offset, length, pos) => {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile: (parent, name, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, {
          length: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            }
          },
          chunkSize: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            }
          }
        });
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    varargs: void 0,
    get() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    },
    getStreamFromFD: function(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    }
  };
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
    try {
      var total = 0;
      var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;
      var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;
      var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;
      var dstReadLow = 0, dstReadHigh = 0;
      var dstWriteLow = 0, dstWriteHigh = 0;
      var dstExceptLow = 0, dstExceptHigh = 0;
      var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);
      var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);
      var check = function(fd2, low, high, val) {
        return fd2 < 32 ? low & val : high & val;
      };
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << fd % 32;
        if (!check(fd, allLow, allHigh, mask)) {
          continue;
        }
        var stream = SYSCALLS.getStreamFromFD(fd);
        var flags = SYSCALLS.DEFAULT_POLLMASK;
        if (stream.stream_ops?.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            var tv_sec = readfds ? HEAP32[timeout >> 2] : 0, tv_usec = readfds ? HEAP32[timeout + 8 >> 2] : 0;
            timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }
        if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
          total++;
        }
        if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
          total++;
        }
        if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
          total++;
        }
      }
      if (readfds) {
        HEAP32[readfds >> 2] = dstReadLow;
        HEAP32[readfds + 4 >> 2] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[writefds >> 2] = dstWriteLow;
        HEAP32[writefds + 4 >> 2] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[exceptfds >> 2] = dstExceptLow;
        HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;
      }
      return total;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  function getSocketFromFD(fd) {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  }
  var setErrNo = (value) => {
    HEAP32[___errno_location() >> 2] = value;
    return value;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name: (name) => {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr: (addr) => {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  function getSocketAddress(addrp, addrlen, allowNull) {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  }
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.createStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.createStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5: {
          var arg = SYSCALLS.get();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 6:
        case 7:
          return 0;
        case 16:
        case 8:
          return -28;
        case 9:
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function convertI32PairToI53Checked(lo, hi) {
    return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18 >> 0] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17 >> 0] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = SYSCALLS.get();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17 >> 0]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = SYSCALLS.get();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = SYSCALLS.get();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function readI53FromI64(ptr) {
    return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  }
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var nowIsMonotonic = true;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      return date.getTime() / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      if (Module["onExit"])
        Module["onExit"](code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var stringToNewUTF8 = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = _malloc(size);
    if (ret)
      stringToUTF8(str, ret, size);
    return ret;
  };
  var __tzset_js = (timezone, daylight, tzname) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    function extractZone(date) {
      var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
      return match ? match[1] : "GMT";
    }
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    var winterNamePtr = stringToNewUTF8(winterName);
    var summerNamePtr = stringToNewUTF8(summerName);
    if (summerOffset < winterOffset) {
      HEAPU32[tzname >> 2] = winterNamePtr;
      HEAPU32[tzname + 4 >> 2] = summerNamePtr;
    } else {
      HEAPU32[tzname >> 2] = summerNamePtr;
      HEAPU32[tzname + 4 >> 2] = winterNamePtr;
    }
  };
  var _abort = () => {
    abort("");
  };
  function _emscripten_date_now() {
    return Date.now();
  }
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = size - b.byteLength + 65535 >>> 16;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = function(ms) {
    return Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  };
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    }
    HEAP8[buffer >> 0] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf >> 0] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_sync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep(function(wakeUp) {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, function(err2) {
          if (err2) {
            wakeUp(function() {
              return 29;
            });
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var getHostByName = (name) => {
    var ret = _malloc(20);
    var nameBuf = stringToNewUTF8(name);
    HEAPU32[ret >> 2] = nameBuf;
    var aliasesBuf = _malloc(4);
    HEAPU32[aliasesBuf >> 2] = 0;
    HEAPU32[ret + 4 >> 2] = aliasesBuf;
    var afinet = 2;
    HEAP32[ret + 8 >> 2] = afinet;
    HEAP32[ret + 12 >> 2] = 4;
    var addrListBuf = _malloc(12);
    HEAPU32[addrListBuf >> 2] = addrListBuf + 8;
    HEAPU32[addrListBuf + 4 >> 2] = 0;
    HEAP32[addrListBuf + 8 >> 2] = inetPton4(DNS.lookup_name(name));
    HEAPU32[ret + 16 >> 2] = addrListBuf;
    return ret;
  };
  var _gethostbyaddr = (addr, addrlen, type) => {
    if (type !== 2) {
      setErrNo(5);
      return null;
    }
    addr = HEAP32[addr >> 2];
    var host = inetNtop4(addr);
    var lookup3 = DNS.lookup_addr(host);
    if (lookup3) {
      host = lookup3;
    }
    return getHostByName(host);
  };
  var _gethostbyname = (name) => getHostByName(UTF8ToString(name));
  var _gethostbyname_r = (name, ret, buf, buflen, out2, err2) => {
    var data = _gethostbyname(name);
    _memcpy(ret, data, 20);
    _free(data);
    HEAP32[err2 >> 2] = 0;
    HEAPU32[out2 >> 2] = ret;
    return 0;
  };
  var _getloadavg = (loadavg, nelem) => {
    var limit = Math.min(nelem, 3);
    var doubleSize = 8;
    for (var i = 0; i < limit; i++) {
      HEAPF64[loadavg + i * doubleSize >> 3] = 0.1;
    }
    return limit;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitWsEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "error");
    },
    awaitWsEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command) {
      if (Module["spawnProcess"]) {
        const spawned = Module["spawnProcess"](command);
        if (!spawned || !spawned.on) {
          throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
        }
        return spawned;
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, [], {
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(procopenCallId) {
    if (!PHPWASM.input_devices) {
      PHPWASM.input_devices = {};
    }
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + procopenCallId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[procopenCallId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    var returnCode;
    var stream;
    try {
      stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      returnCode = 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      returnCode = e.errno;
    }
    if (returnCode === 6 && stream?.fd in PHPWASM.proc_fds) {
      return Asyncify.handleSleep(function(wakeUp) {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            var num2 = doReadv(stream2, iov, iovcnt);
            HEAPU32[pnum >> 2] = num2;
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          if (returnCode2 !== 6 || ++retries > maxRetries || !(stream2?.fd in PHPWASM.proc_fds) || PHPWASM.proc_fds[stream2?.fd]?.exited || FS.isClosed(stream2) || !(PHPWASM.proc_fds[fd]?.stdinFd in (PHPWASM.input_devices || {}))) {
            wakeUp(returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    }
    return returnCode;
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(0);
        });
      });
    }
  }
  function _js_open_process(command, stdinFd, stdoutChildFd, stdoutParentFd, stderrChildFd, stderrParentFd) {
    if (!PHPWASM.proc_fds) {
      PHPWASM.proc_fds = {};
    }
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let cp;
    try {
      cp = PHPWASM.spawnProcess(cmdstr);
    } catch (e) {
      if (e.code === "SPAWN_UNSUPPORTED") {
        return 1;
      }
      throw e;
    }
    let EventEmitter;
    if (ENVIRONMENT_IS_NODE) {
      EventEmitter = require("events").EventEmitter;
    } else {
      EventEmitter = function() {
        this.listeners = {};
      };
      EventEmitter.prototype.emit = function(eventName, data) {
        if (this.listeners[eventName]) {
          this.listeners[eventName].forEach(function(callback) {
            callback(data);
          });
        }
      };
      EventEmitter.prototype.once = function(eventName, callback) {
        const self2 = this;
        function removedCallback() {
          callback(...arguments);
          self2.removeListener(eventName, removedCallback);
        }
        this.on(eventName, removedCallback);
      };
      EventEmitter.prototype.on = function(eventName, callback) {
        if (!this.listeners[eventName]) {
          this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(callback);
      };
      EventEmitter.prototype.removeListener = function(eventName, callback) {
        const idx = this.listeners[eventName].indexOf(callback);
        if (idx !== -1) {
          this.listeners[eventName].splice(idx, 1);
        }
      };
    }
    PHPWASM.proc_fds[stdoutParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stdoutParentFd].stdinFd = stdinFd;
    PHPWASM.proc_fds[stderrParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stderrParentFd].stdinFd = stdinFd;
    const stdoutStream = SYSCALLS.getStreamFromFD(stdoutChildFd);
    cp.on("exit", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].exited = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      PHPWASM.proc_fds[stderrParentFd].exited = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
    });
    cp.stdout.on("data", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].hasData = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, 0);
    });
    const stderrStream = SYSCALLS.getStreamFromFD(stderrChildFd);
    cp.stderr.on("data", function(data) {
      PHPWASM.proc_fds[stderrParentFd].hasData = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
      stderrStream.stream_ops.write(stderrStream, data, 0, data.length, 0);
    });
    if (PHPWASM.input_devices && stdinFd in PHPWASM.input_devices) {
      PHPWASM.input_devices[stdinFd].onData(function(data) {
        if (!data)
          return;
        const dataStr = new TextDecoder("utf-8").decode(data);
        cp.stdin.write(dataStr);
      });
      return 0;
    }
    const stdinStream = SYSCALLS.getStreamFromFD(stdinFd);
    if (!stdinStream.node) {
      return 0;
    }
    const CHUNK_SIZE = 1024;
    const buffer = Buffer.alloc(CHUNK_SIZE);
    let offset = 0;
    while (true) {
      const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
      if (bytesRead === null || bytesRead === 0) {
        break;
      }
      try {
        cp.stdin.write(buffer.subarray(0, bytesRead));
      } catch (e) {
        console.error(e);
        return 1;
      }
      if (bytesRead < CHUNK_SIZE) {
        break;
      }
      offset += bytesRead;
    }
    return 0;
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep((wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr);
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAP32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": (date2) => getWeekBasedYear(date2),
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "%A": "%a",
      "%B": "%b",
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m\\/%d\\/%y",
      "%e": "%d",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%R": "%H\\:%M",
      "%r": "%I\\:%M\\:%S\\s%p",
      "%T": "%H\\:%M\\:%S",
      "%x": "%m\\/%d\\/(?:%y|%Y)",
      "%X": "%H\\:%M\\:%S"
    };
    for (var matcher in EQUIVALENT_MATCHERS) {
      pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
    }
    var DATE_PATTERNS = {
      "%a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      "%b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      "%C": "\\d\\d",
      "%d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      "%H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      "%I": "\\d(?!\\d)|0\\d|10|11|12",
      "%j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      "%m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      "%M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      "%n": "\\s",
      "%p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      "%S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      "%U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%w": "[0-6]",
      "%y": "\\d\\d",
      "%Y": "\\d\\d\\d\\d",
      "%%": "%",
      "%t": "\\s"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    for (var datePattern in DATE_PATTERNS) {
      pattern = pattern.replace(datePattern, "(" + datePattern + DATE_PATTERNS[datePattern] + ")");
    }
    var capture = [];
    for (var i = pattern.indexOf("%"); i >= 0; i = pattern.indexOf("%")) {
      capture.push(pattern[i + 1]);
      pattern = pattern.replace(new RegExp("\\%" + pattern[i + 1], "g"), "");
    }
    var matches = new RegExp("^" + pattern, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59)
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (PHPWASM.proc_fds && socketd in PHPWASM.proc_fds) {
        const emitter = PHPWASM.proc_fds[socketd];
        if (emitter.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitWsEvent(emitter, "data"));
      } else {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function runAndAbortIfError(func) {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  }
  var Asyncify = {
    instrumentWasmImports: function(imports) {
      var importPatterns = [/^_dlopen_js$/, /^invoke_i$/, /^invoke_ii$/, /^invoke_iii$/, /^invoke_iiii$/, /^invoke_iiiii$/, /^invoke_iiiiii$/, /^invoke_iiiiiii$/, /^invoke_iiiiiiii$/, /^invoke_iiiiiiiiii$/, /^invoke_v$/, /^invoke_vi$/, /^invoke_vii$/, /^invoke_viidii$/, /^invoke_viii$/, /^invoke_viiii$/, /^invoke_viiiii$/, /^invoke_viiiiii$/, /^invoke_viiiiiii$/, /^invoke_viiiiiiiii$/, /^js_open_process$/, /^js_popen_to_file$/, /^js_fd_read$/, /^js_module_onMessage$/, /^wasm_poll_socket$/, /^wasm_shutdown$/, /^fd_sync$/, /^__wasi_fd_sync$/, /^__asyncjs__.*$/, /^emscripten_promise_await$/, /^emscripten_idb_load$/, /^emscripten_idb_store$/, /^emscripten_idb_delete$/, /^emscripten_idb_exists$/, /^emscripten_idb_load_blob$/, /^emscripten_idb_store_blob$/, /^emscripten_sleep$/, /^emscripten_wget_data$/, /^emscripten_scan_registers$/, /^emscripten_lazy_load_code$/, /^_load_secondary_module$/, /^emscripten_fiber_swap$/, /^SDL_Delay$/];
      for (var x in imports) {
        (function(x2) {
          var original = imports[x2];
          var sig = original.sig;
          if (typeof original == "function") {
            var isAsyncifyImport = original.isAsync || importPatterns.some((pattern) => !!x2.match(pattern));
          }
        })(x);
      }
    },
    instrumentWasmExports: function(exports) {
      var ret = {};
      for (var x in exports) {
        (function(x2) {
          var original = exports[x2];
          if (typeof original == "function") {
            ret[x2] = function() {
              Asyncify.exportCallStack.push(x2);
              try {
                return original.apply(null, arguments);
              } finally {
                if (!ABORT) {
                  var y = Asyncify.exportCallStack.pop();
                  assert(y === x2);
                  Asyncify.maybeStopUnwind();
                }
              }
            };
          } else {
            ret[x2] = original;
          }
        })(x);
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId: function(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind: function() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone: function() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData: function() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader: function(ptr, stack, stackSize) {
      HEAP32[ptr >> 2] = stack;
      HEAP32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc: function(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFunc: function(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      var func = Module["asm"][name];
      return func;
    },
    doRewind: function(ptr) {
      var start = Asyncify.getDataRewindFunc(ptr);
      runtimeKeepalivePop();
      return start();
    },
    handleSleep: function(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach((func) => callUserCallback(func));
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync: function(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  function getCFunc(ident) {
    var func = Module["_" + ident];
    return func;
  }
  var ccall = function(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func.apply(null, cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts && opts.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FSNode = function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
    read: {
      get: function() {
        return (this.mode & readMode) === readMode;
      },
      set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }
    },
    write: {
      get: function() {
        return (this.mode & writeMode) === writeMode;
      },
      set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }
    },
    isFolder: {
      get: function() {
        return FS.isDir(this.mode);
      }
    },
    isDevice: {
      get: function() {
        return FS.isChrdev(this.mode);
      }
    }
  });
  FS.FSNode = FSNode;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var wasmImports = {
    k: ___assert_fail,
    Va: ___call_sighandler,
    Ua: ___syscall__newselect,
    Ta: ___syscall_accept4,
    Sa: ___syscall_bind,
    Ra: ___syscall_chdir,
    T: ___syscall_chmod,
    Qa: ___syscall_connect,
    Pa: ___syscall_dup,
    Oa: ___syscall_dup3,
    Na: ___syscall_faccessat,
    Ma: ___syscall_fchmod,
    La: ___syscall_fchown32,
    S: ___syscall_fchownat,
    n: ___syscall_fcntl64,
    Ka: ___syscall_fstat64,
    $: ___syscall_ftruncate64,
    Ja: ___syscall_getcwd,
    Ia: ___syscall_getdents64,
    Ha: ___syscall_getpeername,
    Ga: ___syscall_getsockname,
    Fa: ___syscall_getsockopt,
    R: ___syscall_ioctl,
    Ea: ___syscall_listen,
    Da: ___syscall_lstat64,
    Ca: ___syscall_mkdirat,
    Ba: ___syscall_newfstatat,
    x: ___syscall_openat,
    Aa: ___syscall_pipe,
    za: ___syscall_poll,
    ya: ___syscall_readlinkat,
    xa: ___syscall_recvfrom,
    wa: ___syscall_renameat,
    Q: ___syscall_rmdir,
    va: ___syscall_sendto,
    P: ___syscall_socket,
    ua: ___syscall_stat64,
    ta: ___syscall_statfs64,
    sa: ___syscall_symlink,
    E: ___syscall_unlinkat,
    ra: ___syscall_utimensat,
    ma: __emscripten_get_now_is_monotonic,
    la: __emscripten_throw_longjmp,
    Z: __gmtime_js,
    Y: __localtime_js,
    X: __mktime_js,
    W: __mmap_js,
    V: __munmap_js,
    M: __setitimer_js,
    ka: __tzset_js,
    e: _abort,
    C: _emscripten_date_now,
    ja: _emscripten_get_heap_max,
    v: _emscripten_get_now,
    ia: _emscripten_memcpy_big,
    ha: _emscripten_resize_heap,
    L: _emscripten_sleep,
    qa: _environ_get,
    pa: _environ_sizes_get,
    p: _exit,
    r: _fd_close,
    O: _fd_fdstat_get,
    N: _fd_read,
    _: _fd_seek,
    oa: _fd_sync,
    D: _fd_write,
    ga: _getaddrinfo,
    K: _gethostbyaddr,
    J: _gethostbyname_r,
    fa: _getloadavg,
    I: _getnameinfo,
    ea: _getprotobyname,
    da: _getprotobynumber,
    i: invoke_i,
    d: invoke_ii,
    b: invoke_iii,
    g: invoke_iiii,
    h: invoke_iiiii,
    u: invoke_iiiiii,
    t: invoke_iiiiiii,
    w: invoke_iiiiiiii,
    B: invoke_iiiiiiiiii,
    f: invoke_v,
    a: invoke_vi,
    c: invoke_vii,
    A: invoke_viidii,
    m: invoke_viii,
    l: invoke_viiii,
    o: invoke_viiiii,
    j: invoke_viiiiii,
    z: invoke_viiiiiiiii,
    H: _js_create_input_device,
    ca: _js_fd_read,
    ba: _js_module_onMessage,
    G: _js_open_process,
    aa: _js_popen_to_file,
    na: _proc_exit,
    F: _strftime,
    U: _strptime,
    s: _wasm_close,
    y: _wasm_poll_socket,
    q: _wasm_setsockopt
  };
  var asm = createWasm();
  var ___wasm_call_ctors = function() {
    return (___wasm_call_ctors = Module["asm"]["Xa"]).apply(null, arguments);
  };
  var _memcpy = function() {
    return (_memcpy = Module["asm"]["Ya"]).apply(null, arguments);
  };
  var _malloc = function() {
    return (_malloc = Module["asm"]["Za"]).apply(null, arguments);
  };
  var _free = function() {
    return (_free = Module["asm"]["_a"]).apply(null, arguments);
  };
  var setTempRet0 = function() {
    return (setTempRet0 = Module["asm"]["ab"]).apply(null, arguments);
  };
  var ___errno_location = function() {
    return (___errno_location = Module["asm"]["bb"]).apply(null, arguments);
  };
  var _wasm_read = Module["_wasm_read"] = function() {
    return (_wasm_read = Module["_wasm_read"] = Module["asm"]["cb"]).apply(null, arguments);
  };
  var _fflush = Module["_fflush"] = function() {
    return (_fflush = Module["_fflush"] = Module["asm"]["db"]).apply(null, arguments);
  };
  var _wasm_popen = Module["_wasm_popen"] = function() {
    return (_wasm_popen = Module["_wasm_popen"] = Module["asm"]["eb"]).apply(null, arguments);
  };
  var _wasm_php_exec = Module["_wasm_php_exec"] = function() {
    return (_wasm_php_exec = Module["_wasm_php_exec"] = Module["asm"]["fb"]).apply(null, arguments);
  };
  var _php_pollfd_for = Module["_php_pollfd_for"] = function() {
    return (_php_pollfd_for = Module["_php_pollfd_for"] = Module["asm"]["gb"]).apply(null, arguments);
  };
  var _htons = function() {
    return (_htons = Module["asm"]["hb"]).apply(null, arguments);
  };
  var _ntohs = function() {
    return (_ntohs = Module["asm"]["ib"]).apply(null, arguments);
  };
  var _htonl = function() {
    return (_htonl = Module["asm"]["jb"]).apply(null, arguments);
  };
  var _wasm_sleep = Module["_wasm_sleep"] = function() {
    return (_wasm_sleep = Module["_wasm_sleep"] = Module["asm"]["kb"]).apply(null, arguments);
  };
  var _wasm_select = Module["_wasm_select"] = function() {
    return (_wasm_select = Module["_wasm_select"] = Module["asm"]["lb"]).apply(null, arguments);
  };
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = function() {
    return (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = Module["asm"]["mb"]).apply(null, arguments);
  };
  var _run_cli = Module["_run_cli"] = function() {
    return (_run_cli = Module["_run_cli"] = Module["asm"]["nb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = function() {
    return (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = Module["asm"]["ob"]).apply(null, arguments);
  };
  var _wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = function() {
    return (_wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = Module["asm"]["pb"]).apply(null, arguments);
  };
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = function() {
    return (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = Module["asm"]["qb"]).apply(null, arguments);
  };
  var _wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = function() {
    return (_wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = Module["asm"]["rb"]).apply(null, arguments);
  };
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = function() {
    return (_wasm_set_query_string = Module["_wasm_set_query_string"] = Module["asm"]["sb"]).apply(null, arguments);
  };
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = function() {
    return (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = Module["asm"]["tb"]).apply(null, arguments);
  };
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = function() {
    return (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = Module["asm"]["ub"]).apply(null, arguments);
  };
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = function() {
    return (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = Module["asm"]["vb"]).apply(null, arguments);
  };
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = function() {
    return (_wasm_set_request_method = Module["_wasm_set_request_method"] = Module["asm"]["wb"]).apply(null, arguments);
  };
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = function() {
    return (_wasm_set_request_host = Module["_wasm_set_request_host"] = Module["asm"]["xb"]).apply(null, arguments);
  };
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = function() {
    return (_wasm_set_content_type = Module["_wasm_set_content_type"] = Module["asm"]["yb"]).apply(null, arguments);
  };
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = function() {
    return (_wasm_set_request_body = Module["_wasm_set_request_body"] = Module["asm"]["zb"]).apply(null, arguments);
  };
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = function() {
    return (_wasm_set_content_length = Module["_wasm_set_content_length"] = Module["asm"]["Ab"]).apply(null, arguments);
  };
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = function() {
    return (_wasm_set_cookies = Module["_wasm_set_cookies"] = Module["asm"]["Bb"]).apply(null, arguments);
  };
  var _wasm_set_php_code = Module["_wasm_set_php_code"] = function() {
    return (_wasm_set_php_code = Module["_wasm_set_php_code"] = Module["asm"]["Cb"]).apply(null, arguments);
  };
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = function() {
    return (_wasm_set_request_port = Module["_wasm_set_request_port"] = Module["asm"]["Db"]).apply(null, arguments);
  };
  var _phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = function() {
    return (_phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = Module["asm"]["Eb"]).apply(null, arguments);
  };
  var _phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = function() {
    return (_phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = Module["asm"]["Fb"]).apply(null, arguments);
  };
  var _phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = function() {
    return (_phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = Module["asm"]["Gb"]).apply(null, arguments);
  };
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = function() {
    return (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = Module["asm"]["Hb"]).apply(null, arguments);
  };
  var _php_wasm_init = Module["_php_wasm_init"] = function() {
    return (_php_wasm_init = Module["_php_wasm_init"] = Module["asm"]["Ib"]).apply(null, arguments);
  };
  var ___funcs_on_exit = function() {
    return (___funcs_on_exit = Module["asm"]["Jb"]).apply(null, arguments);
  };
  var _emscripten_builtin_memalign = function() {
    return (_emscripten_builtin_memalign = Module["asm"]["Kb"]).apply(null, arguments);
  };
  var __emscripten_timeout = function() {
    return (__emscripten_timeout = Module["asm"]["Lb"]).apply(null, arguments);
  };
  var _setThrew = function() {
    return (_setThrew = Module["asm"]["Mb"]).apply(null, arguments);
  };
  var _emscripten_stack_set_limits = function() {
    return (_emscripten_stack_set_limits = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
  };
  var _emscripten_stack_get_base = function() {
    return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
  };
  var _emscripten_stack_get_end = function() {
    return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
  };
  var stackSave = function() {
    return (stackSave = Module["asm"]["Nb"]).apply(null, arguments);
  };
  var stackRestore = function() {
    return (stackRestore = Module["asm"]["Ob"]).apply(null, arguments);
  };
  var stackAlloc = function() {
    return (stackAlloc = Module["asm"]["Pb"]).apply(null, arguments);
  };
  var dynCall_vi = Module["dynCall_vi"] = function() {
    return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["Qb"]).apply(null, arguments);
  };
  var dynCall_iiii = Module["dynCall_iiii"] = function() {
    return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["Rb"]).apply(null, arguments);
  };
  var dynCall_ii = Module["dynCall_ii"] = function() {
    return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["Sb"]).apply(null, arguments);
  };
  var dynCall_vii = Module["dynCall_vii"] = function() {
    return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["Tb"]).apply(null, arguments);
  };
  var dynCall_iii = Module["dynCall_iii"] = function() {
    return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["Ub"]).apply(null, arguments);
  };
  var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
    return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["Vb"]).apply(null, arguments);
  };
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
    return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["Wb"]).apply(null, arguments);
  };
  var dynCall_viiii = Module["dynCall_viiii"] = function() {
    return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["Xb"]).apply(null, arguments);
  };
  var dynCall_viii = Module["dynCall_viii"] = function() {
    return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["Yb"]).apply(null, arguments);
  };
  var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
    return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["Zb"]).apply(null, arguments);
  };
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
    return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["_b"]).apply(null, arguments);
  };
  var dynCall_i = Module["dynCall_i"] = function() {
    return (dynCall_i = Module["dynCall_i"] = Module["asm"]["$b"]).apply(null, arguments);
  };
  var dynCall_v = Module["dynCall_v"] = function() {
    return (dynCall_v = Module["dynCall_v"] = Module["asm"]["ac"]).apply(null, arguments);
  };
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {
    return (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = Module["asm"]["bc"]).apply(null, arguments);
  };
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
    return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["cc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
    return (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = Module["asm"]["dc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = function() {
    return (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = Module["asm"]["ec"]).apply(null, arguments);
  };
  var dynCall_viidii = Module["dynCall_viidii"] = function() {
    return (dynCall_viidii = Module["dynCall_viidii"] = Module["asm"]["fc"]).apply(null, arguments);
  };
  var _asyncify_start_unwind = function() {
    return (_asyncify_start_unwind = Module["asm"]["gc"]).apply(null, arguments);
  };
  var _asyncify_stop_unwind = function() {
    return (_asyncify_stop_unwind = Module["asm"]["hc"]).apply(null, arguments);
  };
  var _asyncify_start_rewind = function() {
    return (_asyncify_start_rewind = Module["asm"]["ic"]).apply(null, arguments);
  };
  var _asyncify_stop_rewind = function() {
    return (_asyncify_stop_rewind = Module["asm"]["jc"]).apply(null, arguments);
  };
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  Module["FS_unlink"] = FS.unlink;
  Module["ccall"] = ccall;
  Module["UTF8ToString"] = UTF8ToString;
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS"] = FS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  return PHPLoader;
}
var dependencyFilename6, dependenciesTotalSize6;
var init_php_7_3 = __esm({
  "packages/php-wasm/node/public/php_7_3.js"() {
    "use strict";
    dependencyFilename6 = __dirname + "/7_3_33/php_7_3.wasm";
    dependenciesTotalSize6 = 11897714;
  }
});

// packages/php-wasm/node/public/php_7_2.js
var php_7_2_exports = {};
__export(php_7_2_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize7,
  dependencyFilename: () => dependencyFilename7,
  init: () => init7
});
function init7(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = RuntimeName === "WEB";
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
    } else {
      scriptDirectory = __dirname + "/";
    }
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
    Module["inspect"] = () => "[Emscripten Module object]";
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var noExitRuntime = Module["noExitRuntime"] || false;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var wasmTable;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  var runtimeKeepaliveCounter = 0;
  function keepRuntimeAlive() {
    return noExitRuntime || runtimeKeepaliveCounter > 0;
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  function isFileURI(filename) {
    return filename.startsWith("file://");
  }
  var wasmBinaryFile;
  wasmBinaryFile = dependencyFilename7;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
      if (typeof fetch == "function") {
        return fetch(binaryFile, {
          credentials: "same-origin"
        }).then((response) => {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + binaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(() => getBinarySync(binaryFile));
      }
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then((instance) => instance).then(receiver, (reason) => {
      err("failed to asynchronously prepare wasm: " + reason);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err("wasm streaming compile failed: " + reason);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function createWasm() {
    var info = {
      "a": wasmImports
    };
    function receiveInstance(instance, module2) {
      var exports = instance.exports;
      exports = Asyncify.instrumentWasmExports(exports);
      Module["asm"] = exports;
      wasmMemory = Module["asm"]["Va"];
      updateMemoryViews();
      wasmTable = Module["asm"]["_a"];
      addOnInit(Module["asm"]["Wa"]);
      removeRunDependency("wasm-instantiate");
      return exports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        return false;
      }
    }
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi.apply(null, [fp, a1]))(sig);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    },
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH_FS = {
    resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, -1);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        } else {
          result = null;
        }
      } else if (typeof window != "undefined" && typeof window.prompt == "function") {
        result = window.prompt("Input: ");
        if (result !== null) {
          result += "\n";
        }
      } else if (typeof readline == "function") {
        result = readline();
        if (result !== null) {
          result += "\n";
        }
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init: function() {
    },
    shutdown: function() {
    },
    register: function(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char: function(tty) {
        return FS_stdin_getChar();
      },
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets: function(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets: function(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz: function(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
      }
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
        old_node.parent = new_dir;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key in node.contents) {
          if (!node.contents.hasOwnProperty(key)) {
            continue;
          }
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach(function(plugin) {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  }
  function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        if (preFinish)
          preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        if (onload)
          onload();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        if (onerror)
          onerror();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, (byteArray) => processData(byteArray), onerror);
    } else {
      processData(url);
    }
  }
  function FS_modeStringToFlags(str) {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  }
  function FS_getMode(canRead, canWrite) {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  }
  var ERRNO_CODES = {};
  var NODEFS = {
    isWindows: false,
    staticInit: () => {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode: (e) => {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    mount: (mount) => NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0),
    createNode: (parent, name, mode, dev) => {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode: (path) => {
      var stat;
      try {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode = stat.mode | (stat.mode & 292) >> 2;
        }
      } catch (e) {
        if (!e.code)
          throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return stat.mode;
    },
    realPath: (node) => {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join.apply(null, parts);
    },
    flagsForNode: (flags) => {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr: (node) => {
        var path = NODEFS.realPath(node);
        var stat;
        try {
          stat = fs.lstatSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        if (NODEFS.isWindows && !stat.blksize) {
          stat.blksize = 4096;
        }
        if (NODEFS.isWindows && !stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr: (node, attr) => {
        var path = NODEFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      lookup: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod: (parent, name, mode, dev) => {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return node;
      },
      rename: (oldNode, newDir, newName) => {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          fs.renameSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        oldNode.name = newName;
      },
      unlink: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.unlinkSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      rmdir: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.rmdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readdir: (node) => {
        var path = NODEFS.realPath(node);
        try {
          return fs.readdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      symlink: (parent, newName, oldPath) => {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        try {
          fs.symlinkSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readlink: (node) => {
        var path = NODEFS.realPath(node);
        try {
          path = fs.readlinkSync(path);
          path = nodePath.relative(nodePath.resolve(node.mount.opts.root), path);
          return path;
        } catch (e) {
          if (!e.code)
            throw e;
          if (e.code === "UNKNOWN")
            throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      }
    },
    stream_ops: {
      open: (stream) => {
        var path = NODEFS.realPath(stream.node);
        try {
          if (FS.isFile(stream.node.mode)) {
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      close: (stream) => {
        try {
          if (FS.isFile(stream.node.mode) && stream.nfd) {
            fs.closeSync(stream.nfd);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      read: (stream, buffer, offset, length, position) => {
        if (length === 0)
          return 0;
        try {
          return fs.readSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      write: (stream, buffer, offset, length, position) => {
        try {
          return fs.writeSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      llseek: (stream, offset, whence) => {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap: (stream, length, position, prot, flags) => {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName: (parentid, name) => {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode: (parent, name) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode: (parent, name, mode, rdev) => {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode: (node) => {
      FS.hashRemoveNode(node);
    },
    isRoot: (node) => node === node.parent,
    isMountpoint: (node) => !!node.mounted,
    isFile: (mode) => (mode & 61440) === 32768,
    isDir: (mode) => (mode & 61440) === 16384,
    isLink: (mode) => (mode & 61440) === 40960,
    isChrdev: (mode) => (mode & 61440) === 8192,
    isBlkdev: (mode) => (mode & 61440) === 24576,
    isFIFO: (mode) => (mode & 61440) === 4096,
    isSocket: (mode) => (mode & 49152) === 49152,
    flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate: (dir, name) => {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete: (dir, name, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked: (fd) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, {
          object: {
            get() {
              return this.node;
            },
            set(val) {
              this.node = val;
            }
          },
          isRead: {
            get() {
              return (this.flags & 2097155) !== 1;
            }
          },
          isWrite: {
            get() {
              return (this.flags & 2097155) !== 0;
            }
          },
          isAppend: {
            get() {
              return this.flags & 1024;
            }
          },
          flags: {
            get() {
              return this.shared.flags;
            },
            set(val) {
              this.shared.flags = val;
            }
          },
          position: {
            get() {
              return this.shared.position;
            },
            set(val) {
              this.shared.position = val;
            }
          }
        });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream: (fd) => {
      FS.streams[fd] = null;
    },
    chrdev_stream_ops: {
      open: (stream) => {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      },
      llseek: () => {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice: (dev, ops) => {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    },
    syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount: (type, opts, mountpoint) => {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount: (mountpoint) => {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup: (parent, name) => parent.node_ops.lookup(parent, name),
    mknod: (path, mode, dev) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink: (path) => {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat: (path, dontFollow) => {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat: (path) => FS.stat(path, true),
    chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    },
    fchmod: (fd, mode) => {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    },
    fchown: (fd, uid, gid) => {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate: (fd, len) => {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime: (path, atime, mtime) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed: (stream) => stream.fd === null,
    llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read: (stream, buffer, offset, length, position) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write: (stream, buffer, offset, length, position, canOwn) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync: (stream, buffer, offset, length, mmapFlags) => {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    munmap: (stream) => 0,
    ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount: () => {
          var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: (parent, name) => {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams: () => {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
        };
        this.setErrno(errno);
        this.message = "FS error";
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    },
    staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS
      };
    },
    init: (input, output, error) => {
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile: (parent, name, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    },
    createDevice: (parent, name, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open: (stream) => {
          stream.seekable = false;
        },
        close: (stream) => {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        },
        read: (stream, buffer, offset, length, pos) => {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: (stream, buffer, offset, length, pos) => {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile: (parent, name, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, {
          length: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            }
          },
          chunkSize: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            }
          }
        });
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    varargs: void 0,
    get() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    },
    getStreamFromFD: function(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    }
  };
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
    try {
      var total = 0;
      var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;
      var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;
      var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;
      var dstReadLow = 0, dstReadHigh = 0;
      var dstWriteLow = 0, dstWriteHigh = 0;
      var dstExceptLow = 0, dstExceptHigh = 0;
      var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);
      var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);
      var check = function(fd2, low, high, val) {
        return fd2 < 32 ? low & val : high & val;
      };
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << fd % 32;
        if (!check(fd, allLow, allHigh, mask)) {
          continue;
        }
        var stream = SYSCALLS.getStreamFromFD(fd);
        var flags = SYSCALLS.DEFAULT_POLLMASK;
        if (stream.stream_ops?.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            var tv_sec = readfds ? HEAP32[timeout >> 2] : 0, tv_usec = readfds ? HEAP32[timeout + 8 >> 2] : 0;
            timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }
        if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
          total++;
        }
        if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
          total++;
        }
        if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
          total++;
        }
      }
      if (readfds) {
        HEAP32[readfds >> 2] = dstReadLow;
        HEAP32[readfds + 4 >> 2] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[writefds >> 2] = dstWriteLow;
        HEAP32[writefds + 4 >> 2] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[exceptfds >> 2] = dstExceptLow;
        HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;
      }
      return total;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  function getSocketFromFD(fd) {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  }
  var setErrNo = (value) => {
    HEAP32[___errno_location() >> 2] = value;
    return value;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name: (name) => {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr: (addr) => {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  function getSocketAddress(addrp, addrlen, allowNull) {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  }
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.createStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.createStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5: {
          var arg = SYSCALLS.get();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 6:
        case 7:
          return 0;
        case 16:
        case 8:
          return -28;
        case 9:
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function convertI32PairToI53Checked(lo, hi) {
    return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18 >> 0] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17 >> 0] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = SYSCALLS.get();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17 >> 0]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = SYSCALLS.get();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = SYSCALLS.get();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function readI53FromI64(ptr) {
    return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  }
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var nowIsMonotonic = true;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      return date.getTime() / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      if (Module["onExit"])
        Module["onExit"](code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var stringToNewUTF8 = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = _malloc(size);
    if (ret)
      stringToUTF8(str, ret, size);
    return ret;
  };
  var __tzset_js = (timezone, daylight, tzname) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    function extractZone(date) {
      var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
      return match ? match[1] : "GMT";
    }
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    var winterNamePtr = stringToNewUTF8(winterName);
    var summerNamePtr = stringToNewUTF8(summerName);
    if (summerOffset < winterOffset) {
      HEAPU32[tzname >> 2] = winterNamePtr;
      HEAPU32[tzname + 4 >> 2] = summerNamePtr;
    } else {
      HEAPU32[tzname >> 2] = summerNamePtr;
      HEAPU32[tzname + 4 >> 2] = winterNamePtr;
    }
  };
  var _abort = () => {
    abort("");
  };
  function _emscripten_date_now() {
    return Date.now();
  }
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = size - b.byteLength + 65535 >>> 16;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = function(ms) {
    return Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  };
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    }
    HEAP8[buffer >> 0] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf >> 0] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_sync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep(function(wakeUp) {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, function(err2) {
          if (err2) {
            wakeUp(function() {
              return 29;
            });
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var getHostByName = (name) => {
    var ret = _malloc(20);
    var nameBuf = stringToNewUTF8(name);
    HEAPU32[ret >> 2] = nameBuf;
    var aliasesBuf = _malloc(4);
    HEAPU32[aliasesBuf >> 2] = 0;
    HEAPU32[ret + 4 >> 2] = aliasesBuf;
    var afinet = 2;
    HEAP32[ret + 8 >> 2] = afinet;
    HEAP32[ret + 12 >> 2] = 4;
    var addrListBuf = _malloc(12);
    HEAPU32[addrListBuf >> 2] = addrListBuf + 8;
    HEAPU32[addrListBuf + 4 >> 2] = 0;
    HEAP32[addrListBuf + 8 >> 2] = inetPton4(DNS.lookup_name(name));
    HEAPU32[ret + 16 >> 2] = addrListBuf;
    return ret;
  };
  var _gethostbyaddr = (addr, addrlen, type) => {
    if (type !== 2) {
      setErrNo(5);
      return null;
    }
    addr = HEAP32[addr >> 2];
    var host = inetNtop4(addr);
    var lookup3 = DNS.lookup_addr(host);
    if (lookup3) {
      host = lookup3;
    }
    return getHostByName(host);
  };
  var _gethostbyname = (name) => getHostByName(UTF8ToString(name));
  var _gethostbyname_r = (name, ret, buf, buflen, out2, err2) => {
    var data = _gethostbyname(name);
    _memcpy(ret, data, 20);
    _free(data);
    HEAP32[err2 >> 2] = 0;
    HEAPU32[out2 >> 2] = ret;
    return 0;
  };
  var _getloadavg = (loadavg, nelem) => {
    var limit = Math.min(nelem, 3);
    var doubleSize = 8;
    for (var i = 0; i < limit; i++) {
      HEAPF64[loadavg + i * doubleSize >> 3] = 0.1;
    }
    return limit;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitWsEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "error");
    },
    awaitWsEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command) {
      if (Module["spawnProcess"]) {
        const spawned = Module["spawnProcess"](command);
        if (!spawned || !spawned.on) {
          throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
        }
        return spawned;
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, [], {
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(procopenCallId) {
    if (!PHPWASM.input_devices) {
      PHPWASM.input_devices = {};
    }
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + procopenCallId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[procopenCallId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    var returnCode;
    var stream;
    try {
      stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      returnCode = 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      returnCode = e.errno;
    }
    if (returnCode === 6 && stream?.fd in PHPWASM.proc_fds) {
      return Asyncify.handleSleep(function(wakeUp) {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            var num2 = doReadv(stream2, iov, iovcnt);
            HEAPU32[pnum >> 2] = num2;
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          if (returnCode2 !== 6 || ++retries > maxRetries || !(stream2?.fd in PHPWASM.proc_fds) || PHPWASM.proc_fds[stream2?.fd]?.exited || FS.isClosed(stream2) || !(PHPWASM.proc_fds[fd]?.stdinFd in (PHPWASM.input_devices || {}))) {
            wakeUp(returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    }
    return returnCode;
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(0);
        });
      });
    }
  }
  function _js_open_process(command, stdinFd, stdoutChildFd, stdoutParentFd, stderrChildFd, stderrParentFd) {
    if (!PHPWASM.proc_fds) {
      PHPWASM.proc_fds = {};
    }
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let cp;
    try {
      cp = PHPWASM.spawnProcess(cmdstr);
    } catch (e) {
      if (e.code === "SPAWN_UNSUPPORTED") {
        return 1;
      }
      throw e;
    }
    let EventEmitter;
    if (ENVIRONMENT_IS_NODE) {
      EventEmitter = require("events").EventEmitter;
    } else {
      EventEmitter = function() {
        this.listeners = {};
      };
      EventEmitter.prototype.emit = function(eventName, data) {
        if (this.listeners[eventName]) {
          this.listeners[eventName].forEach(function(callback) {
            callback(data);
          });
        }
      };
      EventEmitter.prototype.once = function(eventName, callback) {
        const self2 = this;
        function removedCallback() {
          callback(...arguments);
          self2.removeListener(eventName, removedCallback);
        }
        this.on(eventName, removedCallback);
      };
      EventEmitter.prototype.on = function(eventName, callback) {
        if (!this.listeners[eventName]) {
          this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(callback);
      };
      EventEmitter.prototype.removeListener = function(eventName, callback) {
        const idx = this.listeners[eventName].indexOf(callback);
        if (idx !== -1) {
          this.listeners[eventName].splice(idx, 1);
        }
      };
    }
    PHPWASM.proc_fds[stdoutParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stdoutParentFd].stdinFd = stdinFd;
    PHPWASM.proc_fds[stderrParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stderrParentFd].stdinFd = stdinFd;
    const stdoutStream = SYSCALLS.getStreamFromFD(stdoutChildFd);
    cp.on("exit", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].exited = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      PHPWASM.proc_fds[stderrParentFd].exited = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
    });
    cp.stdout.on("data", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].hasData = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, 0);
    });
    const stderrStream = SYSCALLS.getStreamFromFD(stderrChildFd);
    cp.stderr.on("data", function(data) {
      PHPWASM.proc_fds[stderrParentFd].hasData = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
      stderrStream.stream_ops.write(stderrStream, data, 0, data.length, 0);
    });
    if (PHPWASM.input_devices && stdinFd in PHPWASM.input_devices) {
      PHPWASM.input_devices[stdinFd].onData(function(data) {
        if (!data)
          return;
        const dataStr = new TextDecoder("utf-8").decode(data);
        cp.stdin.write(dataStr);
      });
      return 0;
    }
    const stdinStream = SYSCALLS.getStreamFromFD(stdinFd);
    if (!stdinStream.node) {
      return 0;
    }
    const CHUNK_SIZE = 1024;
    const buffer = Buffer.alloc(CHUNK_SIZE);
    let offset = 0;
    while (true) {
      const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
      if (bytesRead === null || bytesRead === 0) {
        break;
      }
      try {
        cp.stdin.write(buffer.subarray(0, bytesRead));
      } catch (e) {
        console.error(e);
        return 1;
      }
      if (bytesRead < CHUNK_SIZE) {
        break;
      }
      offset += bytesRead;
    }
    return 0;
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep((wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr);
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAP32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": (date2) => getWeekBasedYear(date2),
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "%A": "%a",
      "%B": "%b",
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m\\/%d\\/%y",
      "%e": "%d",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%R": "%H\\:%M",
      "%r": "%I\\:%M\\:%S\\s%p",
      "%T": "%H\\:%M\\:%S",
      "%x": "%m\\/%d\\/(?:%y|%Y)",
      "%X": "%H\\:%M\\:%S"
    };
    for (var matcher in EQUIVALENT_MATCHERS) {
      pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
    }
    var DATE_PATTERNS = {
      "%a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      "%b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      "%C": "\\d\\d",
      "%d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      "%H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      "%I": "\\d(?!\\d)|0\\d|10|11|12",
      "%j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      "%m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      "%M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      "%n": "\\s",
      "%p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      "%S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      "%U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%w": "[0-6]",
      "%y": "\\d\\d",
      "%Y": "\\d\\d\\d\\d",
      "%%": "%",
      "%t": "\\s"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    for (var datePattern in DATE_PATTERNS) {
      pattern = pattern.replace(datePattern, "(" + datePattern + DATE_PATTERNS[datePattern] + ")");
    }
    var capture = [];
    for (var i = pattern.indexOf("%"); i >= 0; i = pattern.indexOf("%")) {
      capture.push(pattern[i + 1]);
      pattern = pattern.replace(new RegExp("\\%" + pattern[i + 1], "g"), "");
    }
    var matches = new RegExp("^" + pattern, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59)
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (PHPWASM.proc_fds && socketd in PHPWASM.proc_fds) {
        const emitter = PHPWASM.proc_fds[socketd];
        if (emitter.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitWsEvent(emitter, "data"));
      } else {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function runAndAbortIfError(func) {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  }
  var Asyncify = {
    instrumentWasmImports: function(imports) {
      var importPatterns = [/^_dlopen_js$/, /^invoke_i$/, /^invoke_ii$/, /^invoke_iii$/, /^invoke_iiii$/, /^invoke_iiiii$/, /^invoke_iiiiii$/, /^invoke_iiiiiii$/, /^invoke_iiiiiiii$/, /^invoke_iiiiiiiiii$/, /^invoke_v$/, /^invoke_vi$/, /^invoke_vii$/, /^invoke_viidii$/, /^invoke_viii$/, /^invoke_viiii$/, /^invoke_viiiii$/, /^invoke_viiiiii$/, /^invoke_viiiiiii$/, /^invoke_viiiiiiiii$/, /^js_open_process$/, /^js_popen_to_file$/, /^js_fd_read$/, /^js_module_onMessage$/, /^wasm_poll_socket$/, /^wasm_shutdown$/, /^fd_sync$/, /^__wasi_fd_sync$/, /^__asyncjs__.*$/, /^emscripten_promise_await$/, /^emscripten_idb_load$/, /^emscripten_idb_store$/, /^emscripten_idb_delete$/, /^emscripten_idb_exists$/, /^emscripten_idb_load_blob$/, /^emscripten_idb_store_blob$/, /^emscripten_sleep$/, /^emscripten_wget_data$/, /^emscripten_scan_registers$/, /^emscripten_lazy_load_code$/, /^_load_secondary_module$/, /^emscripten_fiber_swap$/, /^SDL_Delay$/];
      for (var x in imports) {
        (function(x2) {
          var original = imports[x2];
          var sig = original.sig;
          if (typeof original == "function") {
            var isAsyncifyImport = original.isAsync || importPatterns.some((pattern) => !!x2.match(pattern));
          }
        })(x);
      }
    },
    instrumentWasmExports: function(exports) {
      var ret = {};
      for (var x in exports) {
        (function(x2) {
          var original = exports[x2];
          if (typeof original == "function") {
            ret[x2] = function() {
              Asyncify.exportCallStack.push(x2);
              try {
                return original.apply(null, arguments);
              } finally {
                if (!ABORT) {
                  var y = Asyncify.exportCallStack.pop();
                  assert(y === x2);
                  Asyncify.maybeStopUnwind();
                }
              }
            };
          } else {
            ret[x2] = original;
          }
        })(x);
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId: function(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind: function() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone: function() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData: function() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader: function(ptr, stack, stackSize) {
      HEAP32[ptr >> 2] = stack;
      HEAP32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc: function(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFunc: function(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      var func = Module["asm"][name];
      return func;
    },
    doRewind: function(ptr) {
      var start = Asyncify.getDataRewindFunc(ptr);
      runtimeKeepalivePop();
      return start();
    },
    handleSleep: function(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach((func) => callUserCallback(func));
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync: function(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  function getCFunc(ident) {
    var func = Module["_" + ident];
    return func;
  }
  var ccall = function(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func.apply(null, cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts && opts.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FSNode = function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
    read: {
      get: function() {
        return (this.mode & readMode) === readMode;
      },
      set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }
    },
    write: {
      get: function() {
        return (this.mode & writeMode) === writeMode;
      },
      set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }
    },
    isFolder: {
      get: function() {
        return FS.isDir(this.mode);
      }
    },
    isDevice: {
      get: function() {
        return FS.isChrdev(this.mode);
      }
    }
  });
  FS.FSNode = FSNode;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var wasmImports = {
    k: ___assert_fail,
    Ua: ___call_sighandler,
    Ta: ___syscall__newselect,
    Sa: ___syscall_accept4,
    Ra: ___syscall_bind,
    Qa: ___syscall_chdir,
    S: ___syscall_chmod,
    Pa: ___syscall_connect,
    Oa: ___syscall_dup,
    Na: ___syscall_dup3,
    Ma: ___syscall_faccessat,
    La: ___syscall_fchmod,
    Ka: ___syscall_fchown32,
    R: ___syscall_fchownat,
    n: ___syscall_fcntl64,
    Ja: ___syscall_fstat64,
    _: ___syscall_ftruncate64,
    Ia: ___syscall_getcwd,
    Ha: ___syscall_getdents64,
    Ga: ___syscall_getpeername,
    Fa: ___syscall_getsockname,
    Ea: ___syscall_getsockopt,
    Q: ___syscall_ioctl,
    Da: ___syscall_listen,
    Ca: ___syscall_lstat64,
    Ba: ___syscall_mkdirat,
    Aa: ___syscall_newfstatat,
    x: ___syscall_openat,
    za: ___syscall_pipe,
    ya: ___syscall_poll,
    xa: ___syscall_readlinkat,
    wa: ___syscall_recvfrom,
    va: ___syscall_renameat,
    P: ___syscall_rmdir,
    ua: ___syscall_sendto,
    O: ___syscall_socket,
    ta: ___syscall_stat64,
    sa: ___syscall_statfs64,
    ra: ___syscall_symlink,
    E: ___syscall_unlinkat,
    qa: ___syscall_utimensat,
    la: __emscripten_get_now_is_monotonic,
    ka: __emscripten_throw_longjmp,
    Y: __gmtime_js,
    X: __localtime_js,
    W: __mktime_js,
    V: __mmap_js,
    U: __munmap_js,
    L: __setitimer_js,
    ja: __tzset_js,
    e: _abort,
    C: _emscripten_date_now,
    ia: _emscripten_get_heap_max,
    w: _emscripten_get_now,
    ha: _emscripten_memcpy_big,
    ga: _emscripten_resize_heap,
    K: _emscripten_sleep,
    pa: _environ_get,
    oa: _environ_sizes_get,
    p: _exit,
    t: _fd_close,
    N: _fd_fdstat_get,
    M: _fd_read,
    Z: _fd_seek,
    na: _fd_sync,
    D: _fd_write,
    J: _gethostbyaddr,
    I: _gethostbyname_r,
    fa: _getloadavg,
    ea: _getnameinfo,
    da: _getprotobyname,
    ca: _getprotobynumber,
    i: invoke_i,
    d: invoke_ii,
    b: invoke_iii,
    g: invoke_iiii,
    h: invoke_iiiii,
    u: invoke_iiiiii,
    s: invoke_iiiiiii,
    v: invoke_iiiiiiii,
    B: invoke_iiiiiiiiii,
    f: invoke_v,
    a: invoke_vi,
    c: invoke_vii,
    A: invoke_viidii,
    m: invoke_viii,
    l: invoke_viiii,
    o: invoke_viiiii,
    j: invoke_viiiiii,
    z: invoke_viiiiiiiii,
    H: _js_create_input_device,
    ba: _js_fd_read,
    aa: _js_module_onMessage,
    G: _js_open_process,
    $: _js_popen_to_file,
    ma: _proc_exit,
    F: _strftime,
    T: _strptime,
    r: _wasm_close,
    y: _wasm_poll_socket,
    q: _wasm_setsockopt
  };
  var asm = createWasm();
  var ___wasm_call_ctors = function() {
    return (___wasm_call_ctors = Module["asm"]["Wa"]).apply(null, arguments);
  };
  var _memcpy = function() {
    return (_memcpy = Module["asm"]["Xa"]).apply(null, arguments);
  };
  var _malloc = function() {
    return (_malloc = Module["asm"]["Ya"]).apply(null, arguments);
  };
  var _free = function() {
    return (_free = Module["asm"]["Za"]).apply(null, arguments);
  };
  var setTempRet0 = function() {
    return (setTempRet0 = Module["asm"]["$a"]).apply(null, arguments);
  };
  var ___errno_location = function() {
    return (___errno_location = Module["asm"]["ab"]).apply(null, arguments);
  };
  var _wasm_sleep = Module["_wasm_sleep"] = function() {
    return (_wasm_sleep = Module["_wasm_sleep"] = Module["asm"]["bb"]).apply(null, arguments);
  };
  var _ntohs = function() {
    return (_ntohs = Module["asm"]["cb"]).apply(null, arguments);
  };
  var _htons = function() {
    return (_htons = Module["asm"]["db"]).apply(null, arguments);
  };
  var _htonl = function() {
    return (_htonl = Module["asm"]["htonl"]).apply(null, arguments);
  };
  var _wasm_read = Module["_wasm_read"] = function() {
    return (_wasm_read = Module["_wasm_read"] = Module["asm"]["eb"]).apply(null, arguments);
  };
  var _fflush = Module["_fflush"] = function() {
    return (_fflush = Module["_fflush"] = Module["asm"]["fb"]).apply(null, arguments);
  };
  var _wasm_popen = Module["_wasm_popen"] = function() {
    return (_wasm_popen = Module["_wasm_popen"] = Module["asm"]["gb"]).apply(null, arguments);
  };
  var _wasm_php_exec = Module["_wasm_php_exec"] = function() {
    return (_wasm_php_exec = Module["_wasm_php_exec"] = Module["asm"]["hb"]).apply(null, arguments);
  };
  var _php_pollfd_for = Module["_php_pollfd_for"] = function() {
    return (_php_pollfd_for = Module["_php_pollfd_for"] = Module["asm"]["ib"]).apply(null, arguments);
  };
  var _wasm_select = Module["_wasm_select"] = function() {
    return (_wasm_select = Module["_wasm_select"] = Module["asm"]["jb"]).apply(null, arguments);
  };
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = function() {
    return (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = Module["asm"]["kb"]).apply(null, arguments);
  };
  var _run_cli = Module["_run_cli"] = function() {
    return (_run_cli = Module["_run_cli"] = Module["asm"]["lb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = function() {
    return (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = Module["asm"]["mb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = function() {
    return (_wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = Module["asm"]["nb"]).apply(null, arguments);
  };
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = function() {
    return (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = Module["asm"]["ob"]).apply(null, arguments);
  };
  var _wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = function() {
    return (_wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = Module["asm"]["pb"]).apply(null, arguments);
  };
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = function() {
    return (_wasm_set_query_string = Module["_wasm_set_query_string"] = Module["asm"]["qb"]).apply(null, arguments);
  };
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = function() {
    return (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = Module["asm"]["rb"]).apply(null, arguments);
  };
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = function() {
    return (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = Module["asm"]["sb"]).apply(null, arguments);
  };
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = function() {
    return (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = Module["asm"]["tb"]).apply(null, arguments);
  };
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = function() {
    return (_wasm_set_request_method = Module["_wasm_set_request_method"] = Module["asm"]["ub"]).apply(null, arguments);
  };
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = function() {
    return (_wasm_set_request_host = Module["_wasm_set_request_host"] = Module["asm"]["vb"]).apply(null, arguments);
  };
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = function() {
    return (_wasm_set_content_type = Module["_wasm_set_content_type"] = Module["asm"]["wb"]).apply(null, arguments);
  };
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = function() {
    return (_wasm_set_request_body = Module["_wasm_set_request_body"] = Module["asm"]["xb"]).apply(null, arguments);
  };
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = function() {
    return (_wasm_set_content_length = Module["_wasm_set_content_length"] = Module["asm"]["yb"]).apply(null, arguments);
  };
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = function() {
    return (_wasm_set_cookies = Module["_wasm_set_cookies"] = Module["asm"]["zb"]).apply(null, arguments);
  };
  var _wasm_set_php_code = Module["_wasm_set_php_code"] = function() {
    return (_wasm_set_php_code = Module["_wasm_set_php_code"] = Module["asm"]["Ab"]).apply(null, arguments);
  };
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = function() {
    return (_wasm_set_request_port = Module["_wasm_set_request_port"] = Module["asm"]["Bb"]).apply(null, arguments);
  };
  var _phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = function() {
    return (_phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = Module["asm"]["Cb"]).apply(null, arguments);
  };
  var _phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = function() {
    return (_phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = Module["asm"]["Db"]).apply(null, arguments);
  };
  var _phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = function() {
    return (_phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = Module["asm"]["Eb"]).apply(null, arguments);
  };
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = function() {
    return (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = Module["asm"]["Fb"]).apply(null, arguments);
  };
  var _php_wasm_init = Module["_php_wasm_init"] = function() {
    return (_php_wasm_init = Module["_php_wasm_init"] = Module["asm"]["Gb"]).apply(null, arguments);
  };
  var ___funcs_on_exit = function() {
    return (___funcs_on_exit = Module["asm"]["Hb"]).apply(null, arguments);
  };
  var _emscripten_builtin_memalign = function() {
    return (_emscripten_builtin_memalign = Module["asm"]["Ib"]).apply(null, arguments);
  };
  var __emscripten_timeout = function() {
    return (__emscripten_timeout = Module["asm"]["Jb"]).apply(null, arguments);
  };
  var _setThrew = function() {
    return (_setThrew = Module["asm"]["Kb"]).apply(null, arguments);
  };
  var _emscripten_stack_set_limits = function() {
    return (_emscripten_stack_set_limits = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
  };
  var _emscripten_stack_get_base = function() {
    return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
  };
  var _emscripten_stack_get_end = function() {
    return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
  };
  var stackSave = function() {
    return (stackSave = Module["asm"]["Lb"]).apply(null, arguments);
  };
  var stackRestore = function() {
    return (stackRestore = Module["asm"]["Mb"]).apply(null, arguments);
  };
  var stackAlloc = function() {
    return (stackAlloc = Module["asm"]["Nb"]).apply(null, arguments);
  };
  var dynCall_vi = Module["dynCall_vi"] = function() {
    return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["Ob"]).apply(null, arguments);
  };
  var dynCall_iiii = Module["dynCall_iiii"] = function() {
    return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["Pb"]).apply(null, arguments);
  };
  var dynCall_ii = Module["dynCall_ii"] = function() {
    return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["Qb"]).apply(null, arguments);
  };
  var dynCall_vii = Module["dynCall_vii"] = function() {
    return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["Rb"]).apply(null, arguments);
  };
  var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
    return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["Sb"]).apply(null, arguments);
  };
  var dynCall_iii = Module["dynCall_iii"] = function() {
    return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["Tb"]).apply(null, arguments);
  };
  var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
    return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["Ub"]).apply(null, arguments);
  };
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
    return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["Vb"]).apply(null, arguments);
  };
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
    return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["Wb"]).apply(null, arguments);
  };
  var dynCall_i = Module["dynCall_i"] = function() {
    return (dynCall_i = Module["dynCall_i"] = Module["asm"]["Xb"]).apply(null, arguments);
  };
  var dynCall_viii = Module["dynCall_viii"] = function() {
    return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["Yb"]).apply(null, arguments);
  };
  var dynCall_viiii = Module["dynCall_viiii"] = function() {
    return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["Zb"]).apply(null, arguments);
  };
  var dynCall_v = Module["dynCall_v"] = function() {
    return (dynCall_v = Module["dynCall_v"] = Module["asm"]["_b"]).apply(null, arguments);
  };
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {
    return (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = Module["asm"]["$b"]).apply(null, arguments);
  };
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
    return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["ac"]).apply(null, arguments);
  };
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
    return (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = Module["asm"]["bc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = function() {
    return (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = Module["asm"]["cc"]).apply(null, arguments);
  };
  var dynCall_viidii = Module["dynCall_viidii"] = function() {
    return (dynCall_viidii = Module["dynCall_viidii"] = Module["asm"]["dc"]).apply(null, arguments);
  };
  var _asyncify_start_unwind = function() {
    return (_asyncify_start_unwind = Module["asm"]["ec"]).apply(null, arguments);
  };
  var _asyncify_stop_unwind = function() {
    return (_asyncify_stop_unwind = Module["asm"]["fc"]).apply(null, arguments);
  };
  var _asyncify_start_rewind = function() {
    return (_asyncify_start_rewind = Module["asm"]["gc"]).apply(null, arguments);
  };
  var _asyncify_stop_rewind = function() {
    return (_asyncify_stop_rewind = Module["asm"]["hc"]).apply(null, arguments);
  };
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  Module["FS_unlink"] = FS.unlink;
  Module["ccall"] = ccall;
  Module["UTF8ToString"] = UTF8ToString;
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS"] = FS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  return PHPLoader;
}
var dependencyFilename7, dependenciesTotalSize7;
var init_php_7_2 = __esm({
  "packages/php-wasm/node/public/php_7_2.js"() {
    "use strict";
    dependencyFilename7 = __dirname + "/7_2_34/php_7_2.wasm";
    dependenciesTotalSize7 = 11973830;
  }
});

// packages/php-wasm/node/public/php_7_1.js
var php_7_1_exports = {};
__export(php_7_1_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize8,
  dependencyFilename: () => dependencyFilename8,
  init: () => init8
});
function init8(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = RuntimeName === "WEB";
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
    } else {
      scriptDirectory = __dirname + "/";
    }
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
    Module["inspect"] = () => "[Emscripten Module object]";
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var noExitRuntime = Module["noExitRuntime"] || false;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var wasmTable;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  var runtimeKeepaliveCounter = 0;
  function keepRuntimeAlive() {
    return noExitRuntime || runtimeKeepaliveCounter > 0;
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  function isFileURI(filename) {
    return filename.startsWith("file://");
  }
  var wasmBinaryFile;
  wasmBinaryFile = dependencyFilename8;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
      if (typeof fetch == "function") {
        return fetch(binaryFile, {
          credentials: "same-origin"
        }).then((response) => {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + binaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(() => getBinarySync(binaryFile));
      }
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then((instance) => instance).then(receiver, (reason) => {
      err("failed to asynchronously prepare wasm: " + reason);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err("wasm streaming compile failed: " + reason);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function createWasm() {
    var info = {
      "a": wasmImports
    };
    function receiveInstance(instance, module2) {
      var exports = instance.exports;
      exports = Asyncify.instrumentWasmExports(exports);
      Module["asm"] = exports;
      wasmMemory = Module["asm"]["Ua"];
      updateMemoryViews();
      wasmTable = Module["asm"]["_a"];
      addOnInit(Module["asm"]["Va"]);
      removeRunDependency("wasm-instantiate");
      return exports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        return false;
      }
    }
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi.apply(null, [fp, a1]))(sig);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    },
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH_FS = {
    resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, -1);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        } else {
          result = null;
        }
      } else if (typeof window != "undefined" && typeof window.prompt == "function") {
        result = window.prompt("Input: ");
        if (result !== null) {
          result += "\n";
        }
      } else if (typeof readline == "function") {
        result = readline();
        if (result !== null) {
          result += "\n";
        }
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init: function() {
    },
    shutdown: function() {
    },
    register: function(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char: function(tty) {
        return FS_stdin_getChar();
      },
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets: function(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets: function(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz: function(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
      }
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
        old_node.parent = new_dir;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key in node.contents) {
          if (!node.contents.hasOwnProperty(key)) {
            continue;
          }
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach(function(plugin) {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  }
  function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        if (preFinish)
          preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        if (onload)
          onload();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        if (onerror)
          onerror();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, (byteArray) => processData(byteArray), onerror);
    } else {
      processData(url);
    }
  }
  function FS_modeStringToFlags(str) {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  }
  function FS_getMode(canRead, canWrite) {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  }
  var ERRNO_CODES = {};
  var NODEFS = {
    isWindows: false,
    staticInit: () => {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode: (e) => {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    mount: (mount) => NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0),
    createNode: (parent, name, mode, dev) => {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode: (path) => {
      var stat;
      try {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode = stat.mode | (stat.mode & 292) >> 2;
        }
      } catch (e) {
        if (!e.code)
          throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return stat.mode;
    },
    realPath: (node) => {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join.apply(null, parts);
    },
    flagsForNode: (flags) => {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr: (node) => {
        var path = NODEFS.realPath(node);
        var stat;
        try {
          stat = fs.lstatSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        if (NODEFS.isWindows && !stat.blksize) {
          stat.blksize = 4096;
        }
        if (NODEFS.isWindows && !stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr: (node, attr) => {
        var path = NODEFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      lookup: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod: (parent, name, mode, dev) => {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return node;
      },
      rename: (oldNode, newDir, newName) => {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          fs.renameSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        oldNode.name = newName;
      },
      unlink: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.unlinkSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      rmdir: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.rmdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readdir: (node) => {
        var path = NODEFS.realPath(node);
        try {
          return fs.readdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      symlink: (parent, newName, oldPath) => {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        try {
          fs.symlinkSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readlink: (node) => {
        var path = NODEFS.realPath(node);
        try {
          path = fs.readlinkSync(path);
          path = nodePath.relative(nodePath.resolve(node.mount.opts.root), path);
          return path;
        } catch (e) {
          if (!e.code)
            throw e;
          if (e.code === "UNKNOWN")
            throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      }
    },
    stream_ops: {
      open: (stream) => {
        var path = NODEFS.realPath(stream.node);
        try {
          if (FS.isFile(stream.node.mode)) {
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      close: (stream) => {
        try {
          if (FS.isFile(stream.node.mode) && stream.nfd) {
            fs.closeSync(stream.nfd);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      read: (stream, buffer, offset, length, position) => {
        if (length === 0)
          return 0;
        try {
          return fs.readSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      write: (stream, buffer, offset, length, position) => {
        try {
          return fs.writeSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      llseek: (stream, offset, whence) => {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap: (stream, length, position, prot, flags) => {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName: (parentid, name) => {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode: (parent, name) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode: (parent, name, mode, rdev) => {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode: (node) => {
      FS.hashRemoveNode(node);
    },
    isRoot: (node) => node === node.parent,
    isMountpoint: (node) => !!node.mounted,
    isFile: (mode) => (mode & 61440) === 32768,
    isDir: (mode) => (mode & 61440) === 16384,
    isLink: (mode) => (mode & 61440) === 40960,
    isChrdev: (mode) => (mode & 61440) === 8192,
    isBlkdev: (mode) => (mode & 61440) === 24576,
    isFIFO: (mode) => (mode & 61440) === 4096,
    isSocket: (mode) => (mode & 49152) === 49152,
    flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate: (dir, name) => {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete: (dir, name, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked: (fd) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, {
          object: {
            get() {
              return this.node;
            },
            set(val) {
              this.node = val;
            }
          },
          isRead: {
            get() {
              return (this.flags & 2097155) !== 1;
            }
          },
          isWrite: {
            get() {
              return (this.flags & 2097155) !== 0;
            }
          },
          isAppend: {
            get() {
              return this.flags & 1024;
            }
          },
          flags: {
            get() {
              return this.shared.flags;
            },
            set(val) {
              this.shared.flags = val;
            }
          },
          position: {
            get() {
              return this.shared.position;
            },
            set(val) {
              this.shared.position = val;
            }
          }
        });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream: (fd) => {
      FS.streams[fd] = null;
    },
    chrdev_stream_ops: {
      open: (stream) => {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      },
      llseek: () => {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice: (dev, ops) => {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    },
    syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount: (type, opts, mountpoint) => {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount: (mountpoint) => {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup: (parent, name) => parent.node_ops.lookup(parent, name),
    mknod: (path, mode, dev) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink: (path) => {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat: (path, dontFollow) => {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat: (path) => FS.stat(path, true),
    chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    },
    fchmod: (fd, mode) => {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    },
    fchown: (fd, uid, gid) => {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate: (fd, len) => {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime: (path, atime, mtime) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed: (stream) => stream.fd === null,
    llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read: (stream, buffer, offset, length, position) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write: (stream, buffer, offset, length, position, canOwn) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync: (stream, buffer, offset, length, mmapFlags) => {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    munmap: (stream) => 0,
    ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount: () => {
          var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: (parent, name) => {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams: () => {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
        };
        this.setErrno(errno);
        this.message = "FS error";
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    },
    staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS
      };
    },
    init: (input, output, error) => {
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile: (parent, name, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    },
    createDevice: (parent, name, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open: (stream) => {
          stream.seekable = false;
        },
        close: (stream) => {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        },
        read: (stream, buffer, offset, length, pos) => {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: (stream, buffer, offset, length, pos) => {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile: (parent, name, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, {
          length: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            }
          },
          chunkSize: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            }
          }
        });
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    varargs: void 0,
    get() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    },
    getStreamFromFD: function(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    }
  };
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
    try {
      var total = 0;
      var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;
      var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;
      var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;
      var dstReadLow = 0, dstReadHigh = 0;
      var dstWriteLow = 0, dstWriteHigh = 0;
      var dstExceptLow = 0, dstExceptHigh = 0;
      var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);
      var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);
      var check = function(fd2, low, high, val) {
        return fd2 < 32 ? low & val : high & val;
      };
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << fd % 32;
        if (!check(fd, allLow, allHigh, mask)) {
          continue;
        }
        var stream = SYSCALLS.getStreamFromFD(fd);
        var flags = SYSCALLS.DEFAULT_POLLMASK;
        if (stream.stream_ops?.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            var tv_sec = readfds ? HEAP32[timeout >> 2] : 0, tv_usec = readfds ? HEAP32[timeout + 8 >> 2] : 0;
            timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }
        if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
          total++;
        }
        if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
          total++;
        }
        if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
          total++;
        }
      }
      if (readfds) {
        HEAP32[readfds >> 2] = dstReadLow;
        HEAP32[readfds + 4 >> 2] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[writefds >> 2] = dstWriteLow;
        HEAP32[writefds + 4 >> 2] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[exceptfds >> 2] = dstExceptLow;
        HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;
      }
      return total;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  function getSocketFromFD(fd) {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  }
  var setErrNo = (value) => {
    HEAP32[___errno_location() >> 2] = value;
    return value;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name: (name) => {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr: (addr) => {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  function getSocketAddress(addrp, addrlen, allowNull) {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  }
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.createStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.createStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5: {
          var arg = SYSCALLS.get();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 6:
        case 7:
          return 0;
        case 16:
        case 8:
          return -28;
        case 9:
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function convertI32PairToI53Checked(lo, hi) {
    return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18 >> 0] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17 >> 0] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = SYSCALLS.get();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17 >> 0]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = SYSCALLS.get();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = SYSCALLS.get();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function readI53FromI64(ptr) {
    return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  }
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var nowIsMonotonic = true;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      return date.getTime() / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      if (Module["onExit"])
        Module["onExit"](code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var stringToNewUTF8 = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = _malloc(size);
    if (ret)
      stringToUTF8(str, ret, size);
    return ret;
  };
  var __tzset_js = (timezone, daylight, tzname) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    function extractZone(date) {
      var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
      return match ? match[1] : "GMT";
    }
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    var winterNamePtr = stringToNewUTF8(winterName);
    var summerNamePtr = stringToNewUTF8(summerName);
    if (summerOffset < winterOffset) {
      HEAPU32[tzname >> 2] = winterNamePtr;
      HEAPU32[tzname + 4 >> 2] = summerNamePtr;
    } else {
      HEAPU32[tzname >> 2] = summerNamePtr;
      HEAPU32[tzname + 4 >> 2] = winterNamePtr;
    }
  };
  var _abort = () => {
    abort("");
  };
  function _emscripten_date_now() {
    return Date.now();
  }
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = size - b.byteLength + 65535 >>> 16;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = function(ms) {
    return Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  };
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    }
    HEAP8[buffer >> 0] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf >> 0] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_sync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep(function(wakeUp) {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, function(err2) {
          if (err2) {
            wakeUp(function() {
              return 29;
            });
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var getHostByName = (name) => {
    var ret = _malloc(20);
    var nameBuf = stringToNewUTF8(name);
    HEAPU32[ret >> 2] = nameBuf;
    var aliasesBuf = _malloc(4);
    HEAPU32[aliasesBuf >> 2] = 0;
    HEAPU32[ret + 4 >> 2] = aliasesBuf;
    var afinet = 2;
    HEAP32[ret + 8 >> 2] = afinet;
    HEAP32[ret + 12 >> 2] = 4;
    var addrListBuf = _malloc(12);
    HEAPU32[addrListBuf >> 2] = addrListBuf + 8;
    HEAPU32[addrListBuf + 4 >> 2] = 0;
    HEAP32[addrListBuf + 8 >> 2] = inetPton4(DNS.lookup_name(name));
    HEAPU32[ret + 16 >> 2] = addrListBuf;
    return ret;
  };
  var _gethostbyaddr = (addr, addrlen, type) => {
    if (type !== 2) {
      setErrNo(5);
      return null;
    }
    addr = HEAP32[addr >> 2];
    var host = inetNtop4(addr);
    var lookup3 = DNS.lookup_addr(host);
    if (lookup3) {
      host = lookup3;
    }
    return getHostByName(host);
  };
  var _gethostbyname = (name) => getHostByName(UTF8ToString(name));
  var _gethostbyname_r = (name, ret, buf, buflen, out2, err2) => {
    var data = _gethostbyname(name);
    _memcpy(ret, data, 20);
    _free(data);
    HEAP32[err2 >> 2] = 0;
    HEAPU32[out2 >> 2] = ret;
    return 0;
  };
  var _getloadavg = (loadavg, nelem) => {
    var limit = Math.min(nelem, 3);
    var doubleSize = 8;
    for (var i = 0; i < limit; i++) {
      HEAPF64[loadavg + i * doubleSize >> 3] = 0.1;
    }
    return limit;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitWsEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "error");
    },
    awaitWsEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command) {
      if (Module["spawnProcess"]) {
        const spawned = Module["spawnProcess"](command);
        if (!spawned || !spawned.on) {
          throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
        }
        return spawned;
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, [], {
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(procopenCallId) {
    if (!PHPWASM.input_devices) {
      PHPWASM.input_devices = {};
    }
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + procopenCallId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[procopenCallId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    var returnCode;
    var stream;
    try {
      stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      returnCode = 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      returnCode = e.errno;
    }
    if (returnCode === 6 && stream?.fd in PHPWASM.proc_fds) {
      return Asyncify.handleSleep(function(wakeUp) {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            var num2 = doReadv(stream2, iov, iovcnt);
            HEAPU32[pnum >> 2] = num2;
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          if (returnCode2 !== 6 || ++retries > maxRetries || !(stream2?.fd in PHPWASM.proc_fds) || PHPWASM.proc_fds[stream2?.fd]?.exited || FS.isClosed(stream2) || !(PHPWASM.proc_fds[fd]?.stdinFd in (PHPWASM.input_devices || {}))) {
            wakeUp(returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    }
    return returnCode;
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(0);
        });
      });
    }
  }
  function _js_open_process(command, stdinFd, stdoutChildFd, stdoutParentFd, stderrChildFd, stderrParentFd) {
    if (!PHPWASM.proc_fds) {
      PHPWASM.proc_fds = {};
    }
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let cp;
    try {
      cp = PHPWASM.spawnProcess(cmdstr);
    } catch (e) {
      if (e.code === "SPAWN_UNSUPPORTED") {
        return 1;
      }
      throw e;
    }
    let EventEmitter;
    if (ENVIRONMENT_IS_NODE) {
      EventEmitter = require("events").EventEmitter;
    } else {
      EventEmitter = function() {
        this.listeners = {};
      };
      EventEmitter.prototype.emit = function(eventName, data) {
        if (this.listeners[eventName]) {
          this.listeners[eventName].forEach(function(callback) {
            callback(data);
          });
        }
      };
      EventEmitter.prototype.once = function(eventName, callback) {
        const self2 = this;
        function removedCallback() {
          callback(...arguments);
          self2.removeListener(eventName, removedCallback);
        }
        this.on(eventName, removedCallback);
      };
      EventEmitter.prototype.on = function(eventName, callback) {
        if (!this.listeners[eventName]) {
          this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(callback);
      };
      EventEmitter.prototype.removeListener = function(eventName, callback) {
        const idx = this.listeners[eventName].indexOf(callback);
        if (idx !== -1) {
          this.listeners[eventName].splice(idx, 1);
        }
      };
    }
    PHPWASM.proc_fds[stdoutParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stdoutParentFd].stdinFd = stdinFd;
    PHPWASM.proc_fds[stderrParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stderrParentFd].stdinFd = stdinFd;
    const stdoutStream = SYSCALLS.getStreamFromFD(stdoutChildFd);
    cp.on("exit", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].exited = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      PHPWASM.proc_fds[stderrParentFd].exited = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
    });
    cp.stdout.on("data", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].hasData = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, 0);
    });
    const stderrStream = SYSCALLS.getStreamFromFD(stderrChildFd);
    cp.stderr.on("data", function(data) {
      PHPWASM.proc_fds[stderrParentFd].hasData = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
      stderrStream.stream_ops.write(stderrStream, data, 0, data.length, 0);
    });
    if (PHPWASM.input_devices && stdinFd in PHPWASM.input_devices) {
      PHPWASM.input_devices[stdinFd].onData(function(data) {
        if (!data)
          return;
        const dataStr = new TextDecoder("utf-8").decode(data);
        cp.stdin.write(dataStr);
      });
      return 0;
    }
    const stdinStream = SYSCALLS.getStreamFromFD(stdinFd);
    if (!stdinStream.node) {
      return 0;
    }
    const CHUNK_SIZE = 1024;
    const buffer = Buffer.alloc(CHUNK_SIZE);
    let offset = 0;
    while (true) {
      const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
      if (bytesRead === null || bytesRead === 0) {
        break;
      }
      try {
        cp.stdin.write(buffer.subarray(0, bytesRead));
      } catch (e) {
        console.error(e);
        return 1;
      }
      if (bytesRead < CHUNK_SIZE) {
        break;
      }
      offset += bytesRead;
    }
    return 0;
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep((wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr);
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAP32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": (date2) => getWeekBasedYear(date2),
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "%A": "%a",
      "%B": "%b",
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m\\/%d\\/%y",
      "%e": "%d",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%R": "%H\\:%M",
      "%r": "%I\\:%M\\:%S\\s%p",
      "%T": "%H\\:%M\\:%S",
      "%x": "%m\\/%d\\/(?:%y|%Y)",
      "%X": "%H\\:%M\\:%S"
    };
    for (var matcher in EQUIVALENT_MATCHERS) {
      pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
    }
    var DATE_PATTERNS = {
      "%a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      "%b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      "%C": "\\d\\d",
      "%d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      "%H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      "%I": "\\d(?!\\d)|0\\d|10|11|12",
      "%j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      "%m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      "%M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      "%n": "\\s",
      "%p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      "%S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      "%U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%w": "[0-6]",
      "%y": "\\d\\d",
      "%Y": "\\d\\d\\d\\d",
      "%%": "%",
      "%t": "\\s"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    for (var datePattern in DATE_PATTERNS) {
      pattern = pattern.replace(datePattern, "(" + datePattern + DATE_PATTERNS[datePattern] + ")");
    }
    var capture = [];
    for (var i = pattern.indexOf("%"); i >= 0; i = pattern.indexOf("%")) {
      capture.push(pattern[i + 1]);
      pattern = pattern.replace(new RegExp("\\%" + pattern[i + 1], "g"), "");
    }
    var matches = new RegExp("^" + pattern, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59)
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (PHPWASM.proc_fds && socketd in PHPWASM.proc_fds) {
        const emitter = PHPWASM.proc_fds[socketd];
        if (emitter.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitWsEvent(emitter, "data"));
      } else {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function runAndAbortIfError(func) {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  }
  var Asyncify = {
    instrumentWasmImports: function(imports) {
      var importPatterns = [/^_dlopen_js$/, /^invoke_i$/, /^invoke_ii$/, /^invoke_iii$/, /^invoke_iiii$/, /^invoke_iiiii$/, /^invoke_iiiiii$/, /^invoke_iiiiiii$/, /^invoke_iiiiiiii$/, /^invoke_iiiiiiiiii$/, /^invoke_v$/, /^invoke_vi$/, /^invoke_vii$/, /^invoke_viidii$/, /^invoke_viii$/, /^invoke_viiii$/, /^invoke_viiiii$/, /^invoke_viiiiii$/, /^invoke_viiiiiii$/, /^invoke_viiiiiiiii$/, /^js_open_process$/, /^js_popen_to_file$/, /^js_fd_read$/, /^js_module_onMessage$/, /^wasm_poll_socket$/, /^wasm_shutdown$/, /^fd_sync$/, /^__wasi_fd_sync$/, /^__asyncjs__.*$/, /^emscripten_promise_await$/, /^emscripten_idb_load$/, /^emscripten_idb_store$/, /^emscripten_idb_delete$/, /^emscripten_idb_exists$/, /^emscripten_idb_load_blob$/, /^emscripten_idb_store_blob$/, /^emscripten_sleep$/, /^emscripten_wget_data$/, /^emscripten_scan_registers$/, /^emscripten_lazy_load_code$/, /^_load_secondary_module$/, /^emscripten_fiber_swap$/, /^SDL_Delay$/];
      for (var x in imports) {
        (function(x2) {
          var original = imports[x2];
          var sig = original.sig;
          if (typeof original == "function") {
            var isAsyncifyImport = original.isAsync || importPatterns.some((pattern) => !!x2.match(pattern));
          }
        })(x);
      }
    },
    instrumentWasmExports: function(exports) {
      var ret = {};
      for (var x in exports) {
        (function(x2) {
          var original = exports[x2];
          if (typeof original == "function") {
            ret[x2] = function() {
              Asyncify.exportCallStack.push(x2);
              try {
                return original.apply(null, arguments);
              } finally {
                if (!ABORT) {
                  var y = Asyncify.exportCallStack.pop();
                  assert(y === x2);
                  Asyncify.maybeStopUnwind();
                }
              }
            };
          } else {
            ret[x2] = original;
          }
        })(x);
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId: function(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind: function() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone: function() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData: function() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader: function(ptr, stack, stackSize) {
      HEAP32[ptr >> 2] = stack;
      HEAP32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc: function(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFunc: function(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      var func = Module["asm"][name];
      return func;
    },
    doRewind: function(ptr) {
      var start = Asyncify.getDataRewindFunc(ptr);
      runtimeKeepalivePop();
      return start();
    },
    handleSleep: function(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach((func) => callUserCallback(func));
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync: function(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  function getCFunc(ident) {
    var func = Module["_" + ident];
    return func;
  }
  var ccall = function(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func.apply(null, cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts && opts.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FSNode = function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
    read: {
      get: function() {
        return (this.mode & readMode) === readMode;
      },
      set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }
    },
    write: {
      get: function() {
        return (this.mode & writeMode) === writeMode;
      },
      set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }
    },
    isFolder: {
      get: function() {
        return FS.isDir(this.mode);
      }
    },
    isDevice: {
      get: function() {
        return FS.isChrdev(this.mode);
      }
    }
  });
  FS.FSNode = FSNode;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var wasmImports = {
    k: ___assert_fail,
    Ta: ___call_sighandler,
    Sa: ___syscall__newselect,
    Ra: ___syscall_accept4,
    Qa: ___syscall_bind,
    Pa: ___syscall_chdir,
    R: ___syscall_chmod,
    Oa: ___syscall_connect,
    Na: ___syscall_dup,
    Ma: ___syscall_dup3,
    La: ___syscall_faccessat,
    Ka: ___syscall_fchmod,
    Ja: ___syscall_fchown32,
    Q: ___syscall_fchownat,
    n: ___syscall_fcntl64,
    Ia: ___syscall_fstat64,
    Z: ___syscall_ftruncate64,
    Ha: ___syscall_getcwd,
    Ga: ___syscall_getdents64,
    Fa: ___syscall_getpeername,
    Ea: ___syscall_getsockname,
    Da: ___syscall_getsockopt,
    P: ___syscall_ioctl,
    Ca: ___syscall_listen,
    Ba: ___syscall_lstat64,
    Aa: ___syscall_mkdirat,
    za: ___syscall_newfstatat,
    C: ___syscall_openat,
    ya: ___syscall_pipe,
    xa: ___syscall_poll,
    wa: ___syscall_readlinkat,
    va: ___syscall_recvfrom,
    ua: ___syscall_renameat,
    O: ___syscall_rmdir,
    ta: ___syscall_sendto,
    N: ___syscall_socket,
    sa: ___syscall_stat64,
    ra: ___syscall_statfs64,
    qa: ___syscall_symlink,
    M: ___syscall_unlinkat,
    pa: ___syscall_utimensat,
    ka: __emscripten_get_now_is_monotonic,
    ja: __emscripten_throw_longjmp,
    X: __gmtime_js,
    W: __localtime_js,
    V: __mktime_js,
    U: __mmap_js,
    T: __munmap_js,
    J: __setitimer_js,
    ia: __tzset_js,
    e: _abort,
    A: _emscripten_date_now,
    ha: _emscripten_get_heap_max,
    w: _emscripten_get_now,
    ga: _emscripten_memcpy_big,
    fa: _emscripten_resize_heap,
    I: _emscripten_sleep,
    oa: _environ_get,
    na: _environ_sizes_get,
    p: _exit,
    t: _fd_close,
    L: _fd_fdstat_get,
    K: _fd_read,
    Y: _fd_seek,
    ma: _fd_sync,
    B: _fd_write,
    H: _gethostbyaddr,
    G: _gethostbyname_r,
    ea: _getloadavg,
    da: _getnameinfo,
    ca: _getprotobyname,
    ba: _getprotobynumber,
    i: invoke_i,
    d: invoke_ii,
    b: invoke_iii,
    g: invoke_iiii,
    h: invoke_iiiii,
    v: invoke_iiiiii,
    s: invoke_iiiiiii,
    u: invoke_iiiiiiii,
    z: invoke_iiiiiiiiii,
    f: invoke_v,
    a: invoke_vi,
    c: invoke_vii,
    m: invoke_viii,
    l: invoke_viiii,
    o: invoke_viiiii,
    j: invoke_viiiiii,
    y: invoke_viiiiiiiii,
    F: _js_create_input_device,
    aa: _js_fd_read,
    $: _js_module_onMessage,
    E: _js_open_process,
    _: _js_popen_to_file,
    la: _proc_exit,
    D: _strftime,
    S: _strptime,
    r: _wasm_close,
    x: _wasm_poll_socket,
    q: _wasm_setsockopt
  };
  var asm = createWasm();
  var ___wasm_call_ctors = function() {
    return (___wasm_call_ctors = Module["asm"]["Va"]).apply(null, arguments);
  };
  var _memcpy = function() {
    return (_memcpy = Module["asm"]["Wa"]).apply(null, arguments);
  };
  var _malloc = function() {
    return (_malloc = Module["asm"]["Xa"]).apply(null, arguments);
  };
  var _free = function() {
    return (_free = Module["asm"]["Ya"]).apply(null, arguments);
  };
  var setTempRet0 = function() {
    return (setTempRet0 = Module["asm"]["Za"]).apply(null, arguments);
  };
  var ___errno_location = function() {
    return (___errno_location = Module["asm"]["$a"]).apply(null, arguments);
  };
  var _wasm_sleep = Module["_wasm_sleep"] = function() {
    return (_wasm_sleep = Module["_wasm_sleep"] = Module["asm"]["ab"]).apply(null, arguments);
  };
  var _ntohs = function() {
    return (_ntohs = Module["asm"]["bb"]).apply(null, arguments);
  };
  var _htons = function() {
    return (_htons = Module["asm"]["cb"]).apply(null, arguments);
  };
  var _htonl = function() {
    return (_htonl = Module["asm"]["htonl"]).apply(null, arguments);
  };
  var _wasm_read = Module["_wasm_read"] = function() {
    return (_wasm_read = Module["_wasm_read"] = Module["asm"]["db"]).apply(null, arguments);
  };
  var _fflush = Module["_fflush"] = function() {
    return (_fflush = Module["_fflush"] = Module["asm"]["eb"]).apply(null, arguments);
  };
  var _wasm_popen = Module["_wasm_popen"] = function() {
    return (_wasm_popen = Module["_wasm_popen"] = Module["asm"]["fb"]).apply(null, arguments);
  };
  var _wasm_php_exec = Module["_wasm_php_exec"] = function() {
    return (_wasm_php_exec = Module["_wasm_php_exec"] = Module["asm"]["gb"]).apply(null, arguments);
  };
  var _php_pollfd_for = Module["_php_pollfd_for"] = function() {
    return (_php_pollfd_for = Module["_php_pollfd_for"] = Module["asm"]["hb"]).apply(null, arguments);
  };
  var _wasm_select = Module["_wasm_select"] = function() {
    return (_wasm_select = Module["_wasm_select"] = Module["asm"]["ib"]).apply(null, arguments);
  };
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = function() {
    return (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = Module["asm"]["jb"]).apply(null, arguments);
  };
  var _run_cli = Module["_run_cli"] = function() {
    return (_run_cli = Module["_run_cli"] = Module["asm"]["kb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = function() {
    return (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = Module["asm"]["lb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = function() {
    return (_wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = Module["asm"]["mb"]).apply(null, arguments);
  };
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = function() {
    return (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = Module["asm"]["nb"]).apply(null, arguments);
  };
  var _wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = function() {
    return (_wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = Module["asm"]["ob"]).apply(null, arguments);
  };
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = function() {
    return (_wasm_set_query_string = Module["_wasm_set_query_string"] = Module["asm"]["pb"]).apply(null, arguments);
  };
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = function() {
    return (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = Module["asm"]["qb"]).apply(null, arguments);
  };
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = function() {
    return (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = Module["asm"]["rb"]).apply(null, arguments);
  };
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = function() {
    return (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = Module["asm"]["sb"]).apply(null, arguments);
  };
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = function() {
    return (_wasm_set_request_method = Module["_wasm_set_request_method"] = Module["asm"]["tb"]).apply(null, arguments);
  };
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = function() {
    return (_wasm_set_request_host = Module["_wasm_set_request_host"] = Module["asm"]["ub"]).apply(null, arguments);
  };
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = function() {
    return (_wasm_set_content_type = Module["_wasm_set_content_type"] = Module["asm"]["vb"]).apply(null, arguments);
  };
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = function() {
    return (_wasm_set_request_body = Module["_wasm_set_request_body"] = Module["asm"]["wb"]).apply(null, arguments);
  };
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = function() {
    return (_wasm_set_content_length = Module["_wasm_set_content_length"] = Module["asm"]["xb"]).apply(null, arguments);
  };
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = function() {
    return (_wasm_set_cookies = Module["_wasm_set_cookies"] = Module["asm"]["yb"]).apply(null, arguments);
  };
  var _wasm_set_php_code = Module["_wasm_set_php_code"] = function() {
    return (_wasm_set_php_code = Module["_wasm_set_php_code"] = Module["asm"]["zb"]).apply(null, arguments);
  };
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = function() {
    return (_wasm_set_request_port = Module["_wasm_set_request_port"] = Module["asm"]["Ab"]).apply(null, arguments);
  };
  var _phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = function() {
    return (_phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = Module["asm"]["Bb"]).apply(null, arguments);
  };
  var _phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = function() {
    return (_phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = Module["asm"]["Cb"]).apply(null, arguments);
  };
  var _phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = function() {
    return (_phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = Module["asm"]["Db"]).apply(null, arguments);
  };
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = function() {
    return (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = Module["asm"]["Eb"]).apply(null, arguments);
  };
  var _php_wasm_init = Module["_php_wasm_init"] = function() {
    return (_php_wasm_init = Module["_php_wasm_init"] = Module["asm"]["Fb"]).apply(null, arguments);
  };
  var ___funcs_on_exit = function() {
    return (___funcs_on_exit = Module["asm"]["Gb"]).apply(null, arguments);
  };
  var _emscripten_builtin_memalign = function() {
    return (_emscripten_builtin_memalign = Module["asm"]["Hb"]).apply(null, arguments);
  };
  var __emscripten_timeout = function() {
    return (__emscripten_timeout = Module["asm"]["Ib"]).apply(null, arguments);
  };
  var _setThrew = function() {
    return (_setThrew = Module["asm"]["Jb"]).apply(null, arguments);
  };
  var _emscripten_stack_set_limits = function() {
    return (_emscripten_stack_set_limits = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
  };
  var _emscripten_stack_get_base = function() {
    return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
  };
  var _emscripten_stack_get_end = function() {
    return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
  };
  var stackSave = function() {
    return (stackSave = Module["asm"]["Kb"]).apply(null, arguments);
  };
  var stackRestore = function() {
    return (stackRestore = Module["asm"]["Lb"]).apply(null, arguments);
  };
  var stackAlloc = function() {
    return (stackAlloc = Module["asm"]["Mb"]).apply(null, arguments);
  };
  var dynCall_viii = Module["dynCall_viii"] = function() {
    return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["Nb"]).apply(null, arguments);
  };
  var dynCall_vii = Module["dynCall_vii"] = function() {
    return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["Ob"]).apply(null, arguments);
  };
  var dynCall_vi = Module["dynCall_vi"] = function() {
    return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["Pb"]).apply(null, arguments);
  };
  var dynCall_iii = Module["dynCall_iii"] = function() {
    return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["Qb"]).apply(null, arguments);
  };
  var dynCall_ii = Module["dynCall_ii"] = function() {
    return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["Rb"]).apply(null, arguments);
  };
  var dynCall_v = Module["dynCall_v"] = function() {
    return (dynCall_v = Module["dynCall_v"] = Module["asm"]["Sb"]).apply(null, arguments);
  };
  var dynCall_iiii = Module["dynCall_iiii"] = function() {
    return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["Tb"]).apply(null, arguments);
  };
  var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
    return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["Ub"]).apply(null, arguments);
  };
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
    return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["Vb"]).apply(null, arguments);
  };
  var dynCall_viiii = Module["dynCall_viiii"] = function() {
    return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["Wb"]).apply(null, arguments);
  };
  var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
    return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["Xb"]).apply(null, arguments);
  };
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
    return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["Yb"]).apply(null, arguments);
  };
  var dynCall_i = Module["dynCall_i"] = function() {
    return (dynCall_i = Module["dynCall_i"] = Module["asm"]["Zb"]).apply(null, arguments);
  };
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {
    return (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = Module["asm"]["_b"]).apply(null, arguments);
  };
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
    return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["$b"]).apply(null, arguments);
  };
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
    return (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = Module["asm"]["ac"]).apply(null, arguments);
  };
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = function() {
    return (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = Module["asm"]["bc"]).apply(null, arguments);
  };
  var _asyncify_start_unwind = function() {
    return (_asyncify_start_unwind = Module["asm"]["cc"]).apply(null, arguments);
  };
  var _asyncify_stop_unwind = function() {
    return (_asyncify_stop_unwind = Module["asm"]["dc"]).apply(null, arguments);
  };
  var _asyncify_start_rewind = function() {
    return (_asyncify_start_rewind = Module["asm"]["ec"]).apply(null, arguments);
  };
  var _asyncify_stop_rewind = function() {
    return (_asyncify_stop_rewind = Module["asm"]["fc"]).apply(null, arguments);
  };
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  Module["FS_unlink"] = FS.unlink;
  Module["ccall"] = ccall;
  Module["UTF8ToString"] = UTF8ToString;
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS"] = FS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  return PHPLoader;
}
var dependencyFilename8, dependenciesTotalSize8;
var init_php_7_1 = __esm({
  "packages/php-wasm/node/public/php_7_1.js"() {
    "use strict";
    dependencyFilename8 = __dirname + "/7_1_30/php_7_1.wasm";
    dependenciesTotalSize8 = 11590138;
  }
});

// packages/php-wasm/node/public/php_7_0.js
var php_7_0_exports = {};
__export(php_7_0_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize9,
  dependencyFilename: () => dependencyFilename9,
  init: () => init9
});
function init9(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = RuntimeName === "WEB";
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
    } else {
      scriptDirectory = __dirname + "/";
    }
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
    Module["inspect"] = () => "[Emscripten Module object]";
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var noExitRuntime = Module["noExitRuntime"] || false;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var wasmTable;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  var runtimeKeepaliveCounter = 0;
  function keepRuntimeAlive() {
    return noExitRuntime || runtimeKeepaliveCounter > 0;
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  function isFileURI(filename) {
    return filename.startsWith("file://");
  }
  var wasmBinaryFile;
  wasmBinaryFile = dependencyFilename9;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
      if (typeof fetch == "function") {
        return fetch(binaryFile, {
          credentials: "same-origin"
        }).then((response) => {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + binaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(() => getBinarySync(binaryFile));
      }
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then((instance) => instance).then(receiver, (reason) => {
      err("failed to asynchronously prepare wasm: " + reason);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err("wasm streaming compile failed: " + reason);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function createWasm() {
    var info = {
      "a": wasmImports
    };
    function receiveInstance(instance, module2) {
      var exports = instance.exports;
      exports = Asyncify.instrumentWasmExports(exports);
      Module["asm"] = exports;
      wasmMemory = Module["asm"]["Ua"];
      updateMemoryViews();
      wasmTable = Module["asm"]["_a"];
      addOnInit(Module["asm"]["Va"]);
      removeRunDependency("wasm-instantiate");
      return exports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        return false;
      }
    }
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi.apply(null, [fp, a1]))(sig);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    },
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH_FS = {
    resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, -1);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        } else {
          result = null;
        }
      } else if (typeof window != "undefined" && typeof window.prompt == "function") {
        result = window.prompt("Input: ");
        if (result !== null) {
          result += "\n";
        }
      } else if (typeof readline == "function") {
        result = readline();
        if (result !== null) {
          result += "\n";
        }
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init: function() {
    },
    shutdown: function() {
    },
    register: function(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync: function(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char: function(tty) {
        return FS_stdin_getChar();
      },
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets: function(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets: function(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz: function(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
      }
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
        old_node.parent = new_dir;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key in node.contents) {
          if (!node.contents.hasOwnProperty(key)) {
            continue;
          }
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach(function(plugin) {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  }
  function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        if (preFinish)
          preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        if (onload)
          onload();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        if (onerror)
          onerror();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, (byteArray) => processData(byteArray), onerror);
    } else {
      processData(url);
    }
  }
  function FS_modeStringToFlags(str) {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  }
  function FS_getMode(canRead, canWrite) {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  }
  var ERRNO_CODES = {};
  var NODEFS = {
    isWindows: false,
    staticInit: () => {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode: (e) => {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    mount: (mount) => NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0),
    createNode: (parent, name, mode, dev) => {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode: (path) => {
      var stat;
      try {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode = stat.mode | (stat.mode & 292) >> 2;
        }
      } catch (e) {
        if (!e.code)
          throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return stat.mode;
    },
    realPath: (node) => {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join.apply(null, parts);
    },
    flagsForNode: (flags) => {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr: (node) => {
        var path = NODEFS.realPath(node);
        var stat;
        try {
          stat = fs.lstatSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        if (NODEFS.isWindows && !stat.blksize) {
          stat.blksize = 4096;
        }
        if (NODEFS.isWindows && !stat.blocks) {
          stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr: (node, attr) => {
        var path = NODEFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      lookup: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod: (parent, name, mode, dev) => {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return node;
      },
      rename: (oldNode, newDir, newName) => {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        try {
          fs.renameSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        oldNode.name = newName;
      },
      unlink: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.unlinkSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      rmdir: (parent, name) => {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        try {
          fs.rmdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readdir: (node) => {
        var path = NODEFS.realPath(node);
        try {
          return fs.readdirSync(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      symlink: (parent, newName, oldPath) => {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        try {
          fs.symlinkSync(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      readlink: (node) => {
        var path = NODEFS.realPath(node);
        try {
          path = fs.readlinkSync(path);
          path = nodePath.relative(nodePath.resolve(node.mount.opts.root), path);
          return path;
        } catch (e) {
          if (!e.code)
            throw e;
          if (e.code === "UNKNOWN")
            throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      }
    },
    stream_ops: {
      open: (stream) => {
        var path = NODEFS.realPath(stream.node);
        try {
          if (FS.isFile(stream.node.mode)) {
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      close: (stream) => {
        try {
          if (FS.isFile(stream.node.mode) && stream.nfd) {
            fs.closeSync(stream.nfd);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      read: (stream, buffer, offset, length, position) => {
        if (length === 0)
          return 0;
        try {
          return fs.readSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      write: (stream, buffer, offset, length, position) => {
        try {
          return fs.writeSync(stream.nfd, Buffer.from(buffer.buffer), offset, length, position);
        } catch (e) {
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
      llseek: (stream, offset, whence) => {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap: (stream, length, position, prot, flags) => {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName: (parentid, name) => {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode: (parent, name) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode: (parent, name, mode, rdev) => {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode: (node) => {
      FS.hashRemoveNode(node);
    },
    isRoot: (node) => node === node.parent,
    isMountpoint: (node) => !!node.mounted,
    isFile: (mode) => (mode & 61440) === 32768,
    isDir: (mode) => (mode & 61440) === 16384,
    isLink: (mode) => (mode & 61440) === 40960,
    isChrdev: (mode) => (mode & 61440) === 8192,
    isBlkdev: (mode) => (mode & 61440) === 24576,
    isFIFO: (mode) => (mode & 61440) === 4096,
    isSocket: (mode) => (mode & 49152) === 49152,
    flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate: (dir, name) => {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete: (dir, name, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked: (fd) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, {
          object: {
            get() {
              return this.node;
            },
            set(val) {
              this.node = val;
            }
          },
          isRead: {
            get() {
              return (this.flags & 2097155) !== 1;
            }
          },
          isWrite: {
            get() {
              return (this.flags & 2097155) !== 0;
            }
          },
          isAppend: {
            get() {
              return this.flags & 1024;
            }
          },
          flags: {
            get() {
              return this.shared.flags;
            },
            set(val) {
              this.shared.flags = val;
            }
          },
          position: {
            get() {
              return this.shared.position;
            },
            set(val) {
              this.shared.position = val;
            }
          }
        });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream: (fd) => {
      FS.streams[fd] = null;
    },
    chrdev_stream_ops: {
      open: (stream) => {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      },
      llseek: () => {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice: (dev, ops) => {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    },
    syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount: (type, opts, mountpoint) => {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount: (mountpoint) => {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup: (parent, name) => parent.node_ops.lookup(parent, name),
    mknod: (path, mode, dev) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink: (path) => {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink: (path) => {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat: (path, dontFollow) => {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat: (path) => FS.stat(path, true),
    chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    },
    fchmod: (fd, mode) => {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    },
    fchown: (fd, uid, gid) => {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate: (fd, len) => {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime: (path, atime, mtime) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed: (stream) => stream.fd === null,
    llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read: (stream, buffer, offset, length, position) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write: (stream, buffer, offset, length, position, canOwn) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync: (stream, buffer, offset, length, mmapFlags) => {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    munmap: (stream) => 0,
    ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir: (path) => {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount: () => {
          var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: (parent, name) => {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams: () => {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
        };
        this.setErrno(errno);
        this.message = "FS error";
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    },
    staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS
      };
    },
    init: (input, output, error) => {
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile: (parent, name, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    },
    createDevice: (parent, name, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open: (stream) => {
          stream.seekable = false;
        },
        close: (stream) => {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        },
        read: (stream, buffer, offset, length, pos) => {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: (stream, buffer, offset, length, pos) => {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile: (parent, name, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, {
          length: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            }
          },
          chunkSize: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            }
          }
        });
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    varargs: void 0,
    get() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    },
    getStreamFromFD: function(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    }
  };
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
    try {
      var total = 0;
      var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;
      var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;
      var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;
      var dstReadLow = 0, dstReadHigh = 0;
      var dstWriteLow = 0, dstWriteHigh = 0;
      var dstExceptLow = 0, dstExceptHigh = 0;
      var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);
      var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);
      var check = function(fd2, low, high, val) {
        return fd2 < 32 ? low & val : high & val;
      };
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << fd % 32;
        if (!check(fd, allLow, allHigh, mask)) {
          continue;
        }
        var stream = SYSCALLS.getStreamFromFD(fd);
        var flags = SYSCALLS.DEFAULT_POLLMASK;
        if (stream.stream_ops?.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            var tv_sec = readfds ? HEAP32[timeout >> 2] : 0, tv_usec = readfds ? HEAP32[timeout + 8 >> 2] : 0;
            timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }
        if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
          total++;
        }
        if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
          total++;
        }
        if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
          total++;
        }
      }
      if (readfds) {
        HEAP32[readfds >> 2] = dstReadLow;
        HEAP32[readfds + 4 >> 2] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[writefds >> 2] = dstWriteLow;
        HEAP32[writefds + 4 >> 2] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[exceptfds >> 2] = dstExceptLow;
        HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;
      }
      return total;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  function getSocketFromFD(fd) {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  }
  var setErrNo = (value) => {
    HEAP32[___errno_location() >> 2] = value;
    return value;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name: (name) => {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr: (addr) => {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  function getSocketAddress(addrp, addrlen, allowNull) {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  }
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.createStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.createStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5: {
          var arg = SYSCALLS.get();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 6:
        case 7:
          return 0;
        case 16:
        case 8:
          return -28;
        case 9:
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function convertI32PairToI53Checked(lo, hi) {
    return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18 >> 0] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17 >> 0] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = SYSCALLS.get();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17 >> 0]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = SYSCALLS.get();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = SYSCALLS.get();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(null, "/", 16384 | 511, 0);
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function readI53FromI64(ptr) {
    return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  }
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var nowIsMonotonic = true;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      return date.getTime() / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      if (Module["onExit"])
        Module["onExit"](code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var stringToNewUTF8 = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = _malloc(size);
    if (ret)
      stringToUTF8(str, ret, size);
    return ret;
  };
  var __tzset_js = (timezone, daylight, tzname) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    function extractZone(date) {
      var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
      return match ? match[1] : "GMT";
    }
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    var winterNamePtr = stringToNewUTF8(winterName);
    var summerNamePtr = stringToNewUTF8(summerName);
    if (summerOffset < winterOffset) {
      HEAPU32[tzname >> 2] = winterNamePtr;
      HEAPU32[tzname + 4 >> 2] = summerNamePtr;
    } else {
      HEAPU32[tzname >> 2] = summerNamePtr;
      HEAPU32[tzname + 4 >> 2] = winterNamePtr;
    }
  };
  var _abort = () => {
    abort("");
  };
  function _emscripten_date_now() {
    return Date.now();
  }
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = size - b.byteLength + 65535 >>> 16;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = function(ms) {
    return Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  };
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    }
    HEAP8[buffer >> 0] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf >> 0] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_sync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep(function(wakeUp) {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, function(err2) {
          if (err2) {
            wakeUp(function() {
              return 29;
            });
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset !== "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var getHostByName = (name) => {
    var ret = _malloc(20);
    var nameBuf = stringToNewUTF8(name);
    HEAPU32[ret >> 2] = nameBuf;
    var aliasesBuf = _malloc(4);
    HEAPU32[aliasesBuf >> 2] = 0;
    HEAPU32[ret + 4 >> 2] = aliasesBuf;
    var afinet = 2;
    HEAP32[ret + 8 >> 2] = afinet;
    HEAP32[ret + 12 >> 2] = 4;
    var addrListBuf = _malloc(12);
    HEAPU32[addrListBuf >> 2] = addrListBuf + 8;
    HEAPU32[addrListBuf + 4 >> 2] = 0;
    HEAP32[addrListBuf + 8 >> 2] = inetPton4(DNS.lookup_name(name));
    HEAPU32[ret + 16 >> 2] = addrListBuf;
    return ret;
  };
  var _gethostbyaddr = (addr, addrlen, type) => {
    if (type !== 2) {
      setErrNo(5);
      return null;
    }
    addr = HEAP32[addr >> 2];
    var host = inetNtop4(addr);
    var lookup3 = DNS.lookup_addr(host);
    if (lookup3) {
      host = lookup3;
    }
    return getHostByName(host);
  };
  var _gethostbyname = (name) => getHostByName(UTF8ToString(name));
  var _gethostbyname_r = (name, ret, buf, buflen, out2, err2) => {
    var data = _gethostbyname(name);
    _memcpy(ret, data, 20);
    _free(data);
    HEAP32[err2 >> 2] = 0;
    HEAPU32[out2 >> 2] = ret;
    return 0;
  };
  var _getloadavg = (loadavg, nelem) => {
    var limit = Math.min(nelem, 3);
    var doubleSize = 8;
    for (var i = 0; i < limit; i++) {
      HEAPF64[loadavg + i * doubleSize >> 3] = 0.1;
    }
    return limit;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitWsEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitWsEvent(ws, "error");
    },
    awaitWsEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command) {
      if (Module["spawnProcess"]) {
        const spawned = Module["spawnProcess"](command);
        if (!spawned || !spawned.on) {
          throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
        }
        return spawned;
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, [], {
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(procopenCallId) {
    if (!PHPWASM.input_devices) {
      PHPWASM.input_devices = {};
    }
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + procopenCallId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[procopenCallId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    var returnCode;
    var stream;
    try {
      stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      returnCode = 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      returnCode = e.errno;
    }
    if (returnCode === 6 && stream?.fd in PHPWASM.proc_fds) {
      return Asyncify.handleSleep(function(wakeUp) {
        var retries = 0;
        var interval = 50;
        var timeout = 5e3;
        var maxRetries = timeout / interval;
        function poll() {
          var returnCode2;
          var stream2;
          try {
            stream2 = SYSCALLS.getStreamFromFD(fd);
            var num2 = doReadv(stream2, iov, iovcnt);
            HEAPU32[pnum >> 2] = num2;
            returnCode2 = 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
              console.error(e);
              throw e;
            }
            returnCode2 = e.errno;
          }
          if (returnCode2 !== 6 || ++retries > maxRetries || !(stream2?.fd in PHPWASM.proc_fds) || PHPWASM.proc_fds[stream2?.fd]?.exited || FS.isClosed(stream2) || !(PHPWASM.proc_fds[fd]?.stdinFd in (PHPWASM.input_devices || {}))) {
            wakeUp(returnCode2);
          } else {
            setTimeout(poll, interval);
          }
        }
        poll();
      });
    }
    return returnCode;
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(0);
        });
      });
    }
  }
  function _js_open_process(command, stdinFd, stdoutChildFd, stdoutParentFd, stderrChildFd, stderrParentFd) {
    if (!PHPWASM.proc_fds) {
      PHPWASM.proc_fds = {};
    }
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let cp;
    try {
      cp = PHPWASM.spawnProcess(cmdstr);
    } catch (e) {
      if (e.code === "SPAWN_UNSUPPORTED") {
        return 1;
      }
      throw e;
    }
    let EventEmitter;
    if (ENVIRONMENT_IS_NODE) {
      EventEmitter = require("events").EventEmitter;
    } else {
      EventEmitter = function() {
        this.listeners = {};
      };
      EventEmitter.prototype.emit = function(eventName, data) {
        if (this.listeners[eventName]) {
          this.listeners[eventName].forEach(function(callback) {
            callback(data);
          });
        }
      };
      EventEmitter.prototype.once = function(eventName, callback) {
        const self2 = this;
        function removedCallback() {
          callback(...arguments);
          self2.removeListener(eventName, removedCallback);
        }
        this.on(eventName, removedCallback);
      };
      EventEmitter.prototype.on = function(eventName, callback) {
        if (!this.listeners[eventName]) {
          this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(callback);
      };
      EventEmitter.prototype.removeListener = function(eventName, callback) {
        const idx = this.listeners[eventName].indexOf(callback);
        if (idx !== -1) {
          this.listeners[eventName].splice(idx, 1);
        }
      };
    }
    PHPWASM.proc_fds[stdoutParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stdoutParentFd].stdinFd = stdinFd;
    PHPWASM.proc_fds[stderrParentFd] = new EventEmitter();
    PHPWASM.proc_fds[stderrParentFd].stdinFd = stdinFd;
    const stdoutStream = SYSCALLS.getStreamFromFD(stdoutChildFd);
    cp.on("exit", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].exited = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      PHPWASM.proc_fds[stderrParentFd].exited = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
    });
    cp.stdout.on("data", function(data) {
      PHPWASM.proc_fds[stdoutParentFd].hasData = true;
      PHPWASM.proc_fds[stdoutParentFd].emit("data");
      stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, 0);
    });
    const stderrStream = SYSCALLS.getStreamFromFD(stderrChildFd);
    cp.stderr.on("data", function(data) {
      PHPWASM.proc_fds[stderrParentFd].hasData = true;
      PHPWASM.proc_fds[stderrParentFd].emit("data");
      stderrStream.stream_ops.write(stderrStream, data, 0, data.length, 0);
    });
    if (PHPWASM.input_devices && stdinFd in PHPWASM.input_devices) {
      PHPWASM.input_devices[stdinFd].onData(function(data) {
        if (!data)
          return;
        const dataStr = new TextDecoder("utf-8").decode(data);
        cp.stdin.write(dataStr);
      });
      return 0;
    }
    const stdinStream = SYSCALLS.getStreamFromFD(stdinFd);
    if (!stdinStream.node) {
      return 0;
    }
    const CHUNK_SIZE = 1024;
    const buffer = Buffer.alloc(CHUNK_SIZE);
    let offset = 0;
    while (true) {
      const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
      if (bytesRead === null || bytesRead === 0) {
        break;
      }
      try {
        cp.stdin.write(buffer.subarray(0, bytesRead));
      } catch (e) {
        console.error(e);
        return 1;
      }
      if (bytesRead < CHUNK_SIZE) {
        break;
      }
      offset += bytesRead;
    }
    return 0;
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep((wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr);
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAP32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": (date2) => getWeekBasedYear(date2),
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "%A": "%a",
      "%B": "%b",
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m\\/%d\\/%y",
      "%e": "%d",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%R": "%H\\:%M",
      "%r": "%I\\:%M\\:%S\\s%p",
      "%T": "%H\\:%M\\:%S",
      "%x": "%m\\/%d\\/(?:%y|%Y)",
      "%X": "%H\\:%M\\:%S"
    };
    for (var matcher in EQUIVALENT_MATCHERS) {
      pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
    }
    var DATE_PATTERNS = {
      "%a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      "%b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      "%C": "\\d\\d",
      "%d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      "%H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      "%I": "\\d(?!\\d)|0\\d|10|11|12",
      "%j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      "%m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      "%M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      "%n": "\\s",
      "%p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      "%S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      "%U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      "%w": "[0-6]",
      "%y": "\\d\\d",
      "%Y": "\\d\\d\\d\\d",
      "%%": "%",
      "%t": "\\s"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    for (var datePattern in DATE_PATTERNS) {
      pattern = pattern.replace(datePattern, "(" + datePattern + DATE_PATTERNS[datePattern] + ")");
    }
    var capture = [];
    for (var i = pattern.indexOf("%"); i >= 0; i = pattern.indexOf("%")) {
      capture.push(pattern[i + 1]);
      pattern = pattern.replace(new RegExp("\\%" + pattern[i + 1], "g"), "");
    }
    var matches = new RegExp("^" + pattern, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59)
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (PHPWASM.proc_fds && socketd in PHPWASM.proc_fds) {
        const emitter = PHPWASM.proc_fds[socketd];
        if (emitter.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitWsEvent(emitter, "data"));
      } else {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function runAndAbortIfError(func) {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  }
  var Asyncify = {
    instrumentWasmImports: function(imports) {
      var importPatterns = [/^_dlopen_js$/, /^invoke_i$/, /^invoke_ii$/, /^invoke_iii$/, /^invoke_iiii$/, /^invoke_iiiii$/, /^invoke_iiiiii$/, /^invoke_iiiiiii$/, /^invoke_iiiiiiii$/, /^invoke_iiiiiiiiii$/, /^invoke_v$/, /^invoke_vi$/, /^invoke_vii$/, /^invoke_viidii$/, /^invoke_viii$/, /^invoke_viiii$/, /^invoke_viiiii$/, /^invoke_viiiiii$/, /^invoke_viiiiiii$/, /^invoke_viiiiiiiii$/, /^js_open_process$/, /^js_popen_to_file$/, /^js_fd_read$/, /^js_module_onMessage$/, /^wasm_poll_socket$/, /^wasm_shutdown$/, /^fd_sync$/, /^__wasi_fd_sync$/, /^__asyncjs__.*$/, /^emscripten_promise_await$/, /^emscripten_idb_load$/, /^emscripten_idb_store$/, /^emscripten_idb_delete$/, /^emscripten_idb_exists$/, /^emscripten_idb_load_blob$/, /^emscripten_idb_store_blob$/, /^emscripten_sleep$/, /^emscripten_wget_data$/, /^emscripten_scan_registers$/, /^emscripten_lazy_load_code$/, /^_load_secondary_module$/, /^emscripten_fiber_swap$/, /^SDL_Delay$/];
      for (var x in imports) {
        (function(x2) {
          var original = imports[x2];
          var sig = original.sig;
          if (typeof original == "function") {
            var isAsyncifyImport = original.isAsync || importPatterns.some((pattern) => !!x2.match(pattern));
          }
        })(x);
      }
    },
    instrumentWasmExports: function(exports) {
      var ret = {};
      for (var x in exports) {
        (function(x2) {
          var original = exports[x2];
          if (typeof original == "function") {
            ret[x2] = function() {
              Asyncify.exportCallStack.push(x2);
              try {
                return original.apply(null, arguments);
              } finally {
                if (!ABORT) {
                  var y = Asyncify.exportCallStack.pop();
                  assert(y === x2);
                  Asyncify.maybeStopUnwind();
                }
              }
            };
          } else {
            ret[x2] = original;
          }
        })(x);
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId: function(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind: function() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone: function() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData: function() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader: function(ptr, stack, stackSize) {
      HEAP32[ptr >> 2] = stack;
      HEAP32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc: function(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFunc: function(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      var func = Module["asm"][name];
      return func;
    },
    doRewind: function(ptr) {
      var start = Asyncify.getDataRewindFunc(ptr);
      runtimeKeepalivePop();
      return start();
    },
    handleSleep: function(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach((func) => callUserCallback(func));
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync: function(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  function getCFunc(ident) {
    var func = Module["_" + ident];
    return func;
  }
  var ccall = function(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func.apply(null, cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts && opts.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FSNode = function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
    read: {
      get: function() {
        return (this.mode & readMode) === readMode;
      },
      set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }
    },
    write: {
      get: function() {
        return (this.mode & writeMode) === writeMode;
      },
      set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }
    },
    isFolder: {
      get: function() {
        return FS.isDir(this.mode);
      }
    },
    isDevice: {
      get: function() {
        return FS.isChrdev(this.mode);
      }
    }
  });
  FS.FSNode = FSNode;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var wasmImports = {
    k: ___assert_fail,
    Ta: ___call_sighandler,
    Sa: ___syscall__newselect,
    Ra: ___syscall_accept4,
    Qa: ___syscall_bind,
    Pa: ___syscall_chdir,
    R: ___syscall_chmod,
    Oa: ___syscall_connect,
    Na: ___syscall_dup,
    Ma: ___syscall_dup3,
    La: ___syscall_faccessat,
    Ka: ___syscall_fchmod,
    Ja: ___syscall_fchown32,
    Q: ___syscall_fchownat,
    m: ___syscall_fcntl64,
    Ia: ___syscall_fstat64,
    Z: ___syscall_ftruncate64,
    Ha: ___syscall_getcwd,
    Ga: ___syscall_getdents64,
    Fa: ___syscall_getpeername,
    Ea: ___syscall_getsockname,
    Da: ___syscall_getsockopt,
    P: ___syscall_ioctl,
    Ca: ___syscall_listen,
    Ba: ___syscall_lstat64,
    Aa: ___syscall_mkdirat,
    za: ___syscall_newfstatat,
    C: ___syscall_openat,
    ya: ___syscall_pipe,
    xa: ___syscall_poll,
    wa: ___syscall_readlinkat,
    va: ___syscall_recvfrom,
    ua: ___syscall_renameat,
    O: ___syscall_rmdir,
    ta: ___syscall_sendto,
    N: ___syscall_socket,
    sa: ___syscall_stat64,
    ra: ___syscall_statfs64,
    qa: ___syscall_symlink,
    M: ___syscall_unlinkat,
    pa: ___syscall_utimensat,
    la: __emscripten_get_now_is_monotonic,
    ka: __emscripten_throw_longjmp,
    X: __gmtime_js,
    W: __localtime_js,
    V: __mktime_js,
    U: __mmap_js,
    T: __munmap_js,
    J: __setitimer_js,
    ja: __tzset_js,
    e: _abort,
    A: _emscripten_date_now,
    ia: _emscripten_get_heap_max,
    w: _emscripten_get_now,
    ha: _emscripten_memcpy_big,
    ga: _emscripten_resize_heap,
    I: _emscripten_sleep,
    oa: _environ_get,
    na: _environ_sizes_get,
    o: _exit,
    s: _fd_close,
    L: _fd_fdstat_get,
    K: _fd_read,
    Y: _fd_seek,
    ma: _fd_sync,
    B: _fd_write,
    H: _gethostbyaddr,
    G: _gethostbyname_r,
    fa: _getloadavg,
    ea: _getnameinfo,
    da: _getprotobyname,
    ca: _getprotobynumber,
    i: invoke_i,
    d: invoke_ii,
    b: invoke_iii,
    g: invoke_iiii,
    h: invoke_iiiii,
    v: invoke_iiiiii,
    u: invoke_iiiiiii,
    t: invoke_iiiiiiii,
    ba: invoke_iiiiiiiii,
    z: invoke_iiiiiiiiii,
    f: invoke_v,
    a: invoke_vi,
    c: invoke_vii,
    l: invoke_viii,
    q: invoke_viiii,
    n: invoke_viiiii,
    j: invoke_viiiiii,
    y: invoke_viiiiiiiii,
    F: _js_create_input_device,
    aa: _js_fd_read,
    $: _js_module_onMessage,
    E: _js_open_process,
    _: _js_popen_to_file,
    D: _strftime,
    S: _strptime,
    p: _wasm_close,
    x: _wasm_poll_socket,
    r: _wasm_setsockopt
  };
  var asm = createWasm();
  var ___wasm_call_ctors = function() {
    return (___wasm_call_ctors = Module["asm"]["Va"]).apply(null, arguments);
  };
  var _memcpy = function() {
    return (_memcpy = Module["asm"]["Wa"]).apply(null, arguments);
  };
  var _malloc = function() {
    return (_malloc = Module["asm"]["Xa"]).apply(null, arguments);
  };
  var _free = function() {
    return (_free = Module["asm"]["Ya"]).apply(null, arguments);
  };
  var setTempRet0 = function() {
    return (setTempRet0 = Module["asm"]["Za"]).apply(null, arguments);
  };
  var ___errno_location = function() {
    return (___errno_location = Module["asm"]["$a"]).apply(null, arguments);
  };
  var _wasm_sleep = Module["_wasm_sleep"] = function() {
    return (_wasm_sleep = Module["_wasm_sleep"] = Module["asm"]["ab"]).apply(null, arguments);
  };
  var _ntohs = function() {
    return (_ntohs = Module["asm"]["bb"]).apply(null, arguments);
  };
  var _htons = function() {
    return (_htons = Module["asm"]["cb"]).apply(null, arguments);
  };
  var _htonl = function() {
    return (_htonl = Module["asm"]["htonl"]).apply(null, arguments);
  };
  var _wasm_read = Module["_wasm_read"] = function() {
    return (_wasm_read = Module["_wasm_read"] = Module["asm"]["db"]).apply(null, arguments);
  };
  var _fflush = Module["_fflush"] = function() {
    return (_fflush = Module["_fflush"] = Module["asm"]["eb"]).apply(null, arguments);
  };
  var _wasm_popen = Module["_wasm_popen"] = function() {
    return (_wasm_popen = Module["_wasm_popen"] = Module["asm"]["fb"]).apply(null, arguments);
  };
  var _wasm_php_exec = Module["_wasm_php_exec"] = function() {
    return (_wasm_php_exec = Module["_wasm_php_exec"] = Module["asm"]["gb"]).apply(null, arguments);
  };
  var _php_pollfd_for = Module["_php_pollfd_for"] = function() {
    return (_php_pollfd_for = Module["_php_pollfd_for"] = Module["asm"]["hb"]).apply(null, arguments);
  };
  var _wasm_select = Module["_wasm_select"] = function() {
    return (_wasm_select = Module["_wasm_select"] = Module["asm"]["ib"]).apply(null, arguments);
  };
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = function() {
    return (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = Module["asm"]["jb"]).apply(null, arguments);
  };
  var _run_cli = Module["_run_cli"] = function() {
    return (_run_cli = Module["_run_cli"] = Module["asm"]["kb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = function() {
    return (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = Module["asm"]["lb"]).apply(null, arguments);
  };
  var _wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = function() {
    return (_wasm_set_phpini_entries = Module["_wasm_set_phpini_entries"] = Module["asm"]["mb"]).apply(null, arguments);
  };
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = function() {
    return (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = Module["asm"]["nb"]).apply(null, arguments);
  };
  var _wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = function() {
    return (_wasm_add_uploaded_file = Module["_wasm_add_uploaded_file"] = Module["asm"]["ob"]).apply(null, arguments);
  };
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = function() {
    return (_wasm_set_query_string = Module["_wasm_set_query_string"] = Module["asm"]["pb"]).apply(null, arguments);
  };
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = function() {
    return (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = Module["asm"]["qb"]).apply(null, arguments);
  };
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = function() {
    return (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = Module["asm"]["rb"]).apply(null, arguments);
  };
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = function() {
    return (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = Module["asm"]["sb"]).apply(null, arguments);
  };
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = function() {
    return (_wasm_set_request_method = Module["_wasm_set_request_method"] = Module["asm"]["tb"]).apply(null, arguments);
  };
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = function() {
    return (_wasm_set_request_host = Module["_wasm_set_request_host"] = Module["asm"]["ub"]).apply(null, arguments);
  };
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = function() {
    return (_wasm_set_content_type = Module["_wasm_set_content_type"] = Module["asm"]["vb"]).apply(null, arguments);
  };
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = function() {
    return (_wasm_set_request_body = Module["_wasm_set_request_body"] = Module["asm"]["wb"]).apply(null, arguments);
  };
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = function() {
    return (_wasm_set_content_length = Module["_wasm_set_content_length"] = Module["asm"]["xb"]).apply(null, arguments);
  };
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = function() {
    return (_wasm_set_cookies = Module["_wasm_set_cookies"] = Module["asm"]["yb"]).apply(null, arguments);
  };
  var _wasm_set_php_code = Module["_wasm_set_php_code"] = function() {
    return (_wasm_set_php_code = Module["_wasm_set_php_code"] = Module["asm"]["zb"]).apply(null, arguments);
  };
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = function() {
    return (_wasm_set_request_port = Module["_wasm_set_request_port"] = Module["asm"]["Ab"]).apply(null, arguments);
  };
  var _phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = function() {
    return (_phpwasm_init_uploaded_files_hash = Module["_phpwasm_init_uploaded_files_hash"] = Module["asm"]["Bb"]).apply(null, arguments);
  };
  var _phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = function() {
    return (_phpwasm_register_uploaded_file = Module["_phpwasm_register_uploaded_file"] = Module["asm"]["Cb"]).apply(null, arguments);
  };
  var _phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = function() {
    return (_phpwasm_destroy_uploaded_files_hash = Module["_phpwasm_destroy_uploaded_files_hash"] = Module["asm"]["Db"]).apply(null, arguments);
  };
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = function() {
    return (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = Module["asm"]["Eb"]).apply(null, arguments);
  };
  var _php_wasm_init = Module["_php_wasm_init"] = function() {
    return (_php_wasm_init = Module["_php_wasm_init"] = Module["asm"]["Fb"]).apply(null, arguments);
  };
  var ___funcs_on_exit = function() {
    return (___funcs_on_exit = Module["asm"]["Gb"]).apply(null, arguments);
  };
  var _emscripten_builtin_memalign = function() {
    return (_emscripten_builtin_memalign = Module["asm"]["Hb"]).apply(null, arguments);
  };
  var __emscripten_timeout = function() {
    return (__emscripten_timeout = Module["asm"]["Ib"]).apply(null, arguments);
  };
  var _setThrew = function() {
    return (_setThrew = Module["asm"]["Jb"]).apply(null, arguments);
  };
  var _emscripten_stack_set_limits = function() {
    return (_emscripten_stack_set_limits = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
  };
  var _emscripten_stack_get_base = function() {
    return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
  };
  var _emscripten_stack_get_end = function() {
    return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
  };
  var stackSave = function() {
    return (stackSave = Module["asm"]["Kb"]).apply(null, arguments);
  };
  var stackRestore = function() {
    return (stackRestore = Module["asm"]["Lb"]).apply(null, arguments);
  };
  var stackAlloc = function() {
    return (stackAlloc = Module["asm"]["Mb"]).apply(null, arguments);
  };
  var dynCall_viii = Module["dynCall_viii"] = function() {
    return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["Nb"]).apply(null, arguments);
  };
  var dynCall_vii = Module["dynCall_vii"] = function() {
    return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["Ob"]).apply(null, arguments);
  };
  var dynCall_vi = Module["dynCall_vi"] = function() {
    return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["Pb"]).apply(null, arguments);
  };
  var dynCall_iii = Module["dynCall_iii"] = function() {
    return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["Qb"]).apply(null, arguments);
  };
  var dynCall_ii = Module["dynCall_ii"] = function() {
    return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["Rb"]).apply(null, arguments);
  };
  var dynCall_v = Module["dynCall_v"] = function() {
    return (dynCall_v = Module["dynCall_v"] = Module["asm"]["Sb"]).apply(null, arguments);
  };
  var dynCall_iiii = Module["dynCall_iiii"] = function() {
    return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["Tb"]).apply(null, arguments);
  };
  var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
    return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["Ub"]).apply(null, arguments);
  };
  var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
    return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["Vb"]).apply(null, arguments);
  };
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
    return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["Wb"]).apply(null, arguments);
  };
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
    return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["Xb"]).apply(null, arguments);
  };
  var dynCall_i = Module["dynCall_i"] = function() {
    return (dynCall_i = Module["dynCall_i"] = Module["asm"]["Yb"]).apply(null, arguments);
  };
  var dynCall_viiii = Module["dynCall_viiii"] = function() {
    return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["Zb"]).apply(null, arguments);
  };
  var dynCall_iiiiiiiii = Module["dynCall_iiiiiiiii"] = function() {
    return (dynCall_iiiiiiiii = Module["dynCall_iiiiiiiii"] = Module["asm"]["_b"]).apply(null, arguments);
  };
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {
    return (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = Module["asm"]["$b"]).apply(null, arguments);
  };
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
    return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["ac"]).apply(null, arguments);
  };
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
    return (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = Module["asm"]["bc"]).apply(null, arguments);
  };
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = function() {
    return (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = Module["asm"]["cc"]).apply(null, arguments);
  };
  var _asyncify_start_unwind = function() {
    return (_asyncify_start_unwind = Module["asm"]["dc"]).apply(null, arguments);
  };
  var _asyncify_stop_unwind = function() {
    return (_asyncify_stop_unwind = Module["asm"]["ec"]).apply(null, arguments);
  };
  var _asyncify_start_rewind = function() {
    return (_asyncify_start_rewind = Module["asm"]["fc"]).apply(null, arguments);
  };
  var _asyncify_stop_rewind = function() {
    return (_asyncify_stop_rewind = Module["asm"]["gc"]).apply(null, arguments);
  };
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  Module["FS_unlink"] = FS.unlink;
  Module["ccall"] = ccall;
  Module["UTF8ToString"] = UTF8ToString;
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS"] = FS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  return PHPLoader;
}
var dependencyFilename9, dependenciesTotalSize9;
var init_php_7_0 = __esm({
  "packages/php-wasm/node/public/php_7_0.js"() {
    "use strict";
    dependencyFilename9 = __dirname + "/7_0_33/php_7_0.wasm";
    dependenciesTotalSize9 = 11389470;
  }
});

// packages/php-wasm/node/src/index.ts
var src_exports = {};
__export(src_exports, {
  NodePHP: () => NodePHP,
  getPHPLoaderModule: () => getPHPLoaderModule,
  withNetworking: () => withNetworking
});
module.exports = __toCommonJS(src_exports);

// packages/php-wasm/node-polyfills/src/lib/blob.ts
if (typeof File === "undefined") {
  class File2 extends Blob {
    constructor(sources, fileName, options) {
      super(sources);
      let date;
      if (options?.lastModified) {
        date = /* @__PURE__ */ new Date();
      }
      if (!date || isNaN(date.getFullYear())) {
        date = /* @__PURE__ */ new Date();
      }
      this.lastModifiedDate = date;
      this.lastModified = date.getMilliseconds();
      this.name = fileName || "";
    }
  }
  global.File = File2;
}
function asPromise(obj) {
  return new Promise(function(resolve, reject) {
    obj.onload = obj.onerror = function(event) {
      obj.onload = obj.onerror = null;
      if (event.type === "load") {
        resolve(obj.result);
      } else {
        reject(new Error("Failed to read the blob/file"));
      }
    };
  });
}
if (typeof Blob.prototype.arrayBuffer === "undefined") {
  Blob.prototype.arrayBuffer = function arrayBuffer() {
    const reader = new FileReader();
    reader.readAsArrayBuffer(this);
    return asPromise(reader);
  };
}
if (typeof Blob.prototype.text === "undefined") {
  Blob.prototype.text = function text() {
    const reader = new FileReader();
    reader.readAsText(this);
    return asPromise(reader);
  };
}
function isByobSupported() {
  const inputBytes = new Uint8Array([1, 2, 3, 4]);
  const file = new File([inputBytes], "test");
  const stream = file.stream();
  try {
    stream.getReader({ mode: "byob" });
    return true;
  } catch (e) {
    return false;
  }
}
if (typeof Blob.prototype.stream === "undefined" || !isByobSupported()) {
  Blob.prototype.stream = function() {
    let position = 0;
    const blob = this;
    return new ReadableStream({
      type: "bytes",
      // 0.5 MB seems like a reasonable chunk size, let's adjust
      // this if needed.
      autoAllocateChunkSize: 512 * 1024,
      async pull(controller) {
        const view = controller.byobRequest.view;
        const chunk = blob.slice(position, position + view.byteLength);
        const buffer = await chunk.arrayBuffer();
        const uint8array = new Uint8Array(buffer);
        new Uint8Array(view.buffer).set(uint8array);
        const bytesRead = uint8array.byteLength;
        controller.byobRequest.respond(bytesRead);
        position += bytesRead;
        if (position >= blob.size) {
          controller.close();
        }
      }
    });
  };
}

// packages/php-wasm/node-polyfills/src/lib/custom-event.ts
if (typeof CustomEvent === "undefined") {
  class CustomEvent2 extends Event {
    constructor(name, options = {}) {
      super(name, options);
      this.detail = options.detail;
    }
    initCustomEvent() {
    }
  }
  globalThis.CustomEvent = CustomEvent2;
}

// packages/php-wasm/universal/src/lib/error-event-polyfill.ts
var kError = Symbol("error");
var kMessage = Symbol("message");
var ErrorEvent2 = class extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param type The name of the event
   * @param options A dictionary object that allows for setting
   *                  attributes via object members of the same name.
   */
  constructor(type, options = {}) {
    super(type);
    this[kError] = options.error === void 0 ? null : options.error;
    this[kMessage] = options.message === void 0 ? "" : options.message;
  }
  static {
    kError, kMessage;
  }
  get error() {
    return this[kError];
  }
  get message() {
    return this[kMessage];
  }
};
Object.defineProperty(ErrorEvent2.prototype, "error", { enumerable: true });
Object.defineProperty(ErrorEvent2.prototype, "message", { enumerable: true });
var ErrorEvent = typeof globalThis.ErrorEvent === "function" ? globalThis.ErrorEvent : ErrorEvent2;

// packages/php-wasm/universal/src/lib/is-exit-code-zero.ts
function isExitCodeZero(e) {
  if (!(e instanceof Error)) {
    return false;
  }
  return "exitCode" in e && e?.exitCode === 0 || e?.name === "ExitStatus" && "status" in e && e.status === 0;
}

// packages/php-wasm/universal/src/lib/wasm-error-reporting.ts
var UnhandledRejectionsTarget = class extends EventTarget {
  constructor() {
    super(...arguments);
    this.listenersCount = 0;
  }
  addEventListener(type, callback) {
    ++this.listenersCount;
    super.addEventListener(type, callback);
  }
  removeEventListener(type, callback) {
    --this.listenersCount;
    super.removeEventListener(type, callback);
  }
  hasListeners() {
    return this.listenersCount > 0;
  }
};
function improveWASMErrorReporting(runtime) {
  runtime.asm = {
    ...runtime.asm
  };
  const target = new UnhandledRejectionsTarget();
  for (const key in runtime.asm) {
    if (typeof runtime.asm[key] == "function") {
      const original = runtime.asm[key];
      runtime.asm[key] = function(...args) {
        try {
          return original(...args);
        } catch (e) {
          if (!(e instanceof Error)) {
            throw e;
          }
          const clearMessage = clarifyErrorMessage(
            e,
            runtime.lastAsyncifyStackSource?.stack
          );
          if (runtime.lastAsyncifyStackSource) {
            e.cause = runtime.lastAsyncifyStackSource;
          }
          if (target.hasListeners()) {
            target.dispatchEvent(
              new ErrorEvent("error", {
                error: e,
                message: clearMessage
              })
            );
            return;
          }
          if (!isExitCodeZero(e)) {
            showCriticalErrorBox(clearMessage);
          }
          throw e;
        }
      };
    }
  }
  return target;
}
var functionsMaybeMissingFromAsyncify = [];
function getFunctionsMaybeMissingFromAsyncify() {
  return functionsMaybeMissingFromAsyncify;
}
function clarifyErrorMessage(crypticError, asyncifyStack) {
  if (crypticError.message === "unreachable") {
    let betterMessage = UNREACHABLE_ERROR;
    if (!asyncifyStack) {
      betterMessage += `

This stack trace is lacking. For a better one initialize 
the PHP runtime with { debug: true }, e.g. PHPNode.load('8.1', { debug: true }).

`;
    }
    functionsMaybeMissingFromAsyncify = extractPHPFunctionsFromStack(
      asyncifyStack || crypticError.stack || ""
    );
    for (const fn of functionsMaybeMissingFromAsyncify) {
      betterMessage += `    * ${fn}
`;
    }
    return betterMessage;
  }
  return crypticError.message;
}
var UNREACHABLE_ERROR = `
"unreachable" WASM instruction executed.

The typical reason is a PHP function missing from the ASYNCIFY_ONLY
list when building PHP.wasm.

You will need to file a new issue in the WordPress Playground repository
and paste this error message there:

https://github.com/WordPress/wordpress-playground/issues/new

If you're a core developer, the typical fix is to:

* Isolate a minimal reproduction of the error
* Add a reproduction of the error to php-asyncify.spec.ts in the WordPress Playground repository
* Run 'npm run fix-asyncify'
* Commit the changes, push to the repo, release updated NPM packages

Below is a list of all the PHP functions found in the stack trace to
help with the minimal reproduction. If they're all already listed in
the Dockerfile, you'll need to trigger this error again with long stack
traces enabled. In node.js, you can do it using the --stack-trace-limit=100
CLI option: 

`;
var redBg = "\x1B[41m";
var bold = "\x1B[1m";
var reset = "\x1B[0m";
var eol = "\x1B[K";
var logged = false;
function showCriticalErrorBox(message) {
  if (logged) {
    return;
  }
  logged = true;
  if (message?.trim().startsWith("Program terminated with exit")) {
    return;
  }
  console.log(`${redBg}
${eol}
${bold}  WASM ERROR${reset}${redBg}`);
  for (const line of message.split("\n")) {
    console.log(`${eol}  ${line} `);
  }
  console.log(`${reset}`);
}
function extractPHPFunctionsFromStack(stack) {
  try {
    const names = stack.split("\n").slice(1).map((line) => {
      const parts = line.trim().substring("at ".length).split(" ");
      return {
        fn: parts.length >= 2 ? parts[0] : "<unknown>",
        isWasm: line.includes("wasm://")
      };
    }).filter(
      ({ fn, isWasm }) => isWasm && !fn.startsWith("dynCall_") && !fn.startsWith("invoke_")
    ).map(({ fn }) => fn);
    return Array.from(new Set(names));
  } catch (err) {
    return [];
  }
}

// packages/php-wasm/util/src/lib/semaphore.ts
var Semaphore = class {
  constructor({ concurrency }) {
    this._running = 0;
    this.concurrency = concurrency;
    this.queue = [];
  }
  get running() {
    return this._running;
  }
  async acquire() {
    while (true) {
      if (this._running >= this.concurrency) {
        await new Promise((resolve) => this.queue.push(resolve));
      } else {
        this._running++;
        let released = false;
        return () => {
          if (released) {
            return;
          }
          released = true;
          this._running--;
          if (this.queue.length > 0) {
            this.queue.shift()();
          }
        };
      }
    }
  }
  async run(fn) {
    const release = await this.acquire();
    try {
      return await fn();
    } finally {
      release();
    }
  }
};

// packages/php-wasm/stream-compression/src/utils/iterable-stream-polyfill.ts
if (!ReadableStream.prototype[Symbol.asyncIterator]) {
  ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
    const reader = this.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          return;
        }
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  };
  ReadableStream.prototype.iterate = // @ts-ignore
  ReadableStream.prototype[Symbol.asyncIterator];
}

// packages/php-wasm/stream-compression/src/zip/decode-remote-zip.ts
var CENTRAL_DIRECTORY_END_SCAN_CHUNK_SIZE = 110 * 1024;
var BATCH_DOWNLOAD_OF_FILES_IF_CLOSER_THAN = 10 * 1024;
var PREFER_RANGES_IF_FILE_LARGER_THAN = 1024 * 1024 * 1;
var fetchSemaphore = new Semaphore({ concurrency: 10 });

// packages/php-wasm/universal/src/lib/php-response.ts
var PHPResponse = class _PHPResponse {
  constructor(httpStatusCode, headers, body, errors = "", exitCode = 0) {
    this.httpStatusCode = httpStatusCode;
    this.headers = headers;
    this.bytes = body;
    this.exitCode = exitCode;
    this.errors = errors;
  }
  static fromRawData(data) {
    return new _PHPResponse(
      data.httpStatusCode,
      data.headers,
      data.bytes,
      data.errors,
      data.exitCode
    );
  }
  toRawData() {
    return {
      headers: this.headers,
      bytes: this.bytes,
      errors: this.errors,
      exitCode: this.exitCode,
      httpStatusCode: this.httpStatusCode
    };
  }
  /**
   * Response body as JSON.
   */
  get json() {
    return JSON.parse(this.text);
  }
  /**
   * Response body as text.
   */
  get text() {
    return new TextDecoder().decode(this.bytes);
  }
};

// packages/php-wasm/universal/src/lib/supported-php-versions.ts
var SupportedPHPVersions = [
  "8.3",
  "8.2",
  "8.1",
  "8.0",
  "7.4",
  "7.3",
  "7.2",
  "7.1",
  "7.0"
];
var LatestSupportedPHPVersion = SupportedPHPVersions[0];

// packages/php-wasm/universal/src/lib/php-browser.ts
var PHPBrowser = class {
  #cookies;
  #config;
  /**
   * @param  server - The PHP server to browse.
   * @param  config - The browser configuration.
   */
  constructor(requestHandler, config = {}) {
    this.requestHandler = requestHandler;
    this.#cookies = {};
    this.#config = {
      handleRedirects: false,
      maxRedirects: 4,
      ...config
    };
  }
  /**
   * Sends the request to the server.
   *
   * When cookies are present in the response, this method stores
   * them and sends them with any subsequent requests.
   *
   * When a redirection is present in the response, this method
   * follows it by discarding a response and sending a subsequent
   * request.
   *
   * @param  request   - The request.
   * @param  redirects - Internal. The number of redirects handled so far.
   * @returns PHPRequestHandler response.
   */
  async request(request, redirects = 0) {
    const response = await this.requestHandler.request({
      ...request,
      headers: {
        ...request.headers,
        cookie: this.serializeCookies()
      }
    });
    if (response.headers["set-cookie"]) {
      this.setCookies(response.headers["set-cookie"]);
    }
    if (this.#config.handleRedirects && response.headers["location"] && redirects < this.#config.maxRedirects) {
      const redirectUrl = new URL(
        response.headers["location"][0],
        this.requestHandler.absoluteUrl
      );
      return this.request(
        {
          url: redirectUrl.toString(),
          method: "GET",
          headers: {}
        },
        redirects + 1
      );
    }
    return response;
  }
  /** @inheritDoc */
  pathToInternalUrl(path) {
    return this.requestHandler.pathToInternalUrl(path);
  }
  /** @inheritDoc */
  internalUrlToPath(internalUrl) {
    return this.requestHandler.internalUrlToPath(internalUrl);
  }
  /** @inheritDoc */
  get absoluteUrl() {
    return this.requestHandler.absoluteUrl;
  }
  /** @inheritDoc */
  get documentRoot() {
    return this.requestHandler.documentRoot;
  }
  setCookies(cookies) {
    for (const cookie of cookies) {
      try {
        if (!cookie.includes("=")) {
          continue;
        }
        const equalsIndex = cookie.indexOf("=");
        const name = cookie.substring(0, equalsIndex);
        const value = cookie.substring(equalsIndex + 1).split(";")[0];
        this.#cookies[name] = value;
      } catch (e) {
        console.error(e);
      }
    }
  }
  serializeCookies() {
    const cookiesArray = [];
    for (const name in this.#cookies) {
      cookiesArray.push(`${name}=${this.#cookies[name]}`);
    }
    return cookiesArray.join("; ");
  }
};

// packages/php-wasm/universal/src/lib/urls.ts
var DEFAULT_BASE_URL = "http://example.com";
function toRelativeUrl(url) {
  return url.toString().substring(url.origin.length);
}
function removePathPrefix(path, prefix) {
  if (!prefix || !path.startsWith(prefix)) {
    return path;
  }
  return path.substring(prefix.length);
}
function ensurePathPrefix(path, prefix) {
  if (!prefix || path.startsWith(prefix)) {
    return path;
  }
  return prefix + path;
}

// packages/php-wasm/universal/src/lib/php-request-handler.ts
var PHPRequestHandler = class {
  #DOCROOT;
  #PROTOCOL;
  #HOSTNAME;
  #PORT;
  #HOST;
  #PATHNAME;
  #ABSOLUTE_URL;
  #semaphore;
  /**
   * @param  php    - The PHP instance.
   * @param  config - Request Handler configuration.
   */
  constructor(php, config = {}) {
    this.#semaphore = new Semaphore({ concurrency: 1 });
    const {
      documentRoot = "/www/",
      absoluteUrl = typeof location === "object" ? location?.href : ""
    } = config;
    this.php = php;
    this.#DOCROOT = documentRoot;
    const url = new URL(absoluteUrl);
    this.#HOSTNAME = url.hostname;
    this.#PORT = url.port ? Number(url.port) : url.protocol === "https:" ? 443 : 80;
    this.#PROTOCOL = (url.protocol || "").replace(":", "");
    const isNonStandardPort = this.#PORT !== 443 && this.#PORT !== 80;
    this.#HOST = [
      this.#HOSTNAME,
      isNonStandardPort ? `:${this.#PORT}` : ""
    ].join("");
    this.#PATHNAME = url.pathname.replace(/\/+$/, "");
    this.#ABSOLUTE_URL = [
      `${this.#PROTOCOL}://`,
      this.#HOST,
      this.#PATHNAME
    ].join("");
  }
  /** @inheritDoc */
  pathToInternalUrl(path) {
    return `${this.absoluteUrl}${path}`;
  }
  /** @inheritDoc */
  internalUrlToPath(internalUrl) {
    const url = new URL(internalUrl);
    if (url.pathname.startsWith(this.#PATHNAME)) {
      url.pathname = url.pathname.slice(this.#PATHNAME.length);
    }
    return toRelativeUrl(url);
  }
  get isRequestRunning() {
    return this.#semaphore.running > 0;
  }
  /** @inheritDoc */
  get absoluteUrl() {
    return this.#ABSOLUTE_URL;
  }
  /** @inheritDoc */
  get documentRoot() {
    return this.#DOCROOT;
  }
  /** @inheritDoc */
  async request(request) {
    const isAbsolute = request.url.startsWith("http://") || request.url.startsWith("https://");
    const requestedUrl = new URL(
      request.url,
      isAbsolute ? void 0 : DEFAULT_BASE_URL
    );
    const normalizedRequestedPath = removePathPrefix(
      requestedUrl.pathname,
      this.#PATHNAME
    );
    const fsPath = `${this.#DOCROOT}${normalizedRequestedPath}`;
    if (seemsLikeAPHPRequestHandlerPath(fsPath)) {
      return await this.#dispatchToPHP(request, requestedUrl);
    }
    return this.#serveStaticFile(fsPath);
  }
  /**
   * Serves a static file from the PHP filesystem.
   *
   * @param  fsPath - Absolute path of the static file to serve.
   * @returns The response.
   */
  #serveStaticFile(fsPath) {
    if (!this.php.fileExists(fsPath)) {
      return new PHPResponse(
        404,
        // Let the service worker know that no static file was found
        // and that it's okay to issue a real fetch() to the server.
        {
          "x-file-type": ["static"]
        },
        new TextEncoder().encode("404 File not found")
      );
    }
    const arrayBuffer = this.php.readFileAsBuffer(fsPath);
    return new PHPResponse(
      200,
      {
        "content-length": [`${arrayBuffer.byteLength}`],
        // @TODO: Infer the content-type from the arrayBuffer instead of the file path.
        //        The code below won't return the correct mime-type if the extension
        //        was tampered with.
        "content-type": [inferMimeType(fsPath)],
        "accept-ranges": ["bytes"],
        "cache-control": ["public, max-age=0"]
      },
      arrayBuffer
    );
  }
  /**
   * Runs the requested PHP file with all the request and $_SERVER
   * superglobals populated.
   *
   * @param  request - The request.
   * @returns The response.
   */
  async #dispatchToPHP(request, requestedUrl) {
    const release = await this.#semaphore.acquire();
    try {
      this.php.addServerGlobalEntry("DOCUMENT_ROOT", this.#DOCROOT);
      this.php.addServerGlobalEntry(
        "HTTPS",
        this.#ABSOLUTE_URL.startsWith("https://") ? "on" : ""
      );
      let preferredMethod = "GET";
      const headers = {
        host: this.#HOST,
        ...normalizeHeaders(request.headers || {})
      };
      const fileInfos = [];
      if (request.files && Object.keys(request.files).length) {
        preferredMethod = "POST";
        for (const key in request.files) {
          const file = request.files[key];
          fileInfos.push({
            key,
            name: file.name,
            type: file.type,
            data: new Uint8Array(await file.arrayBuffer())
          });
        }
        if (headers["content-type"]?.startsWith("multipart/form-data")) {
          request.formData = parseMultipartFormDataString(
            request.body || ""
          );
          headers["content-type"] = "application/x-www-form-urlencoded";
          delete request.body;
        }
      }
      let body;
      if (request.formData !== void 0) {
        preferredMethod = "POST";
        headers["content-type"] = headers["content-type"] || "application/x-www-form-urlencoded";
        body = new URLSearchParams(
          request.formData
        ).toString();
      } else {
        body = request.body;
      }
      let scriptPath;
      try {
        scriptPath = this.#resolvePHPFilePath(requestedUrl.pathname);
      } catch (error) {
        return new PHPResponse(
          404,
          {},
          new TextEncoder().encode("404 File not found")
        );
      }
      return await this.php.run({
        relativeUri: ensurePathPrefix(
          toRelativeUrl(requestedUrl),
          this.#PATHNAME
        ),
        protocol: this.#PROTOCOL,
        method: request.method || preferredMethod,
        body,
        fileInfos,
        scriptPath,
        headers
      });
    } finally {
      release();
    }
  }
  /**
   * Resolve the requested path to the filesystem path of the requested PHP file.
   *
   * Fall back to index.php as if there was a url rewriting rule in place.
   *
   * @param  requestedPath - The requested pathname.
   * @throws {Error} If the requested path doesn't exist.
   * @returns The resolved filesystem path.
   */
  #resolvePHPFilePath(requestedPath) {
    let filePath = removePathPrefix(requestedPath, this.#PATHNAME);
    if (filePath.includes(".php")) {
      filePath = filePath.split(".php")[0] + ".php";
    } else {
      if (!filePath.endsWith("/")) {
        filePath += "/";
      }
      if (!filePath.endsWith("index.php")) {
        filePath += "index.php";
      }
    }
    const resolvedFsPath = `${this.#DOCROOT}${filePath}`;
    if (this.php.fileExists(resolvedFsPath)) {
      return resolvedFsPath;
    }
    if (!this.php.fileExists(`${this.#DOCROOT}/index.php`)) {
      throw new Error(`File not found: ${resolvedFsPath}`);
    }
    return `${this.#DOCROOT}/index.php`;
  }
};
function parseMultipartFormDataString(multipartString) {
  const parsedData = {};
  const boundaryMatch = multipartString.match(/--(.*)\r\n/);
  if (!boundaryMatch) {
    return parsedData;
  }
  const boundary = boundaryMatch[1];
  const parts = multipartString.split(`--${boundary}`);
  parts.shift();
  parts.pop();
  parts.forEach((part) => {
    const headerBodySplit = part.indexOf("\r\n\r\n");
    const headers = part.substring(0, headerBodySplit).trim();
    const body = part.substring(headerBodySplit + 4).trim();
    const nameMatch = headers.match(/name="([^"]+)"/);
    if (nameMatch) {
      const name = nameMatch[1];
      parsedData[name] = body;
    }
  });
  return parsedData;
}
function inferMimeType(path) {
  const extension = path.split(".").pop();
  switch (extension) {
    case "css":
      return "text/css";
    case "js":
      return "application/javascript";
    case "png":
      return "image/png";
    case "jpg":
    case "jpeg":
      return "image/jpeg";
    case "gif":
      return "image/gif";
    case "svg":
      return "image/svg+xml";
    case "woff":
      return "font/woff";
    case "woff2":
      return "font/woff2";
    case "ttf":
      return "font/ttf";
    case "otf":
      return "font/otf";
    case "eot":
      return "font/eot";
    case "ico":
      return "image/x-icon";
    case "html":
      return "text/html";
    case "json":
      return "application/json";
    case "xml":
      return "application/xml";
    case "txt":
    case "md":
      return "text/plain";
    default:
      return "application-octet-stream";
  }
}
function seemsLikeAPHPRequestHandlerPath(path) {
  return seemsLikeAPHPFile(path) || seemsLikeADirectoryRoot(path);
}
function seemsLikeAPHPFile(path) {
  return path.endsWith(".php") || path.includes(".php/");
}
function seemsLikeADirectoryRoot(path) {
  const lastSegment = path.split("/").pop();
  return !lastSegment.includes(".");
}

// packages/php-wasm/universal/src/lib/rethrow-file-system-error.ts
var FileErrorCodes = {
  0: "No error occurred. System call completed successfully.",
  1: "Argument list too long.",
  2: "Permission denied.",
  3: "Address in use.",
  4: "Address not available.",
  5: "Address family not supported.",
  6: "Resource unavailable, or operation would block.",
  7: "Connection already in progress.",
  8: "Bad file descriptor.",
  9: "Bad message.",
  10: "Device or resource busy.",
  11: "Operation canceled.",
  12: "No child processes.",
  13: "Connection aborted.",
  14: "Connection refused.",
  15: "Connection reset.",
  16: "Resource deadlock would occur.",
  17: "Destination address required.",
  18: "Mathematics argument out of domain of function.",
  19: "Reserved.",
  20: "File exists.",
  21: "Bad address.",
  22: "File too large.",
  23: "Host is unreachable.",
  24: "Identifier removed.",
  25: "Illegal byte sequence.",
  26: "Operation in progress.",
  27: "Interrupted function.",
  28: "Invalid argument.",
  29: "I/O error.",
  30: "Socket is connected.",
  31: "There is a directory under that path.",
  32: "Too many levels of symbolic links.",
  33: "File descriptor value too large.",
  34: "Too many links.",
  35: "Message too large.",
  36: "Reserved.",
  37: "Filename too long.",
  38: "Network is down.",
  39: "Connection aborted by network.",
  40: "Network unreachable.",
  41: "Too many files open in system.",
  42: "No buffer space available.",
  43: "No such device.",
  44: "There is no such file or directory OR the parent directory does not exist.",
  45: "Executable file format error.",
  46: "No locks available.",
  47: "Reserved.",
  48: "Not enough space.",
  49: "No message of the desired type.",
  50: "Protocol not available.",
  51: "No space left on device.",
  52: "Function not supported.",
  53: "The socket is not connected.",
  54: "Not a directory or a symbolic link to a directory.",
  55: "Directory not empty.",
  56: "State not recoverable.",
  57: "Not a socket.",
  58: "Not supported, or operation not supported on socket.",
  59: "Inappropriate I/O control operation.",
  60: "No such device or address.",
  61: "Value too large to be stored in data type.",
  62: "Previous owner died.",
  63: "Operation not permitted.",
  64: "Broken pipe.",
  65: "Protocol error.",
  66: "Protocol not supported.",
  67: "Protocol wrong type for socket.",
  68: "Result too large.",
  69: "Read-only file system.",
  70: "Invalid seek.",
  71: "No such process.",
  72: "Reserved.",
  73: "Connection timed out.",
  74: "Text file busy.",
  75: "Cross-device link.",
  76: "Extension: Capabilities insufficient."
};
function getEmscriptenFsError(e) {
  const errno = typeof e === "object" ? e?.errno : null;
  if (errno in FileErrorCodes) {
    return FileErrorCodes[errno];
  }
}
function rethrowFileSystemError(messagePrefix = "") {
  return function catchFileSystemError(target, methodName, descriptor) {
    const method = descriptor.value;
    descriptor.value = function(...args) {
      try {
        return method.apply(this, args);
      } catch (e) {
        const errno = typeof e === "object" ? e?.errno : null;
        if (errno in FileErrorCodes) {
          const errmsg = FileErrorCodes[errno];
          const path = typeof args[0] === "string" ? args[0] : null;
          const formattedPrefix = path !== null ? messagePrefix.replaceAll("{path}", path) : messagePrefix;
          throw new Error(`${formattedPrefix}: ${errmsg}`, {
            cause: e
          });
        }
        throw e;
      }
    };
  };
}

// packages/php-wasm/universal/src/lib/load-php-runtime.ts
var RuntimeId = Symbol("RuntimeId");
var loadedRuntimes = /* @__PURE__ */ new Map();
async function loadPHPRuntime(phpLoaderModule, phpModuleArgs = {}, dataDependenciesModules = []) {
  const [phpReady, resolvePHP, rejectPHP] = makePromise();
  const [depsReady, resolveDeps] = makePromise();
  const PHPRuntime = phpLoaderModule.init(currentJsRuntime, {
    onAbort(reason) {
      rejectPHP(reason);
      resolveDeps();
      console.error(reason);
    },
    ENV: {},
    // Emscripten sometimes prepends a '/' to the path, which
    // breaks vite dev mode. An identity `locateFile` function
    // fixes it.
    locateFile: (path) => path,
    ...phpModuleArgs,
    noInitialRun: true,
    onRuntimeInitialized() {
      if (phpModuleArgs.onRuntimeInitialized) {
        phpModuleArgs.onRuntimeInitialized();
      }
      resolvePHP();
    },
    monitorRunDependencies(nbLeft) {
      if (nbLeft === 0) {
        delete PHPRuntime.monitorRunDependencies;
        resolveDeps();
      }
    }
  });
  await Promise.all(
    dataDependenciesModules.map(
      ({ default: dataModule }) => dataModule(PHPRuntime)
    )
  );
  if (!dataDependenciesModules.length) {
    resolveDeps();
  }
  await depsReady;
  await phpReady;
  const id = loadedRuntimes.size;
  PHPRuntime.originalExit = PHPRuntime._exit;
  PHPRuntime._exit = function(code) {
    loadedRuntimes.delete(id);
    return PHPRuntime.originalExit(code);
  };
  PHPRuntime[RuntimeId] = id;
  loadedRuntimes.set(id, PHPRuntime);
  return id;
}
function getLoadedRuntime(id) {
  return loadedRuntimes.get(id);
}
var currentJsRuntime = function() {
  if (typeof process !== "undefined" && process.release?.name === "node") {
    return "NODE";
  } else if (typeof window !== "undefined") {
    return "WEB";
  } else if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    return "WORKER";
  } else {
    return "NODE";
  }
}();
var makePromise = () => {
  const methods = [];
  const promise = new Promise((resolve, reject) => {
    methods.push(resolve, reject);
  });
  methods.unshift(promise);
  return methods;
};

// packages/php-wasm/universal/src/lib/base-php.ts
var STRING = "string";
var NUMBER = "number";
var __private__dont__use = Symbol("__private__dont__use");
var BasePHP2 = class {
  /**
   * Initializes a PHP runtime.
   *
   * @internal
   * @param  PHPRuntime - Optional. PHP Runtime ID as initialized by loadPHPRuntime.
   * @param  serverOptions - Optional. Options for the PHPRequestHandler. If undefined, no request handler will be initialized.
   */
  constructor(PHPRuntimeId, serverOptions) {
    this.#phpIniOverrides = [];
    this.#webSapiInitialized = false;
    this.#wasmErrorsTarget = null;
    this.#serverEntries = {};
    this.#eventListeners = /* @__PURE__ */ new Map();
    this.#messageListeners = [];
    this.#semaphore = new Semaphore({ concurrency: 1 });
    if (PHPRuntimeId !== void 0) {
      this.initializeRuntime(PHPRuntimeId);
    }
    if (serverOptions) {
      this.requestHandler = new PHPBrowser(
        new PHPRequestHandler(this, serverOptions)
      );
    }
  }
  static {
    __private__dont__use;
  }
  #phpIniOverrides;
  #webSapiInitialized;
  #wasmErrorsTarget;
  #serverEntries;
  #eventListeners;
  #messageListeners;
  #semaphore;
  addEventListener(eventType, listener) {
    if (!this.#eventListeners.has(eventType)) {
      this.#eventListeners.set(eventType, /* @__PURE__ */ new Set());
    }
    this.#eventListeners.get(eventType).add(listener);
  }
  removeEventListener(eventType, listener) {
    this.#eventListeners.get(eventType)?.delete(listener);
  }
  dispatchEvent(event) {
    const listeners = this.#eventListeners.get(event.type);
    if (!listeners) {
      return;
    }
    for (const listener of listeners) {
      listener(event);
    }
  }
  /** @inheritDoc */
  async onMessage(listener) {
    this.#messageListeners.push(listener);
  }
  /** @inheritDoc */
  async setSpawnHandler(handler) {
    this[__private__dont__use].spawnProcess = handler;
  }
  /** @inheritDoc */
  get absoluteUrl() {
    return this.requestHandler.requestHandler.absoluteUrl;
  }
  /** @inheritDoc */
  get documentRoot() {
    return this.requestHandler.requestHandler.documentRoot;
  }
  /** @inheritDoc */
  pathToInternalUrl(path) {
    return this.requestHandler.requestHandler.pathToInternalUrl(path);
  }
  /** @inheritDoc */
  internalUrlToPath(internalUrl) {
    return this.requestHandler.requestHandler.internalUrlToPath(
      internalUrl
    );
  }
  initializeRuntime(runtimeId) {
    if (this[__private__dont__use]) {
      throw new Error("PHP runtime already initialized.");
    }
    const runtime = getLoadedRuntime(runtimeId);
    if (!runtime) {
      throw new Error("Invalid PHP runtime id.");
    }
    this[__private__dont__use] = runtime;
    runtime["onMessage"] = async (data) => {
      for (const listener of this.#messageListeners) {
        const returnData = await listener(data);
        if (returnData) {
          return returnData;
        }
      }
      return "";
    };
    this.#wasmErrorsTarget = improveWASMErrorReporting(runtime);
  }
  /** @inheritDoc */
  setPhpIniPath(path) {
    if (this.#webSapiInitialized) {
      throw new Error("Cannot set PHP ini path after calling run().");
    }
    this[__private__dont__use].ccall(
      "wasm_set_phpini_path",
      null,
      ["string"],
      [path]
    );
  }
  /** @inheritDoc */
  setPhpIniEntry(key, value) {
    if (this.#webSapiInitialized) {
      throw new Error("Cannot set PHP ini entries after calling run().");
    }
    this.#phpIniOverrides.push([key, value]);
  }
  /** @inheritDoc */
  chdir(path) {
    this[__private__dont__use].FS.chdir(path);
  }
  /** @inheritDoc */
  async request(request, maxRedirects) {
    if (!this.requestHandler) {
      throw new Error("No request handler available.");
    }
    return this.requestHandler.request(request, maxRedirects);
  }
  /** @inheritDoc */
  async run(request) {
    const release = await this.#semaphore.acquire();
    try {
      if (!this.#webSapiInitialized) {
        this.#initWebRuntime();
        this.#webSapiInitialized = true;
      }
      this.#setScriptPath(request.scriptPath || "");
      this.#setRelativeRequestUri(request.relativeUri || "");
      this.#setRequestMethod(request.method || "GET");
      const headers = normalizeHeaders(request.headers || {});
      const host = headers["host"] || "example.com:443";
      this.#setRequestHostAndProtocol(host, request.protocol || "http");
      this.#setRequestHeaders(headers);
      if (request.body) {
        this.#setRequestBody(request.body);
      }
      if (request.fileInfos) {
        for (const file of request.fileInfos) {
          this.#addUploadedFile(file);
        }
      }
      if (request.code) {
        this.#setPHPCode(" ?>" + request.code);
      }
      this.#addServerGlobalEntriesInWasm();
      return await this.#handleRequest();
    } finally {
      release();
      this.dispatchEvent({
        type: "request.end"
      });
    }
  }
  #initWebRuntime() {
    this.setPhpIniEntry("auto_prepend_file", "/tmp/consts.php");
    if (!this.fileExists("/tmp/consts.php")) {
      this.writeFile(
        "/tmp/consts.php",
        `<?php
				if(file_exists('/tmp/consts.json')) {
					$consts = json_decode(file_get_contents('/tmp/consts.json'), true);
					foreach ($consts as $const => $value) {
						if (!defined($const) && is_scalar($value)) {
							define($const, $value);
						}
					}
				}`
      );
    }
    if (this.#phpIniOverrides.length > 0) {
      const overridesAsIni = this.#phpIniOverrides.map(([key, value]) => `${key}=${value}`).join("\n") + "\n\n";
      this[__private__dont__use].ccall(
        "wasm_set_phpini_entries",
        null,
        [STRING],
        [overridesAsIni]
      );
    }
    this[__private__dont__use].ccall("php_wasm_init", null, [], []);
  }
  #getResponseHeaders() {
    const headersFilePath = "/tmp/headers.json";
    if (!this.fileExists(headersFilePath)) {
      throw new Error(
        "SAPI Error: Could not find response headers file."
      );
    }
    const headersData = JSON.parse(this.readFileAsText(headersFilePath));
    const headers = {};
    for (const line of headersData.headers) {
      if (!line.includes(": ")) {
        continue;
      }
      const colonIndex = line.indexOf(": ");
      const headerName = line.substring(0, colonIndex).toLowerCase();
      const headerValue = line.substring(colonIndex + 2);
      if (!(headerName in headers)) {
        headers[headerName] = [];
      }
      headers[headerName].push(headerValue);
    }
    return {
      headers,
      httpStatusCode: headersData.status
    };
  }
  #setRelativeRequestUri(uri) {
    this[__private__dont__use].ccall(
      "wasm_set_request_uri",
      null,
      [STRING],
      [uri]
    );
    if (uri.includes("?")) {
      const queryString = uri.substring(uri.indexOf("?") + 1);
      this[__private__dont__use].ccall(
        "wasm_set_query_string",
        null,
        [STRING],
        [queryString]
      );
    }
  }
  #setRequestHostAndProtocol(host, protocol) {
    this[__private__dont__use].ccall(
      "wasm_set_request_host",
      null,
      [STRING],
      [host]
    );
    let port;
    try {
      port = parseInt(new URL(host).port, 10);
    } catch (e) {
    }
    if (!port || isNaN(port) || port === 80) {
      port = protocol === "https" ? 443 : 80;
    }
    this[__private__dont__use].ccall(
      "wasm_set_request_port",
      null,
      [NUMBER],
      [port]
    );
    if (protocol === "https" || !protocol && port === 443) {
      this.addServerGlobalEntry("HTTPS", "on");
    }
  }
  #setRequestMethod(method) {
    this[__private__dont__use].ccall(
      "wasm_set_request_method",
      null,
      [STRING],
      [method]
    );
  }
  #setRequestHeaders(headers) {
    if (headers["cookie"]) {
      this[__private__dont__use].ccall(
        "wasm_set_cookies",
        null,
        [STRING],
        [headers["cookie"]]
      );
    }
    if (headers["content-type"]) {
      this[__private__dont__use].ccall(
        "wasm_set_content_type",
        null,
        [STRING],
        [headers["content-type"]]
      );
    }
    if (headers["content-length"]) {
      this[__private__dont__use].ccall(
        "wasm_set_content_length",
        null,
        [NUMBER],
        [parseInt(headers["content-length"], 10)]
      );
    }
    for (const name in headers) {
      let HTTP_prefix = "HTTP_";
      if (["content-type", "content-length"].includes(name.toLowerCase())) {
        HTTP_prefix = "";
      }
      this.addServerGlobalEntry(
        `${HTTP_prefix}${name.toUpperCase().replace(/-/g, "_")}`,
        headers[name]
      );
    }
  }
  #setRequestBody(body) {
    this[__private__dont__use].ccall(
      "wasm_set_request_body",
      null,
      [STRING],
      [body]
    );
    this[__private__dont__use].ccall(
      "wasm_set_content_length",
      null,
      [NUMBER],
      [new TextEncoder().encode(body).length]
    );
  }
  #setScriptPath(path) {
    this[__private__dont__use].ccall(
      "wasm_set_path_translated",
      null,
      [STRING],
      [path]
    );
  }
  addServerGlobalEntry(key, value) {
    this.#serverEntries[key] = value;
  }
  #addServerGlobalEntriesInWasm() {
    for (const key in this.#serverEntries) {
      this[__private__dont__use].ccall(
        "wasm_add_SERVER_entry",
        null,
        [STRING, STRING],
        [key, this.#serverEntries[key]]
      );
    }
  }
  defineConstant(key, value) {
    let consts = {};
    try {
      consts = JSON.parse(
        this.fileExists("/tmp/consts.json") ? this.readFileAsText("/tmp/consts.json") || "{}" : "{}"
      );
    } catch (e) {
    }
    this.writeFile(
      "/tmp/consts.json",
      JSON.stringify({
        ...consts,
        [key]: value
      })
    );
  }
  /**
   * Adds file information to $_FILES superglobal in PHP.
   *
   * In particular:
   * * Creates the file data in the filesystem
   * * Registers the file details in PHP
   *
   * @param  fileInfo - File details
   */
  #addUploadedFile(fileInfo) {
    const { key, name, type, data } = fileInfo;
    const tmpPath = `/tmp/${Math.random().toFixed(20)}`;
    this.writeFile(tmpPath, data);
    const error = 0;
    this[__private__dont__use].ccall(
      "wasm_add_uploaded_file",
      null,
      [STRING, STRING, STRING, STRING, NUMBER, NUMBER],
      [key, name, type, tmpPath, error, data.byteLength]
    );
  }
  #setPHPCode(code) {
    this[__private__dont__use].ccall(
      "wasm_set_php_code",
      null,
      [STRING],
      [code]
    );
  }
  async #handleRequest() {
    let exitCode;
    let errorListener;
    try {
      exitCode = await new Promise((resolve, reject) => {
        errorListener = (e) => {
          const rethrown = new Error("Rethrown");
          rethrown.cause = e.error;
          rethrown.betterMessage = e.message;
          reject(rethrown);
        };
        this.#wasmErrorsTarget?.addEventListener(
          "error",
          errorListener
        );
        const response = this[__private__dont__use].ccall(
          "wasm_sapi_handle_request",
          NUMBER,
          [],
          [],
          { async: true }
        );
        if (response instanceof Promise) {
          return response.then(resolve, reject);
        }
        return resolve(response);
      });
    } catch (e) {
      for (const name in this) {
        if (typeof this[name] === "function") {
          this[name] = () => {
            throw new Error(
              `PHP runtime has crashed \u2013 see the earlier error for details.`
            );
          };
        }
      }
      this.functionsMaybeMissingFromAsyncify = getFunctionsMaybeMissingFromAsyncify();
      const err = e;
      const message = "betterMessage" in err ? err.betterMessage : err.message;
      const rethrown = new Error(message);
      rethrown.cause = err;
      throw rethrown;
    } finally {
      this.#wasmErrorsTarget?.removeEventListener("error", errorListener);
      this.#serverEntries = {};
    }
    const { headers, httpStatusCode } = this.#getResponseHeaders();
    return new PHPResponse(
      httpStatusCode,
      headers,
      this.readFileAsBuffer("/tmp/stdout"),
      this.readFileAsText("/tmp/stderr"),
      exitCode
    );
  }
  mkdir(path) {
    this[__private__dont__use].FS.mkdirTree(path);
  }
  mkdirTree(path) {
    this.mkdir(path);
  }
  readFileAsText(path) {
    return new TextDecoder().decode(this.readFileAsBuffer(path));
  }
  readFileAsBuffer(path) {
    return this[__private__dont__use].FS.readFile(path);
  }
  writeFile(path, data) {
    this[__private__dont__use].FS.writeFile(path, data);
  }
  unlink(path) {
    this[__private__dont__use].FS.unlink(path);
  }
  /** @inheritDoc */
  mv(fromPath, toPath) {
    try {
      this[__private__dont__use].FS.rename(fromPath, toPath);
    } catch (e) {
      const errmsg = getEmscriptenFsError(e);
      if (!errmsg) {
        throw e;
      }
      throw new Error(
        `Could not move ${fromPath} to ${toPath}: ${errmsg}`,
        {
          cause: e
        }
      );
    }
  }
  rmdir(path, options = { recursive: true }) {
    if (options?.recursive) {
      this.listFiles(path).forEach((file) => {
        const filePath = `${path}/${file}`;
        if (this.isDir(filePath)) {
          this.rmdir(filePath, options);
        } else {
          this.unlink(filePath);
        }
      });
    }
    this[__private__dont__use].FS.rmdir(path);
  }
  listFiles(path, options = { prependPath: false }) {
    if (!this.fileExists(path)) {
      return [];
    }
    try {
      const files = this[__private__dont__use].FS.readdir(path).filter(
        (name) => name !== "." && name !== ".."
      );
      if (options.prependPath) {
        const prepend = path.replace(/\/$/, "");
        return files.map((name) => `${prepend}/${name}`);
      }
      return files;
    } catch (e) {
      console.error(e, { path });
      return [];
    }
  }
  isDir(path) {
    if (!this.fileExists(path)) {
      return false;
    }
    return this[__private__dont__use].FS.isDir(
      this[__private__dont__use].FS.lookupPath(path).node.mode
    );
  }
  fileExists(path) {
    try {
      this[__private__dont__use].FS.lookupPath(path);
      return true;
    } catch (e) {
      return false;
    }
  }
  exit(code = 0) {
    return this[__private__dont__use]._exit(code);
  }
};
__decorateClass([
  rethrowFileSystemError('Could not create directory "{path}"')
], BasePHP2.prototype, "mkdir", 1);
__decorateClass([
  rethrowFileSystemError('Could not create directory "{path}"')
], BasePHP2.prototype, "mkdirTree", 1);
__decorateClass([
  rethrowFileSystemError('Could not read "{path}"')
], BasePHP2.prototype, "readFileAsText", 1);
__decorateClass([
  rethrowFileSystemError('Could not read "{path}"')
], BasePHP2.prototype, "readFileAsBuffer", 1);
__decorateClass([
  rethrowFileSystemError('Could not write to "{path}"')
], BasePHP2.prototype, "writeFile", 1);
__decorateClass([
  rethrowFileSystemError('Could not unlink "{path}"')
], BasePHP2.prototype, "unlink", 1);
__decorateClass([
  rethrowFileSystemError('Could not remove directory "{path}"')
], BasePHP2.prototype, "rmdir", 1);
__decorateClass([
  rethrowFileSystemError('Could not list files in "{path}"')
], BasePHP2.prototype, "listFiles", 1);
__decorateClass([
  rethrowFileSystemError('Could not stat "{path}"')
], BasePHP2.prototype, "isDir", 1);
__decorateClass([
  rethrowFileSystemError('Could not stat "{path}"')
], BasePHP2.prototype, "fileExists", 1);
function normalizeHeaders(headers) {
  const normalized = {};
  for (const key in headers) {
    normalized[key.toLowerCase()] = headers[key];
  }
  return normalized;
}

// packages/php-wasm/node/src/lib/get-php-loader-module.ts
async function getPHPLoaderModule(version = LatestSupportedPHPVersion) {
  switch (version) {
    case "8.3":
      return await Promise.resolve().then(() => (init_php_8_3(), php_8_3_exports));
    case "8.2":
      return await Promise.resolve().then(() => (init_php_8_2(), php_8_2_exports));
    case "8.1":
      return await Promise.resolve().then(() => (init_php_8_1(), php_8_1_exports));
    case "8.0":
      return await Promise.resolve().then(() => (init_php_8_0(), php_8_0_exports));
    case "7.4":
      return await Promise.resolve().then(() => (init_php_7_4(), php_7_4_exports));
    case "7.3":
      return await Promise.resolve().then(() => (init_php_7_3(), php_7_3_exports));
    case "7.2":
      return await Promise.resolve().then(() => (init_php_7_2(), php_7_2_exports));
    case "7.1":
      return await Promise.resolve().then(() => (init_php_7_1(), php_7_1_exports));
    case "7.0":
      return await Promise.resolve().then(() => (init_php_7_0(), php_7_0_exports));
  }
  throw new Error(`Unsupported PHP version ${version}`);
}

// packages/php-wasm/node/src/lib/networking/outbound-ws-to-tcp-proxy.ts
var dns = __toESM(require("dns"));
var util = __toESM(require("node:util"));
var net2 = __toESM(require("net"));
var http = __toESM(require("http"));

// node_modules/ws/wrapper.mjs
var import_stream = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);

// packages/php-wasm/node/src/lib/networking/utils.ts
var net = __toESM(require("net"));
function debugLog(...args) {
  if (process.env["DEV"] && !process.env["TEST"]) {
    console.log(...args);
  }
}
async function findFreePorts(n) {
  const serversPromises = [];
  for (let i = 0; i < n; i++) {
    serversPromises.push(listenOnRandomPort());
  }
  const servers = await Promise.all(serversPromises);
  const ports = [];
  for (const server of servers) {
    const address = server.address();
    ports.push(address.port);
    server.close();
  }
  return ports;
}
function listenOnRandomPort() {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.listen(0, () => {
      resolve(server);
    });
  });
}

// packages/php-wasm/node/src/lib/networking/outbound-ws-to-tcp-proxy.ts
function log(...args) {
  debugLog("[WS Server]", ...args);
}
var lookup2 = util.promisify(dns.lookup);
function prependByte(chunk, byte) {
  if (typeof chunk === "string") {
    chunk = String.fromCharCode(byte) + chunk;
  } else if (chunk instanceof ArrayBuffer || "byteLength" in chunk) {
    const buffer = new Uint8Array(chunk.byteLength + 1);
    buffer[0] = byte;
    buffer.set(new Uint8Array(chunk), 1);
    chunk = buffer.buffer;
  } else {
    console.log({ chunk });
    throw new Error("Unsupported chunk type: " + typeof chunk);
  }
  return chunk;
}
var COMMAND_CHUNK = 1;
var COMMAND_SET_SOCKETOPT = 2;
function addSocketOptionsSupportToWebSocketClass(WebSocketConstructor) {
  return class PHPWasmWebSocketConstructor extends WebSocketConstructor {
    // @ts-ignore
    send(chunk, callback) {
      return this.sendCommand(COMMAND_CHUNK, chunk, callback);
    }
    setSocketOpt(optionClass, optionName, optionValue) {
      return this.sendCommand(
        COMMAND_SET_SOCKETOPT,
        new Uint8Array([optionClass, optionName, optionValue]).buffer,
        () => void 0
      );
    }
    sendCommand(commandType, chunk, callback) {
      return WebSocketConstructor.prototype.send.call(
        this,
        prependByte(chunk, commandType),
        callback
      );
    }
  };
}
function initOutboundWebsocketProxyServer(listenPort, listenHost = "127.0.0.1") {
  log(`Binding the WebSockets server to ${listenHost}:${listenPort}...`);
  const webServer = http.createServer((request, response) => {
    response.writeHead(403, { "Content-Type": "text/plain" });
    response.write(
      "403 Permission Denied\nOnly websockets are allowed here.\n"
    );
    response.end();
  });
  return new Promise((resolve) => {
    webServer.listen(listenPort, listenHost, function() {
      const wsServer = new import_websocket_server.default({ server: webServer });
      wsServer.on("connection", onWsConnect);
      resolve(webServer);
    });
  });
}
async function onWsConnect(client, request) {
  const clientAddr = client._socket.remoteAddress;
  const clientLog = function(...args) {
    log(" " + clientAddr + ": ", ...args);
  };
  clientLog(
    "WebSocket connection from : " + clientAddr + " at URL " + (request ? request.url : client.upgradeReq.url)
  );
  clientLog(
    "Version " + client.protocolVersion + ", subprotocol: " + client.protocol
  );
  const reqUrl = new URL(`ws://0.0.0.0` + request.url);
  const reqTargetPort = Number(reqUrl.searchParams.get("port"));
  const reqTargetHost = reqUrl.searchParams.get("host");
  if (!reqTargetPort || !reqTargetHost) {
    clientLog("Missing host or port information");
    client.close(3e3);
    return;
  }
  let target;
  const recvQueue = [];
  function flushMessagesQueue() {
    while (recvQueue.length > 0) {
      const msg = recvQueue.pop();
      const commandType = msg[0];
      clientLog("flushing", { commandType }, msg);
      if (commandType === COMMAND_CHUNK) {
        target.write(msg.slice(1));
      } else if (commandType === COMMAND_SET_SOCKETOPT) {
        const SOL_SOCKET = 1;
        const SO_KEEPALIVE = 9;
        const IPPROTO_TCP = 6;
        const TCP_NODELAY = 1;
        if (msg[1] === SOL_SOCKET && msg[2] === SO_KEEPALIVE) {
          target.setKeepAlive(msg[3]);
        } else if (msg[1] === IPPROTO_TCP && msg[2] === TCP_NODELAY) {
          target.setNoDelay(msg[3]);
        }
      } else {
        clientLog("Unknown command type: " + commandType);
        process.exit();
      }
    }
  }
  client.on("message", function(msg) {
    recvQueue.unshift(msg);
    if (target) {
      flushMessagesQueue();
    }
  });
  client.on("close", function(code, reason) {
    clientLog(
      "WebSocket client disconnected: " + code + " [" + reason + "]"
    );
    target.end();
  });
  client.on("error", function(a) {
    clientLog("WebSocket client error: " + a);
    target.end();
  });
  let reqTargetIp;
  if (net2.isIP(reqTargetHost) === 0) {
    clientLog("resolving " + reqTargetHost + "... ");
    const resolution = await lookup2(reqTargetHost);
    reqTargetIp = resolution.address;
    clientLog("resolved " + reqTargetHost + " -> " + reqTargetIp);
  } else {
    reqTargetIp = reqTargetHost;
  }
  clientLog(
    "Opening a socket connection to " + reqTargetIp + ":" + reqTargetPort
  );
  target = net2.createConnection(reqTargetPort, reqTargetIp, function() {
    clientLog("Connected to target");
    flushMessagesQueue();
  });
  target.on("data", function(data) {
    try {
      client.send(data);
    } catch (e) {
      clientLog("Client closed, cleaning up target");
      target.end();
    }
  });
  target.on("end", function() {
    clientLog("target disconnected");
    client.close();
  });
  target.on("error", function(e) {
    clientLog("target connection error", e);
    target.end();
    client.close(3e3);
  });
}

// packages/php-wasm/node/src/lib/networking/inbound-tcp-to-ws-proxy.ts
var import_net = require("net");
function log2(...args) {
  debugLog("[TCP Server]", ...args);
}
function addTCPServerToWebSocketServerClass(wsListenPort, WSServer) {
  return class PHPWasmWebSocketServer extends WSServer {
    constructor(options, callback) {
      const requestedPort = options.port;
      options.port = wsListenPort;
      listenTCPToWSProxy({
        tcpListenPort: requestedPort,
        wsConnectPort: wsListenPort
      });
      super(options, callback);
    }
  };
}
function listenTCPToWSProxy(options) {
  options = {
    wsConnectHost: "127.0.0.1",
    ...options
  };
  const { tcpListenPort, wsConnectHost, wsConnectPort } = options;
  const server = (0, import_net.createServer)();
  server.on("connection", function handleConnection(tcpSource) {
    const inBuffer = [];
    const wsTarget = new import_websocket.default(
      `ws://${wsConnectHost}:${wsConnectPort}/`
    );
    wsTarget.binaryType = "arraybuffer";
    function wsSend(data) {
      wsTarget.send(new Uint8Array(data));
    }
    wsTarget.addEventListener("open", function() {
      log2("Outbound WebSocket connection established");
      while (inBuffer.length > 0) {
        wsSend(inBuffer.shift());
      }
    });
    wsTarget.addEventListener("message", (e) => {
      log2(
        "WS->TCP message:",
        new TextDecoder().decode(e.data)
      );
      tcpSource.write(Buffer.from(e.data));
    });
    wsTarget.addEventListener("close", () => {
      log2("WebSocket connection closed");
      tcpSource.end();
    });
    tcpSource.on("data", function(data) {
      log2("TCP->WS message:", data);
      if (wsTarget.readyState === import_websocket.default.OPEN) {
        while (inBuffer.length > 0) {
          wsSend(inBuffer.shift());
        }
        wsSend(data);
      } else {
        inBuffer.push(data);
      }
    });
    tcpSource.once("close", function() {
      log2("TCP connection closed");
      wsTarget.close();
    });
    tcpSource.on("error", function() {
      log2("TCP connection error");
      wsTarget.close();
    });
  });
  server.listen(tcpListenPort, function() {
    log2("TCP server listening");
  });
}

// packages/php-wasm/node/src/lib/networking/with-networking.ts
async function withNetworking(phpModuleArgs = {}) {
  const [inboundProxyWsServerPort, outboundProxyWsServerPort] = await findFreePorts(2);
  await initOutboundWebsocketProxyServer(outboundProxyWsServerPort);
  return {
    ...phpModuleArgs,
    websocket: {
      ...phpModuleArgs["websocket"] || {},
      url: (_, host, port) => {
        const query = new URLSearchParams({
          host,
          port
        }).toString();
        return `ws://127.0.0.1:${outboundProxyWsServerPort}/?${query}`;
      },
      subprotocol: "binary",
      decorator: addSocketOptionsSupportToWebSocketClass,
      serverDecorator: addTCPServerToWebSocketServerClass.bind(
        null,
        inboundProxyWsServerPort
      )
    }
  };
}

// packages/php-wasm/node/src/lib/node-php.ts
var import_node_fs2 = require("node:fs");

// packages/php-wasm/node/src/lib/with-local-data-module-loader.ts
var import_node_fs = require("node:fs");
function withLocalDataModuleLoader(phpModuleArgs = {}) {
  const originalGetPreloadedPackage = phpModuleArgs["getPreloadedPackage"];
  return {
    ...phpModuleArgs,
    // Emscripten data modules use XHR for loading the packed
    // .data file, unless getPreloadedPackage
    getPreloadedPackage(path) {
      if (originalGetPreloadedPackage) {
        const moduleMaybe = originalGetPreloadedPackage();
        if (moduleMaybe) {
          return moduleMaybe;
        }
      }
      if (!path.endsWith(".data")) {
        console.warn(
          `Invalid data dependency URL "${path}" \u2013 the file extension must be ".data".`
        );
        return;
      }
      if (!path.startsWith("/@fs/")) {
        console.warn(
          `Invalid data dependency format "${path}" \u2013 the URL is expected to start with /@fs/.`
        );
        return;
      }
      path = path.replace(/^\/@fs/, "");
      if (!path.match(/\/wp-[^/']+\.data$/)) {
        console.warn(
          `Invalid data dependency URL "${path}" \u2013 it does not seem to be a WordPress data module.`
        );
        return;
      }
      if (!(0, import_node_fs.existsSync)(path)) {
        console.warn(
          `Invalid data dependency URL "${path}" \u2013 the path does not exist on the disk`
        );
        return;
      }
      const wpData = (0, import_node_fs.readFileSync)(path);
      const wpDataAsUint8Array = wpData.buffer.slice(
        wpData.byteOffset,
        wpData.byteOffset + wpData.byteLength
      );
      return wpDataAsUint8Array;
    }
  };
}

// packages/php-wasm/node/src/lib/node-php.ts
var STRING2 = "string";
var NUMBER2 = "number";
var _NodePHP = class _NodePHP extends BasePHP2 {
  /**
   * Creates a new PHP instance.
   *
   * Dynamically imports the PHP module, initializes the runtime,
   * and sets up networking. It's a shorthand for the lower-level
   * functions like `getPHPLoaderModule`, `loadPHPRuntime`, and
   * `PHP.initializeRuntime`
   *
   * @param phpVersion The PHP Version to load
   * @param options The options to use when loading PHP
   * @returns A new PHP instance
   */
  static async load(phpVersion, options = {}) {
    return await _NodePHP.loadSync(phpVersion, {
      ...options,
      emscriptenOptions: {
        /**
         * Emscripten default behavior is to kill the process when
         * the WASM program calls `exit()`. We want to throw an
         * exception instead.
         */
        quit: function(code, error) {
          throw error;
        },
        ...options.emscriptenOptions || {}
      }
    }).phpReady;
  }
  /**
   * Does what load() does, but synchronously returns
   * an object with the PHP instance and a promise that
   * resolves when the PHP instance is ready.
   *
   * @see load
   */
  static loadSync(phpVersion, options = {}) {
    const php = new _NodePHP(void 0, options.requestHandler);
    const doLoad = async () => {
      const allModules = await Promise.all([
        getPHPLoaderModule(phpVersion),
        ...options.dataModules || []
      ]);
      const [phpLoaderModule, ...dataModules] = allModules;
      let emscriptenOptions = options.emscriptenOptions || {};
      emscriptenOptions = await withNetworking(emscriptenOptions);
      emscriptenOptions = withLocalDataModuleLoader(emscriptenOptions);
      const runtimeId = await loadPHPRuntime(
        phpLoaderModule,
        emscriptenOptions,
        dataModules
      );
      php.initializeRuntime(runtimeId);
    };
    const asyncData = doLoad();
    return {
      php,
      phpReady: asyncData.then(() => php)
    };
  }
  /**
   * Enables host filesystem usage by mounting root
   * directories (e.g. /, /home, /var) into the in-memory
   * virtual filesystem used by this PHP instance, and
   * setting the current working directory to one used by
   * the current node.js process.
   */
  useHostFilesystem() {
    const dirs = (0, import_node_fs2.readdirSync)("/").filter((file) => file !== "dev").map((file) => `/${file}`).filter((file) => (0, import_node_fs2.lstatSync)(file).isDirectory());
    for (const dir of dirs) {
      if (!this.fileExists(dir)) {
        this.mkdirTree(dir);
      }
      this.mount({ root: dir }, dir);
    }
    this.chdir(process.cwd());
  }
  mount(localPath, virtualFSPath) {
    if (!this.fileExists(virtualFSPath)) {
      this.mkdirTree(virtualFSPath);
    }
    this[__private__dont__use].FS.mount(
      this[__private__dont__use].FS.filesystems.NODEFS,
      typeof localPath === "object" ? localPath : { root: localPath },
      virtualFSPath
    );
  }
  /**
   * Starts a PHP CLI session with given arguments.
   *
   * This method can only be used when PHP was compiled with the CLI SAPI
   * and it cannot be used in conjunction with `run()`.
   *
   * Once this method finishes running, the PHP instance is no
   * longer usable and should be discarded. This is because PHP
   * internally cleans up all the resources and calls exit().
   *
   * @param  argv - The arguments to pass to the CLI.
   * @returns The exit code of the CLI session.
   */
  async cli(argv) {
    for (const arg of argv) {
      this[__private__dont__use].ccall(
        "wasm_add_cli_arg",
        null,
        [STRING2],
        [arg]
      );
    }
    try {
      return await this[__private__dont__use].ccall(
        "run_cli",
        null,
        [],
        [],
        {
          async: true
        }
      );
    } catch (error) {
      if (isExitCodeZero(error)) {
        return 0;
      }
      throw error;
    }
  }
  setSkipShebang(shouldSkip) {
    this[__private__dont__use].ccall(
      "wasm_set_skip_shebang",
      null,
      [NUMBER2],
      [shouldSkip ? 1 : 0]
    );
  }
};
__decorateClass([
  rethrowFileSystemError("Could not mount {path}")
], _NodePHP.prototype, "mount", 1);
var NodePHP = _NodePHP;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  NodePHP,
  getPHPLoaderModule,
  withNetworking
});
